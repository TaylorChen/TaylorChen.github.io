---
title: "PHP-FPM 性能调优指南"
date: 2016-08-17
categories: [技术, PHP]
tags: [技术, PHP, 性能]
---

本文系统性梳理 PHP-FPM 在高并发与高性能场景下的完整优化路径：从 Linux 操作系统内核与网络栈、到 Nginx 与 PHP-FPM 的通讯方式与参数调优，再到 PHP 运行时与业务代码层面的最佳实践，并给出生产可落地的配置示例与故障排查清单。目标读者为正在建设或运营中大型 PHP Web 服务的工程师与架构师。

### 读者收益
- 清晰的容量规划方法与关键监控口径（QPS、P95/P99、错误率、队列长度）；
- 一套可复用的 Linux 内核与网络栈调优清单；
- PHP-FPM `pm` 模式与核心参数的取舍建议与安全边界；
- OPcache/JIT、realpath cache、Composer 自动加载与 APCu 等在生产中的最佳实践；
- 业务代码性能“十项准则”与常见反模式清单；
- 标准化配置样例：sysctl、systemd、Nginx、FPM pool 与 OPcache。

---

## 一、性能目标与测量口径

在优化之前，先把“好”的定义固定下来。

- 指标分层：
  - 应用端：QPS、TP95/TP99 响应时间、错误率、超时率；
  - 资源端：CPU 使用率、上下文切换、内存使用与 page faults、网络丢包/重传、磁盘延时；
  - PHP-FPM 专属：`/status` 的 `accepted conn`、`listen queue`、`idle/active processes`、`max children reached`。
- 容量评估：
  - 峰值并发估算：通过压测或生产监控得到单位请求平均 CPU 时间与内存峰值；
  - Little's Law：\( L = \lambda \times W \)，队列长度与延迟直接相关；
  - 过载保护：在上游（Nginx 或网关）设置合理的连接与请求排队上限，宁可快速失败，避免雪崩。

---

## 二、Linux 系统层调优（以现代 Linux 为主）

面向 PHP-FPM 的系统调优主要围绕“文件句柄/进程数量”“网络连接队列与吞吐”“内存与 I/O”三个方面展开。

### 2.1 文件句柄与进程限制

- 系统级：
  - `fs.file-max` 与 `fs.nr_open` 调高总句柄上限；
  - 结合进程数量与连接数，预留 2～3 倍余量。
- 服务级：使用 systemd 覆盖 PHP-FPM 单元，设置 `LimitNOFILE`，并确保 `TasksMax` 足够大。

```ini
# /etc/systemd/system/php-fpm.service.d/override.conf
[Service]
LimitNOFILE=1048576
TasksMax=infinity
Delegate=yes
```

```bash
sudo systemctl daemon-reload
sudo systemctl restart php-fpm
```

### 2.2 CPU 与调度

- 保持 `irqbalance` 开启，避免中断集中到单核。
- 大流量场景可考虑为 Nginx 绑定少量核心、FPM 绑定其余核心，减少争用：

```ini
# /etc/systemd/system/nginx.service.d/cpu.conf
[Service]
CPUAffinity=0-1

# /etc/systemd/system/php-fpm.service.d/cpu.conf
[Service]
CPUAffinity=2-15
```

### 2.3 内存、THP 与 Swap

- 关闭或降低 Transparent Huge Pages（THP），避免不可预期的停顿：
```bash
echo never | sudo tee /sys/kernel/mm/transparent_hugepage/enabled
```
- 减小 Swap 干预：
```bash
sysctl -w vm.swappiness=10
```
- 关注 `vm.overcommit_memory` 与 OOM Killer 行为，容器化场景优先通过 cgroup/容器限制。

### 2.4 网络栈与连接队列

- 增大 listen backlog 与队列，减少瞬时拥塞丢包：
```bash
sysctl -w net.core.somaxconn=65535
sysctl -w net.core.netdev_max_backlog=250000
sysctl -w net.ipv4.tcp_max_syn_backlog=262144
```
- 发送/接收缓冲区与窗口扩展：
```bash
sysctl -w net.ipv4.tcp_rmem="4096 87380 134217728"
sysctl -w net.ipv4.tcp_wmem="4096 65536 134217728"
sysctl -w net.core.rmem_max=134217728
sysctl -w net.core.wmem_max=134217728
```
- TIME_WAIT 管理：服务端配合长连接降低 TIME_WAIT 产生；谨慎使用 `tcp_tw_reuse`（新内核对服务端无效），不要依赖 `tcp_tw_recycle`（已移除）。
- 连接安全：确保 `net.ipv4.tcp_syncookies=1` 开启以应对 SYN flood。

建议汇总到 `/etc/sysctl.d/99-tuning.conf` 并持久化。

### 2.5 磁盘与 I/O

- SSD 场景优先 `mq-deadline` 或 `none` 调度器；日志分区与数据分区独立；
- 调整 `vm.dirty_background_ratio` 与 `vm.dirty_ratio` 限制脏页冲刷对尾延迟影响。

---

## 三、Nginx 与 PHP-FPM 通讯拓扑

### 3.1 Unix Socket vs TCP

- 同机通讯优先 Unix Socket（更低开销），配置更简单；
- 跨机或容器网络必须使用 TCP；
- 配置 `listen.backlog` 与 Nginx `fastcgi_connect_timeout`/`fastcgi_read_timeout` 对齐，避免误判超时。

### 3.2 Nginx FastCGI 关键项

```nginx
upstream php_backend {
    server unix:/run/php-fpm/www.sock;
    # TCP 场景可配置 keepalive，Socket 不需要
}

server {
    location ~ \.php$ {
        include fastcgi_params;
        fastcgi_pass   php_backend;
        fastcgi_keep_conn on;           # 与 FPM 维持长连接
        fastcgi_connect_timeout 1s;
        fastcgi_send_timeout 5s;
        fastcgi_read_timeout  5s;       # 视业务复杂度调整
        fastcgi_buffers 32 32k;
        fastcgi_buffer_size 64k;
    }
}
```

---

## 四、PHP-FPM 关键参数与策略

FPM 通过 Pool 管理工作进程。核心在 `pm` 模式与并发容量控制。

### 4.1 pm 模式如何选

- `pm = static`：固定进程数，最可预期，适合高负载稳定流量；
- `pm = dynamic`：基于空闲/繁忙动态伸缩，线上最常见；
- `pm = ondemand`：按请求惰性创建，适合低频/突发场景，冷启动成本较高。

### 4.2 并发容量与内存估算

- 经验公式：`pm.max_children = floor(可用内存 / 单进程RSS峰值)`；
- 实测方法：
  - 开启压测后观察 `ps -o pid,rss,cmd -C php-fpm` 或 `/proc/<pid>/status`；
  - 以 P95 RSS 作为保守估计，并预留 15% 以上系统余量；
  - 关注 `max children reached`，出现即表示进程池耗尽，需要增大 `max_children` 或优化单请求资源占用。

### 4.3 池配置示例（www.conf）

```ini
[www]
user = www-data
group = www-data
listen = /run/php-fpm/www.sock
listen.owner = www-data
listen.group = www-data
listen.mode = 0660
listen.backlog = 65535

pm = dynamic
pm.max_children = 128
pm.start_servers = 16
pm.min_spare_servers = 16
pm.max_spare_servers = 64

pm.max_requests = 2000          ; 防止内存泄漏或碎片长期累积
process_control_timeout = 10s
request_terminate_timeout = 10s ; 兜底中断超时请求
request_slowlog_timeout = 3s
slowlog = /var/log/php-fpm/slow.log

catch_workers_output = yes
php_admin_value[memory_limit] = 256M
php_admin_value[error_log] = /var/log/php-fpm/www-error.log
php_admin_flag[log_errors] = on
```

说明：
- `pm.max_requests` 过小会增加进程重启开销，过大难以及时回收泄漏；
- 合理设置 `request_terminate_timeout` 与 `request_slowlog_timeout`，协同 Nginx `fastcgi_read_timeout`，保证故障可恢复；
- 多业务隔离：按应用拆分 pool，避免相互影响。

### 4.4 状态页与健康检查

```ini
pm.status_path = /status
ping.path = /ping
ping.response = pong
```

结合 Nginx 暴露只读管理端点，并以 Prometheus/StatsD 抓取指标。

---

## 五、PHP 运行时：OPcache、JIT 与路径缓存

### 5.1 OPcache 必备配置（生产）

```ini
; /etc/php.d/10-opcache.ini
opcache.enable=1
opcache.enable_cli=0
opcache.memory_consumption=256
opcache.interned_strings_buffer=16
opcache.max_accelerated_files=100000
opcache.validate_timestamps=0        ; 生产禁用文件变更检查
opcache.revalidate_freq=0
opcache.save_comments=1
opcache.fast_shutdown=1
; 可选：文件缓存，容器内频繁重启时有价值
; opcache.file_cache=/var/cache/php-opcache
```

部署发布后务必 `reload` FPM 或使缓存失效，以加载新字节码。

### 5.2 PHP 8 JIT（谨慎评估）

Web I/O 密集型负载对 JIT 的收益有限。若要启用，建议：

```ini
opcache.jit_buffer_size=64M
opcache.jit=1205   ; tracing JIT，适度激进
```

上线前请通过基准压测与业务真实场景对比，确认稳定性与收益。

### 5.3 realpath 与 include 优化

```ini
realpath_cache_size=4096k
realpath_cache_ttl=600
```

避免在热路径做大量 `file_exists()`/`is_file()`，并减少动态 `include`。生产禁用 `allow_url_fopen`，降低 I/O 风险。

---

## 六、业务代码性能最佳实践（FPM 模式）

### 6.1 缓存分层

- 进程内缓存：APCu 存储热点小对象，适合只读配置/路由表。注意 FPM 进程间不共享；
- 分布式缓存：Redis/Memcached 缓存热点数据，设置合理过期与一致性策略；
- 页面与片段缓存：结合 Nginx `proxy_cache` 或应用内缓存，命中率优先。

```php
// APCu 示例：仅适合单进程内命中
$key = 'hot_config_v1';
$val = apcu_fetch($key, $ok);
if (!$ok) {
    $val = load_config_from_db();
    apcu_store($key, $val, 300);
}
```

### 6.2 数据库与外部依赖

- 谨慎使用持久连接（PDO persistent），评估连接复用与连接泄漏风险；
- 统一定义客户端超时、重试与熔断策略，避免阻塞放大；
- 通过批量查询/写入降低往返（N+1 是性能天敌）。

### 6.3 自动加载与 Composer

- 生产构建使用 `composer dump-autoload -o -a`，减少运行时扫描；
- 避免在热路径中动态组合类名或路径，提升 OPcache 命中效率；
- 若使用 APCu 优化 Composer autoload，可开启 `apcu-autoloader`：

```json
{
  "config": {"apcu-autoloader": true}
}
```

### 6.4 代码层微优化与反模式

- 使用 `isset($arr['k'])` 替代 `array_key_exists('k', $arr)`；
- 循环中缓存 `count($arr)`；
- 字符串拼接优先 `.` 而非频繁 `sprintf`；
- 避免在热路径调用正则，改用更轻量的字符串函数；
- 控制异常用作流程分支的频度；
- 会话：使用 Redis Session，并开启 `session.lazy_write=1`、`session.use_strict_mode=1`；
- 降低全局状态与单例滥用，利于并发安全与测试。

### 6.5 超时、降级与排队

- 为外部依赖设置严格超时（连接/读写）与预算；
- 为不可用下游提供读降级或本地兜底；
- 对突发流量采用限流与排队，保护 FPM 进程池。

---

## 七、容量规划与发布策略

- 预估 `pm.max_children` 依据 P95 RSS 与可用内存，预留系统与 page cache 空间；
- 滚动发布：先下线流量（Nginx `drain`/权重降为 0），再 `reload` FPM，避免中断连接；
- 弹性扩缩：容器或虚机水平扩展往往优于单机“顶配”。

---

## 八、监控、压测与故障排查

### 8.1 监控建议

- Nginx：请求率、状态码分布、`upstream_response_time`、队列/连接数；
- FPM：`/status` 指标、`max children reached` 告警、慢日志采样；
- 系统：CPU 利用、软中断、上下文切换、TCP 重传/丢包、磁盘延迟；
- 应用：关键函数耗时分布与火焰图（XHProf/Blackfire/eBPF）。

### 8.2 压测要点

- 区分冷/热缓存表现；
- 启用与生产一致的 OPcache/realpath/composer 优化；
- 采用阶段性压力递增与稳态长跑，观察尾延迟与 GC/重启行为。

### 8.3 常用排查命令

```bash
ss -lntp | grep php-fpm
ps -o pid,ppid,rss,pcpu,cmd -C php-fpm
tail -f /var/log/php-fpm/www-error.log
tail -f /var/log/php-fpm/slow.log
journalctl -u php-fpm -n 200 -f
dmesg | egrep -i 'oom|killed'
```

慢日志与火焰图结合能快速定位热点：先用慢日志发现可疑入口，再以火焰图拆解 CPU 时间。

---

## 九、标准化配置样例

### 9.1 sysctl（/etc/sysctl.d/99-tuning.conf）

```conf
fs.file-max=2097152
net.core.somaxconn=65535
net.core.netdev_max_backlog=250000
net.ipv4.tcp_max_syn_backlog=262144
net.core.rmem_max=134217728
net.core.wmem_max=134217728
net.ipv4.tcp_rmem=4096 87380 134217728
net.ipv4.tcp_wmem=4096 65536 134217728
net.ipv4.tcp_syncookies=1
vm.swappiness=10
```

### 9.2 systemd（Limit 与 CPU 绑定）

```ini
[Service]
LimitNOFILE=1048576
TasksMax=infinity
CPUAffinity=2-15
```

### 9.3 Nginx FastCGI 片段

```nginx
fastcgi_connect_timeout 1s;
fastcgi_send_timeout 5s;
fastcgi_read_timeout 5s;
fastcgi_buffers 32 32k;
fastcgi_buffer_size 64k;
fastcgi_keep_conn on;
```

### 9.4 FPM Pool 片段

```ini
pm = dynamic
pm.max_children = 128
pm.max_requests = 2000
request_terminate_timeout = 10s
request_slowlog_timeout = 3s
slowlog = /var/log/php-fpm/slow.log
```

### 9.5 OPcache 建议

```ini
opcache.enable=1
opcache.memory_consumption=256
opcache.max_accelerated_files=100000
opcache.validate_timestamps=0
```

---

## 十、Checklist（上线前自查）

- [ ] sysctl 已落盘，网络 backlog 与缓冲区放开；
- [ ] systemd `LimitNOFILE/TasksMax` 生效；
- [ ] Nginx 与 FPM backlog、超时与 keepalive 一致；
- [ ] OPcache 命中率与内存占用达标；
- [ ] FPM `/status` 指标健康、无 `max children reached` 持续告警；
- [ ] 慢日志与火焰图能力就绪；
- [ ] 压测覆盖冷/热缓存，尾延迟达标；
- [ ] 发布采用灰度/滚动，具备快速回滚。

---

## 结语

性能优化从来不是单点参数的“魔法值”，而是一条端到端的工程链路：系统内核提供足够的资源与稳态，Nginx 与 FPM 协同对齐超时与队列，OPcache/自动加载与路径缓存确保运行时轻量，业务代码以缓存为中心并控制外部依赖的不可控性。循着本文的方法论与配置清单，结合你们的业务负载画像与监控数据，才能得到真正可复制、可演进的高性能 PHP-FPM 生产实践。
