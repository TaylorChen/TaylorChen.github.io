<!DOCTYPE html>
<html lang="zh-CN"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>MySQL Online DDL机制导致 | TayloyChen Blog</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="MySQL Online DDL机制导致" />
<meta name="author" content="TayloyChen" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="解析 Online DDL row log 重放机制为何会触发 Duplicate entry，给出时间线、源码指引与工程上的可行规避策略（低峰变更/EXCLUSIVE/分阶段变更）。" />
<meta property="og:description" content="解析 Online DDL row log 重放机制为何会触发 Duplicate entry，给出时间线、源码指引与工程上的可行规避策略（低峰变更/EXCLUSIVE/分阶段变更）。" />
<link rel="canonical" href="http://localhost:4000/%E6%8A%80%E6%9C%AF/mysql/2019/08/02/MySQL-Online-DDL%E6%9C%BA%E5%88%B6%E5%AF%BC%E8%87%B4Duplicate-entry%E9%94%99%E8%AF%AF.html" />
<meta property="og:url" content="http://localhost:4000/%E6%8A%80%E6%9C%AF/mysql/2019/08/02/MySQL-Online-DDL%E6%9C%BA%E5%88%B6%E5%AF%BC%E8%87%B4Duplicate-entry%E9%94%99%E8%AF%AF.html" />
<meta property="og:site_name" content="TayloyChen Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-08-02T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="MySQL Online DDL机制导致" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"TayloyChen","url":"https://taylorchen.github.io"},"dateModified":"2025-08-09T11:32:16+08:00","datePublished":"2019-08-02T00:00:00+08:00","description":"解析 Online DDL row log 重放机制为何会触发 Duplicate entry，给出时间线、源码指引与工程上的可行规避策略（低峰变更/EXCLUSIVE/分阶段变更）。","headline":"MySQL Online DDL机制导致","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/%E6%8A%80%E6%9C%AF/mysql/2019/08/02/MySQL-Online-DDL%E6%9C%BA%E5%88%B6%E5%AF%BC%E8%87%B4Duplicate-entry%E9%94%99%E8%AF%AF.html"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/images/favicons/favicon-96x96.png"},"name":"TayloyChen"},"url":"http://localhost:4000/%E6%8A%80%E6%9C%AF/mysql/2019/08/02/MySQL-Online-DDL%E6%9C%BA%E5%88%B6%E5%AF%BC%E8%87%B4Duplicate-entry%E9%94%99%E8%AF%AF.html"}</script>
<!-- End Jekyll SEO tag -->

  
  
    <meta property="article:modified_time" content="2025-08-09T11:32:16+08:00">
  
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="alternate" type="application/atom+xml" href="http://localhost:4000/feed.xml" title="TayloyChen Blog" />
  <link rel="icon" href="/assets/images/favicons/favicon.ico" type="image/x-icon">
  
  
    <meta property="og:image" content="http://localhost:4000/assets/images/2e9ea54a25bedd353d5e06c076d9c7e4.jpeg">
    <meta name="twitter:image" content="http://localhost:4000/assets/images/2e9ea54a25bedd353d5e06c076d9c7e4.jpeg">
  
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/">TayloyChen Blog</a>
    <nav class="site-nav">
      <a class="page-link" href="/">首页</a>
      <a class="page-link" href="/categories/">分类</a>
      <a class="page-link" href="/tags/">标签</a>
      <a class="page-link" href="/archives/">归档</a>
      <a class="page-link" href="/search/">搜索</a>
      <a class="page-link" href="/about/">关于</a>
    </nav>
  </div>
</header>


<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">
  <header>
    <h1>MySQL Online DDL机制导致</h1>
    <p class="post-meta">
      <time datetime="2019-08-02T00:00:00+08:00">2019-08-02</time>
       · 最后更新于 <time datetime="2025-08-09T11:32:16+08:00">2025-08-09</time>
       · 技术 / MySQL
       · 技术, MySQL, Online DDL, 唯一键, 重放
    </p>
    
      <meta name="description" content="解析 Online DDL row log 重放机制为何会触发 Duplicate entry，给出时间线、源码指引与工程上的可行规避策略（低峰变更/EXCLUSIVE/分阶段变更）。">
    
    
      <meta name="keywords" content="技术, MySQL, Online DDL, 唯一键, 重放">
    
  </header>

  <div class="post-body" id="post-body">
    <aside id="toc"></aside>
    <div id="post-content">
      <h1 id="mysql-online-ddl机制导致duplicate-entry错误的分析">MySQL Online DDL机制导致”Duplicate entry”错误的分析</h1>

<h2 id="问题场景精准定位">问题场景精准定位</h2>

<p>您描述的场景非常典型：</p>
<ul>
  <li>手机号字段<strong>早已存在</strong>唯一索引</li>
  <li>原表中该手机号记录<strong>早已存在</strong>（”很早以前就存在数据库中”）</li>
  <li>应用程序<strong>正确使用</strong><code class="language-plaintext highlighter-rouge">INSERT ... ON DUPLICATE KEY UPDATE</code></li>
  <li>问题发生在<strong>执行非唯一索引相关的DDL操作</strong>时（如修改其他字段）</li>
</ul>

<p>这正是阿里云文档中提到的第三种场景：”使用结构设计功能进行不涉及唯一约束或唯一索引组成字段调整的DDL操作”时出现的冲突。</p>

<h2 id="核心问题online-ddl的row-log重放机制">核心问题：Online DDL的row log重放机制</h2>

<h3 id="1-mysql-online-ddl执行流程关键阶段">1. MySQL Online DDL执行流程（关键阶段）</h3>

<p>当执行一个不涉及唯一索引的DDL操作（如修改其他字段）时，MySQL的Online DDL流程如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T0: 开始DDL，创建中间表(#sql-ibxxx)
T1: 将原表数据复制到中间表（此时中间表已包含phone='xxxxx'）
T2: 开始记录DML变更到row log
T3: 应用程序执行INSERT ... ON DUPLICATE KEY UPDATE
T4: 将row log中的变更应用到中间表
T5: 原子替换原表与中间表
</code></pre></div></div>

<h3 id="2-问题发生的精确技术原因">2. 问题发生的精确技术原因</h3>

<p><strong>关键点：row log记录的是原始SQL操作，而非实际执行的操作</strong></p>

<p>当应用程序执行：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">users</span><span class="p">(</span><span class="n">phone</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="s1">'xxxxx'</span><span class="p">,</span> <span class="s1">'张三'</span><span class="p">)</span> 
<span class="k">ON</span> <span class="n">DUPLICATE</span> <span class="k">KEY</span> <span class="k">UPDATE</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'张三'</span><span class="p">;</span>
</code></pre></div></div>

<p>MySQL的处理流程：</p>
<ol>
  <li>检测到唯一键冲突（phone=’xxxxx’已存在）</li>
  <li><strong>将INSERT操作内部转换为UPDATE操作</strong></li>
  <li>执行UPDATE，成功完成</li>
</ol>

<p><strong>但是</strong>，在Online DDL过程中：</p>
<ul>
  <li>MySQL的row log<strong>只记录原始SQL语句</strong>（INSERT…）</li>
  <li><strong>不记录</strong>MySQL内部将其转换为UPDATE的事实</li>
  <li>当重放row log到中间表时，MySQL会<strong>直接执行原始的INSERT语句</strong></li>
</ul>

<h3 id="3-冲突发生的具体时间线">3. 冲突发生的具体时间线</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T0: 开始DDL，创建中间表
T1: 中间表从原表复制数据（已包含phone='xxxxx'）
T2: 开始记录row log
T3: 应用程序执行INSERT ... ON DUPLICATE KEY UPDATE
    - 原表：检测到冲突，自动转为UPDATE，成功
    - row log记录：INSERT INTO ... VALUES('xxxxx', ...)
T4: DDL尝试将row log应用到中间表
    - 中间表：已从T1复制拥有phone='xxxxx'的记录
    - 执行INSERT操作 → 触发Duplicate entry错误
T5: DDL操作失败
</code></pre></div></div>

<h2 id="为什么insert--on-duplicate-key-update在这种场景下失效">为什么INSERT … ON DUPLICATE KEY UPDATE在这种场景下失效？</h2>

<h3 id="1-执行环境差异">1. 执行环境差异</h3>

<table>
  <thead>
    <tr>
      <th>环境</th>
      <th>处理方式</th>
      <th>结果</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>正常执行环境</strong></td>
      <td>MySQL解析并执行完整SQL，识别ON DUPLICATE子句</td>
      <td>INSERT转为UPDATE，无错误</td>
    </tr>
    <tr>
      <td><strong>Online DDL row log重放</strong></td>
      <td>仅执行row log中记录的原始INSERT语句</td>
      <td>直接尝试插入，忽略ON DUPLICATE逻辑</td>
    </tr>
  </tbody>
</table>

<h3 id="2-技术本质row-log的局限性">2. 技术本质：row log的局限性</h3>

<p>MySQL的row log机制设计用于<strong>高效记录和重放DML操作</strong>，但有重要限制：</p>
<ul>
  <li><strong>只记录物理操作</strong>，不记录SQL语义</li>
  <li><strong>不保存执行上下文</strong>（如唯一键检查结果）</li>
  <li><strong>不考虑约束触发的隐式操作转换</strong></li>
</ul>

<p>当MySQL执行<code class="language-plaintext highlighter-rouge">INSERT ... ON DUPLICATE KEY UPDATE</code>时，这是一个<strong>逻辑操作</strong>，会被转换为<strong>物理操作</strong>（UPDATE）。但row log只记录了最初的逻辑操作（INSERT），没有记录最终的物理操作（UPDATE）。</p>

<h3 id="3-中间表状态与原表状态的差异">3. 中间表状态与原表状态的差异</h3>

<p>在T1到T4期间，原表和中间表的状态可能不同步：</p>
<ul>
  <li>原表：通过ON DUPLICATE KEY机制成功处理了冲突</li>
  <li>中间表：没有机会执行相同的逻辑转换</li>
  <li>当直接应用原始INSERT时，中间表严格检查唯一约束，导致失败</li>
</ul>

<h2 id="mysql底层源码级分析">MySQL底层源码级分析</h2>

<p>在MySQL源码中，这一问题的根源在于：</p>

<ol>
  <li><strong>sql/ha_innobase.cc</strong>中的<code class="language-plaintext highlighter-rouge">row_log_apply</code>函数：
    <ul>
      <li>处理row log重放时，直接执行记录的原始操作</li>
      <li>不会重新解析SQL或应用任何约束转换逻辑</li>
    </ul>
  </li>
  <li><strong>sql/sql_insert.cc</strong>中的<code class="language-plaintext highlighter-rouge">mysql_insert</code>函数：
    <ul>
      <li>在正常执行路径中，会调用<code class="language-plaintext highlighter-rouge">handle_duplicates</code>处理唯一键冲突</li>
      <li>但在row log重放路径中，绕过了这一逻辑</li>
    </ul>
  </li>
  <li><strong>row/row0log.cc</strong>中的row log机制：
    <ul>
      <li>仅记录最基础的行变更（INSERT/UPDATE/DELETE）</li>
      <li>不记录高级SQL语句的语义信息</li>
    </ul>
  </li>
</ol>

<h2 id="为什么高并发会加剧这个问题">为什么高并发会加剧这个问题？</h2>

<ol>
  <li><strong>row log积压</strong>：高并发下，T1到T4之间会产生大量DML操作，row log变大</li>
  <li><strong>状态差异扩大</strong>：原表与中间表的状态差异随时间推移而增大</li>
  <li><strong>重放复杂度增加</strong>：更多操作需要重放，冲突概率呈指数级增长</li>
</ol>

<h2 id="解决方案的技术本质">解决方案的技术本质</h2>

<h3 id="1-根本原因">1. 根本原因</h3>
<ul>
  <li>MySQL Online DDL的row log机制无法正确处理<code class="language-plaintext highlighter-rouge">ON DUPLICATE KEY</code>语句</li>
  <li>row log记录的是原始SQL，而非实际执行的物理操作</li>
</ul>

<h3 id="2-有效解决方案">2. 有效解决方案</h3>

<h4 id="方案a避免在业务高峰期执行ddl">方案A：避免在业务高峰期执行DDL</h4>
<ul>
  <li>选择低峰期执行DDL操作，减少row log积压</li>
  <li>降低原表与中间表状态差异</li>
</ul>

<h4 id="方案b使用lockexclusive">方案B：使用LOCK=EXCLUSIVE</h4>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">users</span> <span class="k">MODIFY</span> <span class="k">COLUMN</span> <span class="n">age</span> <span class="nb">INT</span> <span class="k">COMMENT</span> <span class="s1">'年龄'</span> <span class="k">LOCK</span><span class="o">=</span><span class="k">EXCLUSIVE</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>完全阻塞DML操作，确保数据一致性</li>
  <li>代价：DDL执行期间表不可写</li>
</ul>

<h4 id="方案c分阶段执行最佳实践">方案C：分阶段执行（最佳实践）</h4>
<ol>
  <li>先添加新列（不修改原列）</li>
  <li>应用程序双写新旧列</li>
  <li>数据迁移完成后，再删除旧列
    <ul>
      <li>避免长时间Online DDL操作</li>
      <li>减少冲突窗口期</li>
    </ul>
  </li>
</ol>

<h3 id="3-为什么先查询再插入无效">3. 为什么”先查询再插入”无效？</h3>
<p>即使应用程序改为：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">users</span> <span class="k">WHERE</span> <span class="n">phone</span><span class="o">=</span><span class="s1">'xxxxx'</span><span class="p">;</span>
<span class="c1">-- 如果存在则UPDATE，否则INSERT</span>
</code></pre></div></div>
<p>在Online DDL期间：</p>
<ul>
  <li>SELECT可能在T1前执行，看到记录存在</li>
  <li>但INSERT/UPDATE操作在T2后执行</li>
  <li>row log重放时仍会尝试插入已存在的记录</li>
</ul>

<h2 id="结论">结论</h2>

<ol>
  <li>
    <p><strong>技术本质</strong>：MySQL Online DDL的row log机制<strong>无法正确处理<code class="language-plaintext highlighter-rouge">INSERT ... ON DUPLICATE KEY UPDATE</code>语句</strong>，因为它只记录原始INSERT语句，不记录MySQL内部将其转换为UPDATE的事实。</p>
  </li>
  <li>
    <p><strong>问题根源</strong>：当row log中的原始INSERT语句被应用到中间表时，中间表已通过数据复制拥有相同唯一键的记录，导致严格唯一性检查失败。</p>
  </li>
  <li>
    <p><strong>这不是应用程序错误</strong>：即使应用程序正确使用了<code class="language-plaintext highlighter-rouge">ON DUPLICATE KEY</code>，在Online DDL过程中仍会失败，这是MySQL底层机制的限制。</p>
  </li>
  <li>
    <p><strong>解决方案</strong>：避免在高并发期间执行DDL操作，或使用LOCK=EXCLUSIVE强制串行化，或采用分阶段变更策略。</p>
  </li>
</ol>

    </div>
  </div>

  
  
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
    
    
    
    
  
    
    
    
      
        
    
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
    
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
    
    
    
    
  
    
    
    
      
        
    
    
    
    
  
  <section class="related-posts">
    <h2>相关阅读</h2>
    <ul>
      
        <li><a href="/%E6%8A%80%E6%9C%AF/nginx/2025/07/01/Nginx-Ingress-%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5.html">Nginx Ingress 高并发场景优化实践</a> <small>(2025-07-01)</small></li>
      
        <li><a href="/%E6%8A%80%E6%9C%AF/nginx/2025/06/28/Nginx-%E9%9B%B6%E5%81%9C%E6%9C%BA%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E4%B8%8E%E5%9B%9E%E6%BB%9A%E7%AD%96%E7%95%A5.html">Nginx 零停机灰度发布与回滚策略</a> <small>(2025-06-28)</small></li>
      
        <li><a href="/%E6%8A%80%E6%9C%AF/nginx/2023/12/05/Nginx-Ingress-%E5%9C%A8Kubernetes%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E9%85%8D%E7%BD%AE.html">Nginx Ingress 在 Kubernetes 的高可用配置</a> <small>(2023-12-05)</small></li>
      
        <li><a href="/%E6%8A%80%E6%9C%AF/mysql/2023/02/27/MySQL-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E4%BB%8E-explain-%E5%88%B0%E7%81%AB%E7%84%B0%E5%9B%BE.html">MySQL-慢查询优化-从-explain-到火焰图</a> <small>(2023-02-27)</small></li>
      
        <li><a href="/%E6%8A%80%E6%9C%AF/golang/2022/10/07/Go-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-Channel%E4%B8%8EContext%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html">Go 并发模型：Channel 与 Context 最佳实践</a> <small>(2022-10-07)</small></li>
      
    </ul>
  </section>
  

  <footer class="post-footer">
    <div class="share">
      <a href="https://twitter.com/intent/tweet?text=MySQL%20Online%20DDL%E6%9C%BA%E5%88%B6%E5%AF%BC%E8%87%B4&url=http://localhost:4000/%E6%8A%80%E6%9C%AF/mysql/2019/08/02/MySQL-Online-DDL%E6%9C%BA%E5%88%B6%E5%AF%BC%E8%87%B4Duplicate-entry%E9%94%99%E8%AF%AF.html" target="_blank">Share to X</a>
      <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/%E6%8A%80%E6%9C%AF/mysql/2019/08/02/MySQL-Online-DDL%E6%9C%BA%E5%88%B6%E5%AF%BC%E8%87%B4Duplicate-entry%E9%94%99%E8%AF%AF.html" target="_blank" style="margin-left:12px;">Share to Facebook</a>
    </div>

    
    <section id="comments" style="margin-top: 24px;">
      <script src="https://giscus.app/client.js"
        data-repo=""
        data-repo-id=""
        data-category="General"
        data-category-id=""
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="light"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
      </script>
    </section>
    
  </footer>
</article>

<button id="back-to-top" title="回到顶部">↑</button>

<script>
// 构建目录
(function(){
  const content = document.getElementById('post-content');
  const toc = document.getElementById('toc');
  if (!content || !toc) return;
  const headings = content.querySelectorAll('h1, h2, h3');
  if (!headings.length) return;
  const ul = document.createElement('ul');
  headings.forEach(h => {
    if (!h.id) h.id = h.textContent.trim().toLowerCase().replace(/\s+/g, '-');
    const li = document.createElement('li');
    li.style.marginLeft = ({H1:0,H2:12,H3:24})[h.tagName] + 'px';
    const a = document.createElement('a');
    a.href = '#' + h.id;
    a.textContent = h.textContent;
    li.appendChild(a);
    ul.appendChild(li);
  });
  const title = document.createElement('div');
  title.textContent = '目录';
  title.style.fontWeight = 'bold';
  title.style.marginBottom = '8px';
  toc.appendChild(title);
  toc.appendChild(ul);
})();

// 代码复制按钮
(function(){
  document.querySelectorAll('pre > code').forEach(code => {
    const pre = code.parentElement;
    const btn = document.createElement('button');
    btn.textContent = '复制';
    btn.className = 'copy-btn';
    btn.onclick = async () => {
      try { await navigator.clipboard.writeText(code.innerText); btn.textContent = '已复制'; setTimeout(()=>btn.textContent='复制',1000);} catch(e) {}
    };
    pre.style.position = 'relative';
    btn.style.position = 'absolute';
    btn.style.right = '8px';
    btn.style.top = '8px';
    pre.appendChild(btn);
  });
})();

// 回到顶部
(function(){
  const btn = document.getElementById('back-to-top');
  const onscroll = () => { btn.style.display = window.scrollY > 300 ? 'block' : 'none'; };
  window.addEventListener('scroll', onscroll); onscroll();
  btn.onclick = () => window.scrollTo({top:0, behavior:'smooth'});
})();

// 图片懒加载
(function(){
  document.querySelectorAll('#post-content img').forEach(img => {
    img.loading = 'lazy';
    if (!img.hasAttribute('alt') || img.getAttribute('alt') === '') {
      try {
        const u = new URL(img.src, window.location.origin);
        const name = (u.pathname.split('/').pop() || '').split('.')[0];
        if (name) img.setAttribute('alt', decodeURIComponent(name));
      } catch (e) {}
    }
  });
})();
</script>

<style>
.post-body{display:flex; gap:24px}
#toc{min-width:200px; max-width:240px; position:sticky; top:80px; height:max-content}
#post-content{flex:1}
#back-to-top{position:fixed; right:16px; bottom:24px; display:none; padding:8px 10px}
.copy-btn{font-size:12px; padding:2px 6px}
@media (max-width: 900px){ .post-body{flex-direction:column;} #toc{position:static;}}
</style><script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySQL Online DDL机制导致",
  "description": "解析 Online DDL row log 重放机制为何会触发 Duplicate entry，给出时间线、源码指引与工程上的可行规避策略（低峰变更/EXCLUSIVE/分阶段变更）。",
  "datePublished": "2019-08-02T00:00:00+08:00",
  "dateModified": "2025-08-09T11:32:16+08:00",
  "author": {
    "@type": "Person",
    "name": "TayloyChen"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:4000/%E6%8A%80%E6%9C%AF/mysql/2019/08/02/MySQL-Online-DDL%E6%9C%BA%E5%88%B6%E5%AF%BC%E8%87%B4Duplicate-entry%E9%94%99%E8%AF%AF.html"
  },
  "url": "http://localhost:4000/%E6%8A%80%E6%9C%AF/mysql/2019/08/02/MySQL-Online-DDL%E6%9C%BA%E5%88%B6%E5%AF%BC%E8%87%B4Duplicate-entry%E9%94%99%E8%AF%AF.html"
}
</script>



      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">TayloyChen Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">{&quot;name&quot; =&gt; &quot;TayloyChen&quot;, &quot;url&quot; =&gt; &quot;https://taylorchen.github.io&quot;}</li><li><a class="u-email" href="mailto:cherrycmd@gmail.com">cherrycmd@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/taylorchen"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">taylorchen</span></a></li><li><a href="https://www.twitter.com/shlchen"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">shlchen</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>这里是 TayloyChen 的个人博客，与你一起发现更大的世界 | 要做一个有 ikigai 的程序员</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
