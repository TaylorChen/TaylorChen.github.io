<!DOCTYPE html>
<html lang="zh-CN"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>MySQL-慢查询优化-从-explain-到火焰图 | TayloyChen Blog</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="MySQL-慢查询优化-从-explain-到火焰图" />
<meta name="author" content="TayloyChen" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="从底层原理到工程方法论：EXPLAIN/ANALYZE 判读、联合索引与 SARGable 改写、回表/分页优化、直方图与 Invisible Index 灰度，附典型案例。" />
<meta property="og:description" content="从底层原理到工程方法论：EXPLAIN/ANALYZE 判读、联合索引与 SARGable 改写、回表/分页优化、直方图与 Invisible Index 灰度，附典型案例。" />
<link rel="canonical" href="http://localhost:4000/%E6%8A%80%E6%9C%AF/mysql/2023/02/27/MySQL-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E4%BB%8E-explain-%E5%88%B0%E7%81%AB%E7%84%B0%E5%9B%BE.html" />
<meta property="og:url" content="http://localhost:4000/%E6%8A%80%E6%9C%AF/mysql/2023/02/27/MySQL-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E4%BB%8E-explain-%E5%88%B0%E7%81%AB%E7%84%B0%E5%9B%BE.html" />
<meta property="og:site_name" content="TayloyChen Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-02-27T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="MySQL-慢查询优化-从-explain-到火焰图" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"TayloyChen","url":"https://taylorchen.github.io"},"dateModified":"2025-08-10T00:22:34+08:00","datePublished":"2023-02-27T00:00:00+08:00","description":"从底层原理到工程方法论：EXPLAIN/ANALYZE 判读、联合索引与 SARGable 改写、回表/分页优化、直方图与 Invisible Index 灰度，附典型案例。","headline":"MySQL-慢查询优化-从-explain-到火焰图","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/%E6%8A%80%E6%9C%AF/mysql/2023/02/27/MySQL-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E4%BB%8E-explain-%E5%88%B0%E7%81%AB%E7%84%B0%E5%9B%BE.html"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/images/favicons/favicon-96x96.png"},"name":"TayloyChen"},"url":"http://localhost:4000/%E6%8A%80%E6%9C%AF/mysql/2023/02/27/MySQL-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E4%BB%8E-explain-%E5%88%B0%E7%81%AB%E7%84%B0%E5%9B%BE.html"}</script>
<!-- End Jekyll SEO tag -->

  
  
    <meta property="article:modified_time" content="2025-08-10T00:22:34+08:00">
  
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="alternate" type="application/atom+xml" href="http://localhost:4000/feed.xml" title="TayloyChen Blog" />
  <link rel="icon" href="/assets/images/favicons/favicon.ico" type="image/x-icon">
  
  
    <meta property="og:image" content="http://localhost:4000/assets/images/2e9ea54a25bedd353d5e06c076d9c7e4.jpeg">
    <meta name="twitter:image" content="http://localhost:4000/assets/images/2e9ea54a25bedd353d5e06c076d9c7e4.jpeg">
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebSite",
    "name": "TayloyChen Blog",
    "url": "http://localhost:4000",
    "potentialAction": {
      "@type": "SearchAction",
      "target": "http://localhost:4000/search/?q={query}",
      "query-input": "required name=query"
    }
  }
  </script>
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Person",
    "name": "TayloyChen",
    "url": "https://taylorchen.github.io",
    "sameAs": ["https://github.com/taylorchen","https://twitter.com/shlchen"]
  }
  </script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/">TayloyChen Blog</a>
    <nav class="site-nav">
      <a class="page-link" href="/">首页</a>
      <a class="page-link" href="/categories/">分类</a>
      <a class="page-link" href="/tags/">标签</a>
      <a class="page-link" href="/archives/">归档</a>
  <a class="page-link" href="/search/">搜索</a>
  <a class="page-link" href="/feed.xml" rel="alternate" type="application/atom+xml">订阅</a>
      <a class="page-link" href="/about/">关于</a>
    </nav>
  </div>
</header>


<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">
  <header>
    <h1>MySQL-慢查询优化-从-explain-到火焰图</h1>
    <p class="post-meta">
      <time datetime="2023-02-27T00:00:00+08:00">2023-02-27</time>
       · 最后更新于 <time datetime="2025-08-10T00:22:34+08:00">2025-08-10</time>
       · 技术 / MySQL
       · 技术, MySQL, 慢查询, 索引, B+树, EXPLAIN, 性能
    </p>
    <nav class="breadcrumbs" aria-label="Breadcrumb">
      <a href="/">首页</a>
      
        
          &nbsp;/&nbsp;<a href="/categories/">技术</a>
        
          &nbsp;/&nbsp;<a href="/categories/">MySQL</a>
        
      
      &nbsp;/&nbsp;<span aria-current="page">MySQL-慢查询优化-从-explain-到火焰图</span>
    </nav>
    
      <meta name="description" content="从底层原理到工程方法论：EXPLAIN/ANALYZE 判读、联合索引与 SARGable 改写、回表/分页优化、直方图与 Invisible Index 灰度，附典型案例。">
    
    
      <meta name="keywords" content="技术, MySQL, 慢查询, 索引, B+树, EXPLAIN, 性能">
    
  </header>

  <div class="post-body" id="post-body">
    <aside id="toc"></aside>
    <div id="post-content">
      <p>在大多数互联网业务中，性能问题往往集中在查询侧（读多写少、读写比常见为 10:1），而慢查询占据了主要矛盾的“C 位”。要系统性地把慢查询优化好，必须同时理解数据库的底层原理（磁盘 IO、B+ 树、优化器）、索引设计的工程原则、可落地的重写与调参手法，以及边界条件——哪些场景即便你用尽 SQL 和索引也很难救。本文在高技术细节的基础上，结合一线经验进行结构化扩展与工程化整理，以期给出一份可直接借鉴的优化指南。</p>

<h2 id="一底层原理速览为什么索引有效为什么会慢">一、底层原理速览：为什么索引有效、为什么会慢</h2>

<ul>
  <li>磁盘 vs 内存的数量级鸿沟
    <ul>
      <li>随机磁盘 IO 的代价远高于内存访问。一次随机 IO 需要经历寻道、旋转延迟、传输时间，数量级毫秒；CPU 指令数量级纳秒。我们优化的核心目标，是让“每次查询落盘的随机 IO”尽量变少甚至可控。</li>
    </ul>
  </li>
  <li>InnoDB 与 B+ 树
    <ul>
      <li>InnoDB 二级索引和聚簇索引（主键索引）均是 B+ 树。B+ 树扇出高、树高低（常见 2～4 层），单次定位数据通常 2～3 次 IO 即可。二级索引叶子节点只存被索引列和主键值，真实行数据在聚簇索引上，因此“二级索引命中但需要回表”会产生额外 IO。</li>
    </ul>
  </li>
  <li>页与顺序读取
    <ul>
      <li>InnoDB 页默认 16KB，局部性/预读使得顺序 IO 的吞吐远优于大量随机 IO。覆盖索引、索引下推、减少回表，本质都是在“让更多命中停留在更少的页里”。</li>
    </ul>
  </li>
</ul>

<p>这组常识决定了：合理的索引与查询改写，能把“全表扫描 + 大量随机 IO”变成“极小范围树检索 + 少量随机/顺序 IO”。</p>

<h2 id="二方法论从观测定位到验证">二、方法论：从观测、定位到验证</h2>

<ul>
  <li>观测
    <ul>
      <li>开启并分析慢查询日志（slow_query_log、long_query_time、log_queries_not_using_indexes）</li>
      <li>使用 pt-query-digest 聚合热点 SQL；借助 performance_schema/sys schema 获取 Wait、IO、Lock 等维度</li>
    </ul>
  </li>
  <li>定位
    <ul>
      <li>EXPLAIN 与 EXPLAIN ANALYZE（8.0.18+）评估真实执行路径与耗时分布</li>
      <li>关注 type、key、rows、filtered、Extra（Using index、Using where、Using temporary、Using filesort、Using index condition）</li>
    </ul>
  </li>
  <li>验证
    <ul>
      <li>基线采样（QPS、P95/P99 延迟、Rows examined/Rows sent、临时表与回表次数）</li>
      <li>审慎灰度：MySQL 8.0 可用 Invisible Index 验证索引有效性；在线 DDL 降低变更风险</li>
    </ul>
  </li>
  <li>回归
    <ul>
      <li>用真实业务参数覆盖极端分支；关注“看似更快但在特定参数下灾难性退化”的情况（本文后面会给典型案例）</li>
    </ul>
  </li>
</ul>

<h2 id="三索引优化的核心原则工程可落地">三、索引优化的核心原则（工程可落地）</h2>

<ul>
  <li>核心一：围绕“查询模式”而不是“字段”建索引
    <ul>
      <li>只为 WHERE、JOIN、ORDER BY、GROUP BY 等过滤/排序参与列建立索引</li>
      <li>高基数（高选择性）列优先（如 user_id &gt; status）；极低选择性列（如性别）单独加索引意义不大</li>
    </ul>
  </li>
  <li>核心二：联合索引的列序必须与谓词和排序兼容
    <ul>
      <li>“等值列在前，范围列靠后”，让尽量多的谓词参与到索引扫描而非回表过滤</li>
      <li>同时需要权衡“列选择性”和“使用频率”，一般建议：等值频繁且选择性高的列靠前；用于排序/分组的列一并纳入并统一升降序</li>
      <li>兼顾 ORDER BY/ GROUP BY 的“索引有序性”，避免 Using filesort/Using temporary</li>
    </ul>
  </li>
  <li>核心三：覆盖索引优先
    <ul>
      <li>SELECT 的列尽量被索引覆盖，Extra 出现 Using index 表示“无需回表”。这对热点 TopN 查询、Feed/列表页尤其致命有效</li>
    </ul>
  </li>
  <li>核心四：让条件可 SARGable（可由索引评估）
    <ul>
      <li>避免对列做函数或表达式：如 UPPER(col) = ‘X’、DATE(create_time) = ‘2025-08-01’</li>
      <li>解决手法：函数生成列 + 函数索引（MySQL 8.0 支持 Functional Index）；或用范围改写（create_time &gt;= ‘2025-08-01’ AND create_time &lt; ‘2025-08-02’）</li>
    </ul>
  </li>
  <li>核心五：LIKE 前缀命中与全文检索
    <ul>
      <li>LIKE ‘abc%’ 可用 btree 前缀走索引；LIKE ‘%abc%’ 需全文索引（FULLTEXT/倒排/NGRAM）或改造数据结构（反向存储 + 前缀匹配 + 函数索引）</li>
    </ul>
  </li>
  <li>核心六：ORDER BY/分页优化
    <ul>
      <li>避免“大偏移”分页（LIMIT 100000, 20）；推荐“基于游标”的 Seek 方法（WHERE (k, id) &gt; (?, ?) LIMIT N）</li>
      <li>如必须排序分页，尽量使用能满足排序的联合索引（与 WHERE 子句兼容）</li>
    </ul>
  </li>
  <li>核心七：主键与二级索引协同
    <ul>
      <li>InnoDB 主键即数据物理顺序。主键应短、递增（雪花 ID/自增/UUIDv7），避免随机 UUIDv4 导致频繁页分裂</li>
      <li>二级索引叶子存主键，回表代价与主键长度、行大小、局部性直接相关</li>
    </ul>
  </li>
  <li>核心八：统计信息与优化器
    <ul>
      <li>定期 ANALYZE TABLE，开启持久统计（innodb_stats_persistent）；必要时使用直方图（MySQL 8.0 histogram）提升基数估计</li>
      <li>在小概率误判时使用优化器 Hint（STRAIGHT_JOIN、USE INDEX、INDEX_MERGE、BKA/BKA ON/OFF 等）</li>
    </ul>
  </li>
  <li>核心九：分区不是索引的替代
    <ul>
      <li>分区降低“被扫描的数据量”，但分区内仍需索引；分区键必须参与查询谓词才能有效裁剪分区</li>
    </ul>
  </li>
  <li>核心十：变更安全
    <ul>
      <li>使用 Invisible Index 验证效果；在线 DDL 降低锁表风险；灰度发布与回滚预案必备
        <h2 id="四实际慢查询案例与可落地重写">四、实际慢查询案例与可落地重写</h2>
      </li>
    </ul>
  </li>
</ul>

<h3 id="案例-1多条件计数--时间范围">案例 1：多条件计数 + 时间范围</h3>

<p>业务 SQL（简化自业界常见模式）：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">task</span>
<span class="k">WHERE</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="k">AND</span> <span class="n">operator_id</span> <span class="o">=</span> <span class="mi">20839</span>
  <span class="k">AND</span> <span class="n">operate_time</span> <span class="o">&gt;</span> <span class="mi">1371169729</span>
  <span class="k">AND</span> <span class="n">operate_time</span> <span class="o">&lt;</span> <span class="mi">1371174603</span>
  <span class="k">AND</span> <span class="k">type</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<p>常见问题</p>
<ul>
  <li>单列索引分散在各列，导致优化器选一个索引，再对其它条件做回表过滤，Rows examined 仍然很大。</li>
  <li>时间范围是“范围谓词”，放在联合索引中靠后更合理。</li>
</ul>

<p>建议索引</p>
<ul>
  <li>建立联合索引：<code class="language-plaintext highlighter-rouge">(status, operator_id, type, operate_time)</code>。等值列在前，范围列 <code class="language-plaintext highlighter-rouge">operate_time</code> 放最后。</li>
  <li>若查询还常常 ORDER BY operate_time，可考虑 <code class="language-plaintext highlighter-rouge">(status, operator_id, type, operate_time)</code> 同时覆盖排序。</li>
</ul>

<p>验证要点</p>
<ul>
  <li>EXPLAIN 观察 <code class="language-plaintext highlighter-rouge">type: range/ref</code>、<code class="language-plaintext highlighter-rouge">key: idx_s_o_t_ot</code>、<code class="language-plaintext highlighter-rouge">rows</code> 明显下降；Extra 无 Using filesort/Using temporary。</li>
  <li>COUNT(*) 可结合覆盖索引实现“无回表计数”。</li>
</ul>

<h3 id="案例-2排序--limit-的-topn-与-join-的悖论">案例 2：排序 + LIMIT 的 TopN 与 Join 的悖论</h3>

<p>目标 SQL（取最新创建的 10 条）：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">c</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="k">c</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="k">c</span><span class="p">.</span><span class="n">created_time</span>
<span class="k">FROM</span> <span class="n">contact</span> <span class="k">c</span>
<span class="k">JOIN</span> <span class="p">...</span> <span class="c1">-- 复杂多表过滤</span>
<span class="k">WHERE</span> <span class="p">...</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="k">c</span><span class="p">.</span><span class="n">created_time</span> <span class="k">DESC</span>
<span class="k">LIMIT</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></div></div>

<p>两种思路</p>
<ul>
  <li>先全量 Join 后排序再 LIMIT：如果 Join 过滤后仍有海量行，再排序与分页，代价巨大。</li>
  <li>优化策略：基于 <code class="language-plaintext highlighter-rouge">c.created_time</code> 可排序的联合索引（如 <code class="language-plaintext highlighter-rouge">(created_time, id)</code> 或与 WHERE 兼容的更长索引），先从 <code class="language-plaintext highlighter-rouge">c</code> 上用索引顺序取 TopN，再做 Join 过滤，不够再取下一批（Loop 取 TopN+Join 过滤）。</li>
</ul>

<p>巨幅加速 vs 灾难性退化</p>
<ul>
  <li>在“Join 过滤率较高但非极端”的情况下，这种“先取 TopN 再 Join”的策略往往带来数量级的速度提升（实践中可从秒级降到毫秒级）。</li>
  <li>但当 Join 过滤极端严格，TopN 的候选一再被过滤掉，则会出现“反复取 10 条、反复 Join、始终不够”的灾难性退化，整体甚至比原始写法更慢。由于 MySQL 的 Nested Loop 特性，这类退化在优化器层面很难被完全消弭。</li>
</ul>

<p>工程建议</p>
<ul>
  <li>预先把 Join 侧过滤做“强裁剪”（如用子查询或派生表先把候选主键集缩小到 O(1e3) 级别，再回表取 TopN）</li>
  <li>若业务允许，把排序字段与过滤字段合并为能被同一联合索引同时支持的模式</li>
  <li>极端场景交由应用逻辑优化，例如缓存预计算 TopN 候选集、分层存储、异步刷新等</li>
</ul>

<h3 id="案例-3exists--多表-join-的过滤上移">案例 3：EXISTS + 多表 Join 的过滤上移</h3>

<p>原始 SQL（示意）：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">c</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="k">c</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="k">c</span><span class="p">.</span><span class="n">created_time</span>
<span class="k">FROM</span> <span class="n">contact</span> <span class="k">c</span>
<span class="k">WHERE</span> <span class="k">EXISTS</span> <span class="p">(</span>
  <span class="k">SELECT</span> <span class="mi">1</span>
  <span class="k">FROM</span> <span class="n">contact_branch</span> <span class="n">cb</span>
  <span class="k">JOIN</span> <span class="n">branch_user</span> <span class="n">bu</span> <span class="k">ON</span> <span class="n">cb</span><span class="p">.</span><span class="n">branch_id</span> <span class="o">=</span> <span class="n">bu</span><span class="p">.</span><span class="n">branch_id</span> <span class="k">AND</span> <span class="n">bu</span><span class="p">.</span><span class="n">status</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
  <span class="k">JOIN</span> <span class="n">org_emp_info</span> <span class="n">oei</span> <span class="k">ON</span> <span class="n">oei</span><span class="p">.</span><span class="n">data_id</span> <span class="o">=</span> <span class="n">bu</span><span class="p">.</span><span class="n">user_id</span>
                        <span class="k">AND</span> <span class="n">oei</span><span class="p">.</span><span class="n">node_left</span> <span class="o">&gt;=</span> <span class="mi">2875</span>
                        <span class="k">AND</span> <span class="n">oei</span><span class="p">.</span><span class="n">node_right</span> <span class="o">&lt;=</span> <span class="mi">10802</span>
                        <span class="k">AND</span> <span class="n">oei</span><span class="p">.</span><span class="n">org_category</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
  <span class="k">WHERE</span> <span class="k">c</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">cb</span><span class="p">.</span><span class="n">contact_id</span>
<span class="p">)</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="k">c</span><span class="p">.</span><span class="n">created_time</span> <span class="k">DESC</span>
<span class="k">LIMIT</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></div></div>

<p>优化思路</p>
<ul>
  <li>为 Join 键与过滤列建立必要索引：<code class="language-plaintext highlighter-rouge">cb(branch_id, contact_id)</code>、<code class="language-plaintext highlighter-rouge">bu(branch_id, status)</code>、<code class="language-plaintext highlighter-rouge">oei(org_category, node_left, node_right, data_id)</code> 等</li>
  <li>半连接（Semi-join）重写：在 MySQL 8.0 上，优化器对 EXISTS/IN 有半连接转换，可显著减少回表</li>
  <li>将“组织区间过滤”下推产生“候选 user_id 集合”，再回表关联 contact，避免大范围 Join 后再过滤</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">STRAIGHT_JOIN</code> 在个别误判时固定 Join 顺序</li>
</ul>

<h3 id="案例-4模糊匹配与全文搜索">案例 4：模糊匹配与全文搜索</h3>

<p>原始 SQL：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">id</span> <span class="k">FROM</span> <span class="n">article</span> <span class="k">WHERE</span> <span class="n">title</span> <span class="k">LIKE</span> <span class="s1">'%分布式事务%'</span><span class="p">;</span>
</code></pre></div></div>

<p>结论</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">%xxx%</code> 前导通配符使得无法按 btree 自左向右利用索引，只能全表扫描</li>
  <li>备选路径：全文索引（FULLTEXT/倒排/NGRAM）、ES/搜索服务；或改造为“前后缀可命中”的查询模式；或建立“反向字符串 + 函数索引”的特定业务替代方案（有代价）</li>
</ul>

<h3 id="案例-5函数过滤与-sargable-改写">案例 5：函数过滤与 SARGable 改写</h3>

<p>问题 SQL：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">orders</span>
<span class="k">WHERE</span> <span class="nb">DATE</span><span class="p">(</span><span class="n">create_time</span><span class="p">)</span> <span class="o">=</span> <span class="s1">'2025-08-09'</span><span class="p">;</span>
</code></pre></div></div>

<p>改写</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">orders</span>
<span class="k">WHERE</span> <span class="n">create_time</span> <span class="o">&gt;=</span> <span class="s1">'2025-08-09 00:00:00'</span>
  <span class="k">AND</span> <span class="n">create_time</span> <span class="o">&lt;</span>  <span class="s1">'2025-08-10 00:00:00'</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>或在 MySQL 8.0 上使用函数索引/生成列：
    <ul>
      <li>生成列 <code class="language-plaintext highlighter-rouge">create_date</code> = DATE(create_time)，并对其建索引，查询改为 <code class="language-plaintext highlighter-rouge">WHERE create_date = '2025-08-09'</code></li>
    </ul>
  </li>
</ul>

<h2 id="五那些很难优化或不该在数据库层面优化的场景">五、那些“很难优化或不该在数据库层面优化”的场景</h2>

<ul>
  <li>先排序再 Join + LIMIT 的极端退化
    <ul>
      <li>如前述案例 2，当 Join 过滤极端严格且结果集稀疏，MySQL 将反复取 TopN 候选再 Join，导致“指数级”重试。优化器很难自动摆脱这种结构性退化，通常需要业务/架构层面改造（缓存/预计算/拆查询）。</li>
    </ul>
  </li>
  <li>低选择性列的大范围过滤
    <ul>
      <li>如 <code class="language-plaintext highlighter-rouge">status IN (1,2,3)</code>、<code class="language-plaintext highlighter-rouge">gender in (0,1)</code>，索引帮助不大。通常是全表扫描更快。需通过复合谓词联合高选择性列，或改业务模型/分区/冷热分表</li>
    </ul>
  </li>
  <li>全字段模糊匹配
    <ul>
      <li>LIKE ‘%keyword%’、跨多列 OR 混合匹配，本质是搜索问题。应引入搜索引擎或全文索引。强行在 MySQL 用索引 merge 往往治标不治本</li>
    </ul>
  </li>
  <li>返回超大行/大字段
    <ul>
      <li>查询即便命中索引，但需要回表读取大量列（BLOB/TEXT、大 JSON），IO 成本依旧高。考虑列裁剪、行列分离（大字段外置）</li>
    </ul>
  </li>
  <li>复杂 UDF、存储过程型逻辑
    <ul>
      <li>复杂运算难以下推，无法被优化器重写与索引利用。需要在应用层/ETL 预处理，或改写为可下推的谓词</li>
    </ul>
  </li>
  <li>数据太小/Buffer 命中率极高
    <ul>
      <li>小表全表扫描更快，建索引可能适得其反（维护成本 &gt; 受益）。应基于基线指标权衡</li>
    </ul>
  </li>
  <li>高更新写入压力下的过度索引
    <ul>
      <li>每个索引都是写放大。对高频写表，索引数量应严格节制；必要时离线/异步索引化（如汇总表/物化视图）</li>
    </ul>
  </li>
</ul>

<h2 id="六实施清单从方案到上线的工程流程">六、实施清单：从方案到上线的工程流程</h2>

<ul>
  <li>明确目标与基线
    <ul>
      <li>指标：平均/尾延、QPS、Rows examined、临时表、回表次数、网络时间、锁等待</li>
    </ul>
  </li>
  <li>重写/加索引的操作顺序
    <ul>
      <li>先改写使 SARGable；再评估联合索引顺序；验证 ORDER BY/WHERE 兼容性</li>
      <li>能覆盖索引则覆盖；无法覆盖时最小化回表列</li>
    </ul>
  </li>
  <li>EXPLAIN/EXPLAIN ANALYZE 验证
    <ul>
      <li>看 <code class="language-plaintext highlighter-rouge">rows x filtered</code> 评估真实扫描量；观察 Extra 是否出现 Using filesort/temporary</li>
    </ul>
  </li>
  <li>统计信息与优化器纠偏
    <ul>
      <li>执行 <code class="language-plaintext highlighter-rouge">ANALYZE TABLE</code>；必要时直方图；少量使用 Hint 纠偏误判</li>
    </ul>
  </li>
  <li>安全上线
    <ul>
      <li>使用 Invisible Index 预验证；在线 DDL；灰度与回滚；限流与隔离（读写分离、只读副本压测）</li>
    </ul>
  </li>
  <li>回归测试与极端参数
    <ul>
      <li>针对“TopN + Join 过滤极端稀疏”等已知退化路径，设计覆盖性测试数据，避免“线上才暴雷”</li>
    </ul>
  </li>
</ul>

<h2 id="七explain-关键信号的快速判读">七、EXPLAIN 关键信号的快速判读</h2>

<ul>
  <li>type：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL（越靠左越好）</li>
  <li>key：命中的索引名；key_len：使用的索引前缀长度</li>
  <li>rows、filtered：估计扫描行数与过滤比例；<code class="language-plaintext highlighter-rouge">rows * filtered</code> 近似为后续参与的行数</li>
  <li>Extra：
    <ul>
      <li>Using index：覆盖索引，无回表</li>
      <li>Using where：回表或额外条件过滤</li>
      <li>Using index condition：索引下推（ICP）</li>
      <li>Using temporary/Using filesort：排序/分组代价高，多半需要改写/加索引</li>
      <li>Using join buffer：说明发生了 Block Nested-Loop Join，索引缺失或不匹配</li>
    </ul>
  </li>
</ul>

<h2 id="八索引设计的可执行准则checklist">八、索引设计的可执行准则（Checklist）</h2>

<ul>
  <li>必做
    <ul>
      <li>为最常用的查询模式建立联合索引，等值列在前，范围列靠后</li>
      <li>能覆盖就覆盖；返回列尽量落在索引上</li>
      <li>避免函数包裹列；避免 <code class="language-plaintext highlighter-rouge">%keyword%</code> 的模糊匹配；避免大偏移分页</li>
      <li>优化 ORDER BY/WHERE 一致性，必要时使用降序索引（MySQL 8.0 支持）</li>
      <li>定期维护统计信息与直方图；使用 Invisible Index 做灰度验证</li>
    </ul>
  </li>
  <li>慎做
    <ul>
      <li>对低选择性列单独加索引</li>
      <li>为“读少写多”的表加过多索引</li>
      <li>在数据量很小的表上执意强索引化</li>
    </ul>
  </li>
  <li>不做
    <ul>
      <li>期望“先排序后 Join + LIMIT”在极端稀疏条件下自动变快</li>
      <li>在数据库层硬啃“搜索引擎问题”（跨列 OR + 模糊）</li>
    </ul>
  </li>
</ul>

<h2 id="九总结">九、总结</h2>

<ul>
  <li>索引与慢查询优化的本质，是利用 B+ 树和统计信息，让绝大多数查询在“极小的页数与极少的随机 IO”中完成。</li>
  <li>工程上，索引顺序、覆盖索引、SARGable 改写、ORDER BY 与 WHERE 的兼容性，是性价比最高的四大抓手。</li>
  <li>“先排序 + LIMIT + 再 Join”的策略在大多数情况下很香，但在极端稀疏过滤下会灾难性退化，这是优化的边界之一，通常需要业务侧改造。</li>
  <li>不要迷信“给所有条件列都加索引”，依查询而建才是正道。</li>
  <li>持续基线化、灰度验证与极端参数回归，是让优化“安全落地”的保障。</li>
</ul>

<hr />

<p>本文重点覆盖了索引优化原则、典型慢查询案例（含“排序+LIMIT+Join”悖论）、以及不可优化或不宜在数据库层优化的边界场景；提供了实施清单与 EXPLAIN 判读清单，可直接按清单逐项落地。</p>

    </div>
  </div>

  
  
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
    
    
    
    
  
    
    
    
      
        
    
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
    
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
    
      
        
    
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
    
    
    
    
  
  <section class="related-posts">
    <h2>相关阅读</h2>
    <ul>
      
        <li><a href="/%E6%8A%80%E6%9C%AF/nginx/2025/07/01/Nginx-Ingress-%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5.html">Nginx Ingress 高并发场景优化实践</a> <small>(2025-07-01)</small></li>
      
        <li><a href="/%E6%8A%80%E6%9C%AF/nginx/2025/06/28/Nginx-%E9%9B%B6%E5%81%9C%E6%9C%BA%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E4%B8%8E%E5%9B%9E%E6%BB%9A%E7%AD%96%E7%95%A5.html">Nginx 零停机灰度发布与回滚策略</a> <small>(2025-06-28)</small></li>
      
        <li><a href="/%E6%8A%80%E6%9C%AF/nginx/2023/12/05/Nginx-Ingress-%E5%9C%A8Kubernetes%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E9%85%8D%E7%BD%AE.html">Nginx Ingress 在 Kubernetes 的高可用配置</a> <small>(2023-12-05)</small></li>
      
        <li><a href="/%E6%8A%80%E6%9C%AF/golang/2022/10/07/Go-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-Channel%E4%B8%8EContext%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html">Go 并发模型：Channel 与 Context 最佳实践</a> <small>(2022-10-07)</small></li>
      
        <li><a href="/%E6%8A%80%E6%9C%AF/java/2022/03/30/Java-Spring-%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E9%99%B7%E9%98%B1.html">Java Spring 事务传播与隔离级别陷阱</a> <small>(2022-03-30)</small></li>
      
    </ul>
  </section>
  

  <footer class="post-footer">
    <nav class="post-pager" aria-label="Post Navigation">
      
        <a class="prev" href="/%E6%8A%80%E6%9C%AF/golang/2022/10/07/Go-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-Channel%E4%B8%8EContext%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html" rel="prev">← 上一篇：Go 并发模型：Channel 与 Context 最佳实践</a>
      
      
        <a class="next" href="/web3/2023/03/22/Web3-DAO-%E6%B2%BB%E7%90%86%E4%B8%8E%E5%8D%8F%E5%90%8C%E5%AE%9E%E8%B7%B5.html" rel="next">下一篇：DAO：治理、金库与协同实践 →</a>
      
    </nav>
    <div class="share">
      <a href="https://twitter.com/intent/tweet?text=MySQL-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E4%BB%8E-explain-%E5%88%B0%E7%81%AB%E7%84%B0%E5%9B%BE&url=http://localhost:4000/%E6%8A%80%E6%9C%AF/mysql/2023/02/27/MySQL-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E4%BB%8E-explain-%E5%88%B0%E7%81%AB%E7%84%B0%E5%9B%BE.html" target="_blank" rel="noopener">Share to X</a>
      <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/%E6%8A%80%E6%9C%AF/mysql/2023/02/27/MySQL-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E4%BB%8E-explain-%E5%88%B0%E7%81%AB%E7%84%B0%E5%9B%BE.html" target="_blank" rel="noopener" style="margin-left:12px;">Share to Facebook</a>
      <a href="https://www.linkedin.com/sharing/share-offsite/?url=http://localhost:4000/%E6%8A%80%E6%9C%AF/mysql/2023/02/27/MySQL-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E4%BB%8E-explain-%E5%88%B0%E7%81%AB%E7%84%B0%E5%9B%BE.html" target="_blank" rel="noopener" style="margin-left:12px;">Share to LinkedIn</a>
    </div>

    
    <section id="comments" style="margin-top: 24px;">
      <script src="https://giscus.app/client.js"
        data-repo=""
        data-repo-id=""
        data-category="General"
        data-category-id=""
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="light"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
      </script>
    </section>
    
  </footer>
</article>

<button id="back-to-top" title="回到顶部">↑</button>

<script>
// 构建目录
(function(){
  const content = document.getElementById('post-content');
  const toc = document.getElementById('toc');
  if (!content || !toc) return;
  const headings = content.querySelectorAll('h1, h2, h3');
  if (!headings.length) return;
  const ul = document.createElement('ul');
  headings.forEach(h => {
    if (!h.id) h.id = h.textContent.trim().toLowerCase().replace(/\s+/g, '-');
    const li = document.createElement('li');
    li.style.marginLeft = ({H1:0,H2:12,H3:24})[h.tagName] + 'px';
    const a = document.createElement('a');
    a.href = '#' + h.id;
    a.textContent = h.textContent;
    li.appendChild(a);
    ul.appendChild(li);
  });
  const title = document.createElement('div');
  title.textContent = '目录';
  title.style.fontWeight = 'bold';
  title.style.marginBottom = '8px';
  toc.appendChild(title);
  toc.appendChild(ul);
})();

// 代码复制按钮
(function(){
  document.querySelectorAll('pre > code').forEach(code => {
    const pre = code.parentElement;
    const btn = document.createElement('button');
    btn.textContent = '复制';
    btn.className = 'copy-btn';
    btn.onclick = async () => {
      try { await navigator.clipboard.writeText(code.innerText); btn.textContent = '已复制'; setTimeout(()=>btn.textContent='复制',1000);} catch(e) {}
    };
    pre.style.position = 'relative';
    btn.style.position = 'absolute';
    btn.style.right = '8px';
    btn.style.top = '8px';
    pre.appendChild(btn);
  });
})();

// 回到顶部
(function(){
  const btn = document.getElementById('back-to-top');
  const onscroll = () => { btn.style.display = window.scrollY > 300 ? 'block' : 'none'; };
  window.addEventListener('scroll', onscroll); onscroll();
  btn.onclick = () => window.scrollTo({top:0, behavior:'smooth'});
})();

// 图片懒加载与缺失 alt 自动补全
(function(){
  document.querySelectorAll('#post-content img').forEach(img => {
    img.loading = 'lazy';
    if (!img.hasAttribute('alt') || img.getAttribute('alt') === '') {
      try {
        const u = new URL(img.src, window.location.origin);
        const name = (u.pathname.split('/').pop() || '').split('.')[0];
        if (name) img.setAttribute('alt', decodeURIComponent(name));
      } catch (e) {}
    }
  });
})();
</script>

<style>
.post-body{display:flex; gap:24px}
#post-body .breadcrumbs{margin:8px 0 12px 0}
#toc{min-width:200px; max-width:240px; position:sticky; top:80px; height:max-content}
#post-content{flex:1}
#back-to-top{position:fixed; right:16px; bottom:24px; display:none; padding:8px 10px}
.copy-btn{font-size:12px; padding:2px 6px}
 .post-pager{display:flex; justify-content:space-between; margin:16px 0}
 .post-pager .prev,.post-pager .next{max-width:48%;}
@media (max-width: 900px){ .post-body{flex-direction:column;} #toc{position:static;}}
</style><script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySQL-慢查询优化-从-explain-到火焰图",
  "description": "从底层原理到工程方法论：EXPLAIN/ANALYZE 判读、联合索引与 SARGable 改写、回表/分页优化、直方图与 Invisible Index 灰度，附典型案例。",
  "datePublished": "2023-02-27T00:00:00+08:00",
  "dateModified": "2025-08-10T00:22:34+08:00",
  "author": {
    "@type": "Person",
    "name": "TayloyChen"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:4000/%E6%8A%80%E6%9C%AF/mysql/2023/02/27/MySQL-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E4%BB%8E-explain-%E5%88%B0%E7%81%AB%E7%84%B0%E5%9B%BE.html"
  },
  "url": "http://localhost:4000/%E6%8A%80%E6%9C%AF/mysql/2023/02/27/MySQL-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E4%BB%8E-explain-%E5%88%B0%E7%81%AB%E7%84%B0%E5%9B%BE.html"
}
</script><script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {"@type": "ListItem", "position": 1, "name": "首页", "item": "http://localhost:4000/"}
    
      
      
        ,{"@type": "ListItem", "position": 2, "name": "技术", "item": "http://localhost:4000/categories/"}
        
      
        ,{"@type": "ListItem", "position": 3, "name": "MySQL", "item": "http://localhost:4000/categories/"}
        
      
    
    ,{"@type": "ListItem", "position": 4, "name": "MySQL-慢查询优化-从-explain-到火焰图", "item": "http://localhost:4000/%E6%8A%80%E6%9C%AF/mysql/2023/02/27/MySQL-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E4%BB%8E-explain-%E5%88%B0%E7%81%AB%E7%84%B0%E5%9B%BE.html"}
  ]
}
</script>



      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">TayloyChen Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name"><a class="u-url" href="https://taylorchen.github.io">TayloyChen</a></li><li><a class="u-email" href="mailto:cherrycmd@gmail.com">cherrycmd@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/taylorchen"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">taylorchen</span></a></li><li><a href="https://www.twitter.com/shlchen"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">shlchen</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>这里是 TayloyChen 的个人博客，与你一起发现更大的世界 | 要做一个有 ikigai 的程序员</p>
      </div>
    </div>

  </div>

</footer>


</body>

</html>
