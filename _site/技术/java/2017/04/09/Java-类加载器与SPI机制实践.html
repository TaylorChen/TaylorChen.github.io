<!DOCTYPE html>
<html lang="zh-CN"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Java 类加载器与 SPI 机制实践 | TayloyChen Blog</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Java 类加载器与 SPI 机制实践" />
<meta name="author" content="TayloyChen" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="梳理类加载全流程与双亲委派、命名空间隔离，深入 SPI 与 TCCL 的装配机制，并结合字节码增强/Agent 构建从加载到运行期增强的工程链路。" />
<meta property="og:description" content="梳理类加载全流程与双亲委派、命名空间隔离，深入 SPI 与 TCCL 的装配机制，并结合字节码增强/Agent 构建从加载到运行期增强的工程链路。" />
<link rel="canonical" href="http://localhost:4000/%E6%8A%80%E6%9C%AF/java/2017/04/09/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8ESPI%E6%9C%BA%E5%88%B6%E5%AE%9E%E8%B7%B5.html" />
<meta property="og:url" content="http://localhost:4000/%E6%8A%80%E6%9C%AF/java/2017/04/09/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8ESPI%E6%9C%BA%E5%88%B6%E5%AE%9E%E8%B7%B5.html" />
<meta property="og:site_name" content="TayloyChen Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-04-09T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Java 类加载器与 SPI 机制实践" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"TayloyChen","url":"https://taylorchen.github.io"},"dateModified":"2025-08-09T19:09:21+08:00","datePublished":"2017-04-09T00:00:00+08:00","description":"梳理类加载全流程与双亲委派、命名空间隔离，深入 SPI 与 TCCL 的装配机制，并结合字节码增强/Agent 构建从加载到运行期增强的工程链路。","headline":"Java 类加载器与 SPI 机制实践","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/%E6%8A%80%E6%9C%AF/java/2017/04/09/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8ESPI%E6%9C%BA%E5%88%B6%E5%AE%9E%E8%B7%B5.html"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/images/favicons/favicon-96x96.png"},"name":"TayloyChen"},"url":"http://localhost:4000/%E6%8A%80%E6%9C%AF/java/2017/04/09/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8ESPI%E6%9C%BA%E5%88%B6%E5%AE%9E%E8%B7%B5.html"}</script>
<!-- End Jekyll SEO tag -->

  
  
    <meta property="article:modified_time" content="2025-08-09T19:09:21+08:00">
  
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="alternate" type="application/atom+xml" href="http://localhost:4000/feed.xml" title="TayloyChen Blog" />
  <link rel="icon" href="/assets/images/favicons/favicon.ico" type="image/x-icon">
  
  
    <meta property="og:image" content="http://localhost:4000/assets/images/2e9ea54a25bedd353d5e06c076d9c7e4.jpeg">
    <meta name="twitter:image" content="http://localhost:4000/assets/images/2e9ea54a25bedd353d5e06c076d9c7e4.jpeg">
  
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/">TayloyChen Blog</a>
    <nav class="site-nav">
      <a class="page-link" href="/">首页</a>
      <a class="page-link" href="/categories/">分类</a>
      <a class="page-link" href="/tags/">标签</a>
      <a class="page-link" href="/archives/">归档</a>
      <a class="page-link" href="/search/">搜索</a>
      <a class="page-link" href="/about/">关于</a>
    </nav>
  </div>
</header>


<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">
  <header>
    <h1>Java 类加载器与 SPI 机制实践</h1>
    <p class="post-meta">
      <time datetime="2017-04-09T00:00:00+08:00">2017-04-09</time>
       · 最后更新于 <time datetime="2025-08-09T19:09:21+08:00">2025-08-09</time>
       · 技术 / Java
       · 技术, Java, 类加载, SPI, 字节码增强, Java Agent, AOP
    </p>
    
      <meta name="description" content="梳理类加载全流程与双亲委派、命名空间隔离，深入 SPI 与 TCCL 的装配机制，并结合字节码增强/Agent 构建从加载到运行期增强的工程链路。">
    
    
      <meta name="keywords" content="技术, Java, 类加载, SPI, 字节码增强, Java Agent, AOP">
    
  </header>

  <div class="post-body" id="post-body">
    <aside id="toc"></aside>
    <div id="post-content">
      <p>本文系统梳理 Java 虚拟机的类加载流程、双亲委派模型与命名空间隔离，深入解析 SPI（Service Provider Interface）在容器与插件化架构中的使用要点与常见坑，并结合字节码增强与 Java Agent 的实践串联起类加载与运行期增强这一条主线，帮助你在工程中进行正确的架构取舍与问题诊断。</p>

<h2 id="0-你为什么需要关心类加载与-spi">0. 你为什么需要关心类加载与 SPI</h2>

<ul>
  <li><strong>定位复杂 ClassNotFoundException / NoSuchMethodError / LinkageError</strong>：多数与类加载边界和版本冲突相关。</li>
  <li><strong>搭建插件化平台与多租户隔离</strong>：自定义 <code class="language-plaintext highlighter-rouge">ClassLoader</code> 能在一进程内提供清晰的依赖边界与热插拔能力。</li>
  <li><strong>正确使用 SPI、JDBC、JNDI、日志门面</strong>：都依赖 <code class="language-plaintext highlighter-rouge">ServiceLoader</code> + 线程上下文类加载器（TCCL）。</li>
  <li><strong>运行期增强与诊断</strong>：AOP、性能探针、日志埋点、线上热修复都离不开字节码增强与 Java Agent。</li>
</ul>

<hr />

<h2 id="1-jvm-类加载全流程与命名空间">1. JVM 类加载全流程与命名空间</h2>

<p>JVM 将一个 <code class="language-plaintext highlighter-rouge">.class</code> 从“字节序列”变为可执行的类元数据，经历如下阶段：</p>

<p>1) 加载（Loading）</p>
<ul>
  <li>读取字节流，形成 <code class="language-plaintext highlighter-rouge">Class</code> 对象的初始结构，确定其“定义加载器”（Defining ClassLoader）。</li>
</ul>

<p>2) 链接（Linking）</p>
<ul>
  <li>验证（Verification）：字节码结构合法性与安全检查。</li>
  <li>准备（Preparation）：为静态字段分配内存并设零值。</li>
  <li>解析（Resolution）：将符号引用解析为直接引用（可能懒解析）。</li>
</ul>

<p>3) 初始化（Initialization）</p>
<ul>
  <li>执行 <code class="language-plaintext highlighter-rouge">&lt;clinit&gt;</code> 静态初始化块，真正赋初值，保证线程安全一次性执行。</li>
</ul>

<p>类由某个 <code class="language-plaintext highlighter-rouge">ClassLoader</code> 定义后会进入该加载器的“命名空间”。同名类在不同命名空间是“不同的类”，这也是很多跨 <code class="language-plaintext highlighter-rouge">ClassLoader</code> 转型失败、方法找不到的根源。</p>

<h3 id="11-双亲委派模型parent-delegation">1.1 双亲委派模型（Parent Delegation）</h3>

<p>标准的类加载器层次：</p>
<ul>
  <li>Bootstrap ClassLoader（C/C++ 实现，加载核心类库）</li>
  <li>Platform/Extension ClassLoader（加载平台扩展）</li>
  <li>Application ClassLoader（加载应用 <code class="language-plaintext highlighter-rouge">classpath</code>）</li>
  <li>自定义 ClassLoader（可作为子层）</li>
</ul>

<p>委派过程：<code class="language-plaintext highlighter-rouge">loadClass</code> 先委派给父加载器；父找不到（抛 <code class="language-plaintext highlighter-rouge">ClassNotFoundException</code>）才回落到子加载器自己加载。优势：</p>
<ul>
  <li><strong>安全</strong>：防止用户代码伪造 <code class="language-plaintext highlighter-rouge">java.lang.*</code> 等核心类。</li>
  <li><strong>共享</strong>：上层定义一次，全局共享，减少重复加载与内存浪费。</li>
</ul>

<p>什么时候“打破”或“变形”委派：</p>
<ul>
  <li><strong>容器隔离与热部署</strong>：如 Tomcat、OSGi、插件化框架会采用“先本地后父类”或双亲/并行策略以实现隔离与覆盖。</li>
  <li><strong>SPI 与 TCCL</strong>：JDK 某些 API 通过“线程上下文类加载器”来绕过严格的父委派边界。</li>
</ul>

<h3 id="12-class-等价性与常见异常">1.2 Class 等价性与常见异常</h3>

<ul>
  <li>同名类如果由不同 <code class="language-plaintext highlighter-rouge">ClassLoader</code> 定义，则 <code class="language-plaintext highlighter-rouge">clazzA != clazzB</code>，即使字节码完全相同。</li>
  <li>典型异常：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ClassCastException: X cannot be cast to X</code>（两个 X 来自不同加载器）；</li>
      <li><code class="language-plaintext highlighter-rouge">NoSuchMethodError/NoSuchFieldError</code>（版本不一致）；</li>
      <li><code class="language-plaintext highlighter-rouge">LinkageError: loader constraint violation</code>（同名类被不同加载器以不同版本解析）。</li>
    </ul>
  </li>
</ul>

<p>工程建议：跨边界交互使用稳定的“数据结构或接口”包由公共上层加载器定义；不同插件内部类不外泄。</p>

<hr />

<h2 id="2-自定义-classloader隔离覆盖与热插拔">2. 自定义 ClassLoader：隔离、覆盖与热插拔</h2>

<p>典型目标：</p>
<ul>
  <li>为每个业务域/插件创建独立的依赖边界（避免 jar 冲突）。</li>
  <li>支持插件卸载与升级（释放旧 <code class="language-plaintext highlighter-rouge">ClassLoader</code>，让类与资源可被 GC 回收）。</li>
</ul>

<p>最小可用实现思路：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IsolatedClassLoader</span> <span class="kd">extends</span> <span class="nc">ClassLoader</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]&gt;</span> <span class="n">classNameToBytes</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">IsolatedClassLoader</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]&gt;</span> <span class="n">classNameToBytes</span><span class="o">,</span> <span class="nc">ClassLoader</span> <span class="n">parent</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">classNameToBytes</span> <span class="o">=</span> <span class="n">classNameToBytes</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">findClass</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ClassNotFoundException</span> <span class="o">{</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">classNameToBytes</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">bytes</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">ClassNotFoundException</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="k">return</span> <span class="nf">defineClass</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">bytes</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">bytes</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>说明：</p>
<ul>
  <li>仅覆盖 <code class="language-plaintext highlighter-rouge">findClass</code>，仍保留“父优先”委派，以保证核心类安全。</li>
  <li>需要自管资源获取与依赖链；若要“先本地后父类”，可在 <code class="language-plaintext highlighter-rouge">loadClass</code> 中调整策略，但务必限制可覆盖的包前缀（如只允许 <code class="language-plaintext highlighter-rouge">com.example.plugins.*</code>）。</li>
</ul>

<p>释放资源：卸载插件时断开对 <code class="language-plaintext highlighter-rouge">ClassLoader</code> 的所有强引用（包括线程、定时器、缓存、<code class="language-plaintext highlighter-rouge">ThreadLocal</code>、JNI 句柄等），否则类与字节码无法回收。</p>

<hr />

<h2 id="3-spiservice-provider-interface原理与实战">3. SPI（Service Provider Interface）原理与实战</h2>

<p>SPI 的核心在于“调用方依赖接口，运行期按需装配实现”。JDK 提供 <code class="language-plaintext highlighter-rouge">java.util.ServiceLoader</code>，通过读取 <code class="language-plaintext highlighter-rouge">META-INF/services/&lt;接口全名&gt;</code> 文件完成发现。</p>

<h3 id="31-基本使用">3.1 基本使用</h3>

<p>文件布局：</p>
<ul>
  <li>接口：<code class="language-plaintext highlighter-rouge">com.example.spi.Storage</code></li>
  <li>实现类：<code class="language-plaintext highlighter-rouge">com.example.spi.impl.LocalStorage</code>, <code class="language-plaintext highlighter-rouge">com.example.spi.impl.S3Storage</code></li>
  <li>声明文件：<code class="language-plaintext highlighter-rouge">META-INF/services/com.example.spi.Storage</code>
    <ul>
      <li>内容：
        <ul>
          <li><code class="language-plaintext highlighter-rouge">com.example.spi.impl.LocalStorage</code></li>
          <li><code class="language-plaintext highlighter-rouge">com.example.spi.impl.S3Storage</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Storage</span> <span class="o">{</span> <span class="kt">void</span> <span class="nf">write</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span><span class="o">);</span> <span class="o">}</span>

<span class="nc">ServiceLoader</span><span class="o">&lt;</span><span class="nc">Storage</span><span class="o">&gt;</span> <span class="n">loader</span> <span class="o">=</span> <span class="nc">ServiceLoader</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="nc">Storage</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Storage</span> <span class="n">s</span> <span class="o">:</span> <span class="n">loader</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">s</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"k"</span><span class="o">,</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>工作机制：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ServiceLoader</code> 默认使用当前线程的 TCCL（<code class="language-plaintext highlighter-rouge">Thread.currentThread().getContextClassLoader()</code>）读取 <code class="language-plaintext highlighter-rouge">META-INF/services</code>。</li>
  <li>若 TCCL 为空，则回退到 <code class="language-plaintext highlighter-rouge">ServiceLoader</code> 自身的加载器。</li>
</ul>

<h3 id="32-容器与多-classloader-环境的坑">3.2 容器与多 ClassLoader 环境的坑</h3>

<ul>
  <li>在应用服务器、微服务框架、插件系统中，接口与实现往往位于不同加载器。若 TCCL 未指向“实现所在加载器”，会出现找不到实现的情况。</li>
  <li>解决：在调用前设置合适的 TCCL，或使用 <code class="language-plaintext highlighter-rouge">ServiceLoader.load(接口, 实现所在的ClassLoader)</code> 显式指定。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ClassLoader</span> <span class="n">implLoader</span> <span class="o">=</span> <span class="n">pluginClassLoader</span><span class="o">;</span> <span class="c1">// 实现所在加载器</span>
<span class="nc">ServiceLoader</span><span class="o">&lt;</span><span class="nc">Storage</span><span class="o">&gt;</span> <span class="n">loader</span> <span class="o">=</span> <span class="nc">ServiceLoader</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="nc">Storage</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">implLoader</span><span class="o">);</span>
</code></pre></div></div>

<p>常见依赖 SPI 的组件：JDBC 驱动加载、JUL <code class="language-plaintext highlighter-rouge">Logging</code>, JAXP, JSON-B/JSON-P、JCA、JDBC-URL 自动发现、SLF4J 的服务桥接等。排查相关问题时优先检查 TCCL 与 <code class="language-plaintext highlighter-rouge">META-INF/services</code>。</p>

<h3 id="33-与模块化jpmsosgi的关系">3.3 与模块化（JPMS/OSGi）的关系</h3>

<ul>
  <li>JPMS：在 <code class="language-plaintext highlighter-rouge">module-info.java</code> 中通过 <code class="language-plaintext highlighter-rouge">uses</code>/<code class="language-plaintext highlighter-rouge">provides ... with ...</code> 显式声明服务使用与提供；跨模块访问受导出规则约束。</li>
  <li>OSGi：每个 Bundle 本质是独立 ClassLoader，导出/导入包决定可见性。SPI 文件通常需要打包到导出的资源路径，并确保上下文加载器在正确的 Bundle。</li>
</ul>

<p>工程建议：</p>
<ul>
  <li>为公共接口单独建“API 模块”由上层加载器加载；实现各自打包并在需要时通过 SPI 或容器注册方式装配。</li>
  <li>避免将实现类泄漏到 API 包或公共加载器，减少“二义性解析”。</li>
</ul>

<hr />

<h2 id="4-从-aop-到字节码增强把加载时与运行时串起来">4. 从 AOP 到字节码增强：把“加载时”与“运行时”串起来</h2>

<p>动态代理与 AOP 是“增强”的入口：</p>
<ul>
  <li>JDK 代理基于接口；CGLIB 基于子类；都属于“对象层”的拦截。</li>
  <li>字节码增强则直接在“类定义层”改写方法体或插桩，覆盖更广（无接口限制）且可零侵入接入现有代码。</li>
</ul>

<p>增强的时间点：</p>
<ul>
  <li>编译期：借助 <code class="language-plaintext highlighter-rouge">javac</code> 插件或 Gradle/Maven 插件处理字节码（如 Lombok、MapStruct）。</li>
  <li>加载期：通过 <code class="language-plaintext highlighter-rouge">Instrumentation</code> 的 <code class="language-plaintext highlighter-rouge">ClassFileTransformer</code> 在类被 JVM 定义前改写；</li>
  <li>运行期：Attach 到目标 JVM，<code class="language-plaintext highlighter-rouge">retransform</code>/<code class="language-plaintext highlighter-rouge">redefine</code> 已加载类。</li>
</ul>

<p>常用类库与对比：</p>
<ul>
  <li>ASM：指令级 API，最灵活也最底层，性能最好，学习曲线陡峭。</li>
  <li>Javassist：以“源码字符串/表达式”方式组装，易用性高，适合快速原型。</li>
  <li>Byte Buddy：类型安全的 Fluent API，生态完善（与 Agent、Mockito、Android 兼容性好）。</li>
</ul>

<hr />

<h2 id="5-java-agent-实战速览加载期与运行期">5. Java Agent 实战速览（加载期与运行期）</h2>

<h3 id="51-预主代理premain随进程启动">5.1 预主代理（premain）：随进程启动</h3>

<p><code class="language-plaintext highlighter-rouge">MANIFEST.MF</code>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Premain-Class: com.example.agent.DemoAgent
Can-Redefine-Classes: true
Can-Retransform-Classes: true
</code></pre></div></div>

<p>Agent：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoAgent</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">premain</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">,</span> <span class="nc">Instrumentation</span> <span class="n">inst</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">inst</span><span class="o">.</span><span class="na">addTransformer</span><span class="o">(</span><span class="k">new</span> <span class="nc">TimingTransformer</span><span class="o">(),</span> <span class="kc">true</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Transformer（以 Byte Buddy 为例）：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TimingTransformer</span> <span class="kd">implements</span> <span class="nc">ClassFileTransformer</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">transform</span><span class="o">(</span><span class="nc">Module</span> <span class="n">module</span><span class="o">,</span> <span class="nc">ClassLoader</span> <span class="n">loader</span><span class="o">,</span> <span class="nc">String</span> <span class="n">className</span><span class="o">,</span>
                          <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">classBeingRedefined</span><span class="o">,</span> <span class="nc">ProtectionDomain</span> <span class="n">pd</span><span class="o">,</span>
                          <span class="kt">byte</span><span class="o">[]</span> <span class="n">classfileBuffer</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">className</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">className</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"com/example/service/"</span><span class="o">))</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="c1">// 使用 ASM/Javassist/Byte Buddy 改写方法体，插入计时代码</span>
    <span class="c1">// 返回新的字节码；返回 null 表示不改写</span>
    <span class="k">return</span> <span class="nf">enhance</span><span class="o">(</span><span class="n">classfileBuffer</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>启动：<code class="language-plaintext highlighter-rouge">java -javaagent:demo-agent.jar -jar app.jar</code></p>

<h3 id="52-运行期-attach无重启注入">5.2 运行期 Attach：无重启注入</h3>

<p><code class="language-plaintext highlighter-rouge">MANIFEST.MF</code>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Agent-Class: com.example.agent.DemoAgent
Can-Redefine-Classes: true
Can-Retransform-Classes: true
</code></pre></div></div>

<p>Agent：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoAgent</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">agentmain</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">,</span> <span class="nc">Instrumentation</span> <span class="n">inst</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">inst</span><span class="o">.</span><span class="na">addTransformer</span><span class="o">(</span><span class="k">new</span> <span class="nc">TimingTransformer</span><span class="o">(),</span> <span class="kc">true</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">c</span> <span class="o">:</span> <span class="n">inst</span><span class="o">.</span><span class="na">getAllLoadedClasses</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"com.example.service"</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span> <span class="n">inst</span><span class="o">.</span><span class="na">retransformClasses</span><span class="o">(</span><span class="n">c</span><span class="o">);</span> <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">ignore</span><span class="o">)</span> <span class="o">{}</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Attach 到目标进程：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">VirtualMachine</span> <span class="n">vm</span> <span class="o">=</span> <span class="nc">VirtualMachine</span><span class="o">.</span><span class="na">attach</span><span class="o">(</span><span class="s">"&lt;pid&gt;"</span><span class="o">);</span>
<span class="n">vm</span><span class="o">.</span><span class="na">loadAgent</span><span class="o">(</span><span class="s">"/path/demo-agent.jar"</span><span class="o">);</span>
<span class="n">vm</span><span class="o">.</span><span class="na">detach</span><span class="o">();</span>
</code></pre></div></div>

<p>要点与限制：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">redefine</code>/<code class="language-plaintext highlighter-rouge">retransform</code> 不能随意更改已加载类的结构（如新增/删除字段、方法签名变化），通常仅能改写方法体。</li>
  <li>性能与稳定性优先：过滤目标类与方法范围；避免在 Transformer 中做 I/O 或重计算。</li>
  <li>安全与合规：生产注入需严格审批与审计；避免收集敏感数据；为回滚预留“撤销增强”的能力。</li>
</ul>

<p>实践场景：</p>
<ul>
  <li>无侵入埋点与链路追踪、慢调用采样、SQL/HTTP 出入口观测。</li>
  <li>线上紧急诊断（打印入参/返回值/堆栈）、热点修复（谨慎使用）。</li>
  <li>框架级特性（如 Spring AOP、ORM 懒加载）背后常用到字节码增强。</li>
</ul>

<hr />

<h2 id="6-将类加载spi-与-agent-串成一条工程实践链">6. 将类加载、SPI 与 Agent 串成一条“工程实践链”</h2>

<p>面对实际系统时，可以按以下 checklist 设计与排错：</p>

<ul>
  <li>类加载边界
    <ul>
      <li>定义“API 包”（接口与 DTO）由上层加载器加载；实现各自位于独立 <code class="language-plaintext highlighter-rouge">ClassLoader</code>；</li>
      <li>插件只暴露接口，避免对外泄漏实现类；</li>
      <li>谨慎采用“先本地后父类”的策略，并限制可覆盖包前缀；</li>
    </ul>
  </li>
  <li>SPI 装配
    <ul>
      <li>确保 <code class="language-plaintext highlighter-rouge">META-INF/services/&lt;接口全名&gt;</code> 存在且内容正确；</li>
      <li>在容器/插件环境中使用正确的 TCCL 或显式传入实现加载器；</li>
      <li>对多实现场景，建立可配置的选择策略（优先级、条件加载）；</li>
    </ul>
  </li>
  <li>诊断与增强
    <ul>
      <li>开发态：使用 Byte Buddy/Javassist 快速验证增强点；</li>
      <li>生产态：以 Agent 注入，限定类集合，提供开关与回滚；</li>
      <li>记录增强带来的额外开销，建立 SLO 告警；</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="7-常见问题速查">7. 常见问题速查</h2>

<ul>
  <li>为什么 <code class="language-plaintext highlighter-rouge">ServiceLoader</code> 在本地能找到实现，部署到容器后找不到？
    <ul>
      <li>检查 TCCL 是否指向实现所在加载器；容器可能切换线程或包裹执行；显式使用 <code class="language-plaintext highlighter-rouge">ServiceLoader.load(接口, 加载器)</code>。</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">X cannot be cast to X</code> 但类名完全相同？
    <ul>
      <li>两个 X 分别由不同 <code class="language-plaintext highlighter-rouge">ClassLoader</code> 定义。收敛公共类型到 API 包；跨边界仅传递接口或数据类。</li>
    </ul>
  </li>
  <li>引入 Agent 后偶发死锁/卡顿？
    <ul>
      <li>Transformer 中做了 I/O/日志锁争用；或改写引入了同步膨胀。减少锁、避开热点方法、加采样率。</li>
    </ul>
  </li>
  <li>能否在运行期给类“加字段/加方法”？
    <ul>
      <li>受限于 JVM 的 redefinition 能力，一般不可以；需通过“旁路存储”（<code class="language-plaintext highlighter-rouge">ConcurrentHashMap&lt;Class&lt;?&gt;, Data&gt;</code>）、<code class="language-plaintext highlighter-rouge">invokedynamic</code> 或“代理包装”规避。</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="8-结语">8. 结语</h2>

<p>类加载与 SPI 决定了“模块如何被看见与装配”，字节码增强与 Agent 决定了“模块在运行期如何被观测与改变”。把二者打通，既能写出可演化、可观测的系统，也能在复杂运行环境中快速定位问题、降低故障恢复时间（MTTR）。</p>

<hr />

<h2 id="参考与延伸阅读">参考与延伸阅读</h2>

<ul>
  <li>The Java Virtual Machine Specification（ClassFile 与指令集）</li>
  <li>Byte Buddy、ASM、Javassist 官方文档</li>
  <li>JDK <code class="language-plaintext highlighter-rouge">java.util.ServiceLoader</code> 源码与 <code class="language-plaintext highlighter-rouge">META-INF/services</code> 约定</li>
</ul>


    </div>
  </div>

  
  
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
    
    
    
    
  
    
    
    
      
        
    
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
    
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
    
    
    
    
  
    
    
    
      
        
    
    
    
    
  
  <section class="related-posts">
    <h2>相关阅读</h2>
    <ul>
      
        <li><a href="/%E6%8A%80%E6%9C%AF/nginx/2025/07/01/Nginx-Ingress-%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5.html">Nginx Ingress 高并发场景优化实践</a> <small>(2025-07-01)</small></li>
      
        <li><a href="/%E6%8A%80%E6%9C%AF/nginx/2025/06/28/Nginx-%E9%9B%B6%E5%81%9C%E6%9C%BA%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E4%B8%8E%E5%9B%9E%E6%BB%9A%E7%AD%96%E7%95%A5.html">Nginx 零停机灰度发布与回滚策略</a> <small>(2025-06-28)</small></li>
      
        <li><a href="/%E6%8A%80%E6%9C%AF/nginx/2023/12/05/Nginx-Ingress-%E5%9C%A8Kubernetes%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E9%85%8D%E7%BD%AE.html">Nginx Ingress 在 Kubernetes 的高可用配置</a> <small>(2023-12-05)</small></li>
      
        <li><a href="/%E6%8A%80%E6%9C%AF/mysql/2023/02/27/MySQL-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E4%BB%8E-explain-%E5%88%B0%E7%81%AB%E7%84%B0%E5%9B%BE.html">MySQL-慢查询优化-从-explain-到火焰图</a> <small>(2023-02-27)</small></li>
      
        <li><a href="/%E6%8A%80%E6%9C%AF/golang/2022/10/07/Go-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-Channel%E4%B8%8EContext%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html">Go 并发模型：Channel 与 Context 最佳实践</a> <small>(2022-10-07)</small></li>
      
    </ul>
  </section>
  

  <footer class="post-footer">
    <div class="share">
      <a href="https://twitter.com/intent/tweet?text=Java%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8E%20SPI%20%E6%9C%BA%E5%88%B6%E5%AE%9E%E8%B7%B5&url=http://localhost:4000/%E6%8A%80%E6%9C%AF/java/2017/04/09/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8ESPI%E6%9C%BA%E5%88%B6%E5%AE%9E%E8%B7%B5.html" target="_blank">Share to X</a>
      <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/%E6%8A%80%E6%9C%AF/java/2017/04/09/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8ESPI%E6%9C%BA%E5%88%B6%E5%AE%9E%E8%B7%B5.html" target="_blank" style="margin-left:12px;">Share to Facebook</a>
    </div>

    
    <section id="comments" style="margin-top: 24px;">
      <script src="https://giscus.app/client.js"
        data-repo=""
        data-repo-id=""
        data-category="General"
        data-category-id=""
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="light"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
      </script>
    </section>
    
  </footer>
</article>

<button id="back-to-top" title="回到顶部">↑</button>

<script>
// 构建目录
(function(){
  const content = document.getElementById('post-content');
  const toc = document.getElementById('toc');
  if (!content || !toc) return;
  const headings = content.querySelectorAll('h1, h2, h3');
  if (!headings.length) return;
  const ul = document.createElement('ul');
  headings.forEach(h => {
    if (!h.id) h.id = h.textContent.trim().toLowerCase().replace(/\s+/g, '-');
    const li = document.createElement('li');
    li.style.marginLeft = ({H1:0,H2:12,H3:24})[h.tagName] + 'px';
    const a = document.createElement('a');
    a.href = '#' + h.id;
    a.textContent = h.textContent;
    li.appendChild(a);
    ul.appendChild(li);
  });
  const title = document.createElement('div');
  title.textContent = '目录';
  title.style.fontWeight = 'bold';
  title.style.marginBottom = '8px';
  toc.appendChild(title);
  toc.appendChild(ul);
})();

// 代码复制按钮
(function(){
  document.querySelectorAll('pre > code').forEach(code => {
    const pre = code.parentElement;
    const btn = document.createElement('button');
    btn.textContent = '复制';
    btn.className = 'copy-btn';
    btn.onclick = async () => {
      try { await navigator.clipboard.writeText(code.innerText); btn.textContent = '已复制'; setTimeout(()=>btn.textContent='复制',1000);} catch(e) {}
    };
    pre.style.position = 'relative';
    btn.style.position = 'absolute';
    btn.style.right = '8px';
    btn.style.top = '8px';
    pre.appendChild(btn);
  });
})();

// 回到顶部
(function(){
  const btn = document.getElementById('back-to-top');
  const onscroll = () => { btn.style.display = window.scrollY > 300 ? 'block' : 'none'; };
  window.addEventListener('scroll', onscroll); onscroll();
  btn.onclick = () => window.scrollTo({top:0, behavior:'smooth'});
})();

// 图片懒加载
(function(){
  document.querySelectorAll('#post-content img').forEach(img => {
    img.loading = 'lazy';
    if (!img.hasAttribute('alt') || img.getAttribute('alt') === '') {
      try {
        const u = new URL(img.src, window.location.origin);
        const name = (u.pathname.split('/').pop() || '').split('.')[0];
        if (name) img.setAttribute('alt', decodeURIComponent(name));
      } catch (e) {}
    }
  });
})();
</script>

<style>
.post-body{display:flex; gap:24px}
#toc{min-width:200px; max-width:240px; position:sticky; top:80px; height:max-content}
#post-content{flex:1}
#back-to-top{position:fixed; right:16px; bottom:24px; display:none; padding:8px 10px}
.copy-btn{font-size:12px; padding:2px 6px}
@media (max-width: 900px){ .post-body{flex-direction:column;} #toc{position:static;}}
</style><script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java 类加载器与 SPI 机制实践",
  "description": "梳理类加载全流程与双亲委派、命名空间隔离，深入 SPI 与 TCCL 的装配机制，并结合字节码增强/Agent 构建从加载到运行期增强的工程链路。",
  "datePublished": "2017-04-09T00:00:00+08:00",
  "dateModified": "2025-08-09T19:09:21+08:00",
  "author": {
    "@type": "Person",
    "name": "TayloyChen"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:4000/%E6%8A%80%E6%9C%AF/java/2017/04/09/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8ESPI%E6%9C%BA%E5%88%B6%E5%AE%9E%E8%B7%B5.html"
  },
  "url": "http://localhost:4000/%E6%8A%80%E6%9C%AF/java/2017/04/09/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8ESPI%E6%9C%BA%E5%88%B6%E5%AE%9E%E8%B7%B5.html"
}
</script>



      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">TayloyChen Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">{&quot;name&quot; =&gt; &quot;TayloyChen&quot;, &quot;url&quot; =&gt; &quot;https://taylorchen.github.io&quot;}</li><li><a class="u-email" href="mailto:cherrycmd@gmail.com">cherrycmd@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/taylorchen"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">taylorchen</span></a></li><li><a href="https://www.twitter.com/shlchen"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">shlchen</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>这里是 TayloyChen 的个人博客，与你一起发现更大的世界 | 要做一个有 ikigai 的程序员</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
