<!DOCTYPE html>
<html lang="zh-CN"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Go goroutine 调度器原理：GMP | TayloyChen Blog</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Go goroutine 调度器原理：GMP" />
<meta name="author" content="TayloyChen" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="系统拆解 Go 的 G-M-P 三元模型、work stealing、抢占与 netpoller 协作机制，配合实验/可观测手段理解调度器的性能与权衡。" />
<meta property="og:description" content="系统拆解 Go 的 G-M-P 三元模型、work stealing、抢占与 netpoller 协作机制，配合实验/可观测手段理解调度器的性能与权衡。" />
<link rel="canonical" href="http://localhost:4000/%E6%8A%80%E6%9C%AF/golang/2015/11/02/Go-goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86GMP.html" />
<meta property="og:url" content="http://localhost:4000/%E6%8A%80%E6%9C%AF/golang/2015/11/02/Go-goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86GMP.html" />
<meta property="og:site_name" content="TayloyChen Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-11-02T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Go goroutine 调度器原理：GMP" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"TayloyChen","url":"https://taylorchen.github.io"},"dateModified":"2025-08-09T19:09:21+08:00","datePublished":"2015-11-02T00:00:00+08:00","description":"系统拆解 Go 的 G-M-P 三元模型、work stealing、抢占与 netpoller 协作机制，配合实验/可观测手段理解调度器的性能与权衡。","headline":"Go goroutine 调度器原理：GMP","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/%E6%8A%80%E6%9C%AF/golang/2015/11/02/Go-goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86GMP.html"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/images/favicons/favicon-96x96.png"},"name":"TayloyChen"},"url":"http://localhost:4000/%E6%8A%80%E6%9C%AF/golang/2015/11/02/Go-goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86GMP.html"}</script>
<!-- End Jekyll SEO tag -->

  
  
    <meta property="article:modified_time" content="2025-08-09T19:09:21+08:00">
  
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="alternate" type="application/atom+xml" href="http://localhost:4000/feed.xml" title="TayloyChen Blog" />
  <link rel="icon" href="/assets/images/favicons/favicon.ico" type="image/x-icon">
  
  
    <meta property="og:image" content="http://localhost:4000/assets/images/2e9ea54a25bedd353d5e06c076d9c7e4.jpeg">
    <meta name="twitter:image" content="http://localhost:4000/assets/images/2e9ea54a25bedd353d5e06c076d9c7e4.jpeg">
  
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/">TayloyChen Blog</a>
    <nav class="site-nav">
      <a class="page-link" href="/">首页</a>
      <a class="page-link" href="/categories/">分类</a>
      <a class="page-link" href="/tags/">标签</a>
      <a class="page-link" href="/archives/">归档</a>
      <a class="page-link" href="/search/">搜索</a>
      <a class="page-link" href="/about/">关于</a>
    </nav>
  </div>
</header>


<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">
  <header>
    <h1>Go goroutine 调度器原理：GMP</h1>
    <p class="post-meta">
      <time datetime="2015-11-02T00:00:00+08:00">2015-11-02</time>
       · 最后更新于 <time datetime="2025-08-09T19:09:21+08:00">2025-08-09</time>
       · 技术 / Golang
       · 技术, Golang, GMP, 调度器, 并发
    </p>
    
      <meta name="description" content="系统拆解 Go 的 G-M-P 三元模型、work stealing、抢占与 netpoller 协作机制，配合实验/可观测手段理解调度器的性能与权衡。">
    
    
      <meta name="keywords" content="技术, Golang, GMP, 调度器, 并发">
    
  </header>

  <div class="post-body" id="post-body">
    <aside id="toc"></aside>
    <div id="post-content">
      <p>这篇文章不只是“是什么”，而是从语言设计动机与系统实现细节出发，系统性拆解 Go 调度器的三元模型：G（goroutine）、M（OS thread）、P（processor）。围绕“为什么要引入 GMP”“GMP 解决了什么问题”“有哪些代价与权衡”“如何直观理解并用实验证明”，我们给出多维度、可操作的深度解读。</p>

<h2 id="一动机go-想解决什么问题">一、动机：Go 想解决什么问题？</h2>

<p>如果回到 2007–2009 年 Go 诞生的背景，Google 内部已经在大规模分布式系统中挣扎：</p>
<ul>
  <li>需要写高并发服务，却要在复杂的回调、线程与锁之间艰难取舍；</li>
  <li>线程创建与上下文切换成本高，每个线程动辄 MB 级别栈内存；</li>
  <li>I/O 与 CPU 混合型负载让“要么阻塞、要么回调”的模型两头不讨好；</li>
  <li>C/C++ 缺少一等公民的并发原语，异步代码可读性差而且脆弱。</li>
</ul>

<p>Go 的答案可以浓缩为三点：</p>
<ul>
  <li>基于 CSP 的并发观：以 goroutine 与 channel 为一等公民，用“看起来可阻塞”的直观代码描述并发；</li>
  <li>用户态调度器：把大量 goroutine 以 M:N 方式复用到少量 OS 线程上，降低成本并提升可伸缩性；</li>
  <li>面向工程实战：自动栈增长、抢占、网络 poller、分配器与 GC 协同，提供“默认高效、按需可调”的体验。</li>
</ul>

<p>GMP 模型正是在这样的目标约束下诞生：既要“写起来像同步”，又要“跑起来像高性能异步”，还要“在多核机器上自然扩展”。</p>

<h2 id="二设计思想从-11-到-mn再到-p-的引入">二、设计思想：从 1:1 到 M:N，再到 P 的引入</h2>

<p>线程模型的历史谱系大致有三类：</p>
<ul>
  <li>1:1（每个用户线程映射一个 OS 线程）：实现简单，但创建/销毁、上下文切换和栈内存都昂贵；</li>
  <li>N:1（绿色线程，全在用户态）：切换快，但无法利用多核，遇到系统调用就会整体阻塞；</li>
  <li>M:N（用户态与内核态混合）：折中路线，但实现复杂，边界条件众多。</li>
</ul>

<p>Go 选择 M:N，但早期只存在 G 和 M，很快遭遇扩展性与缓存局部性问题：多个 M 抢同一把全局锁从全局 run queue 取任务，导致抖动。Go 1.1 引入 P（processor）作为“执行 goroutine 的逻辑 CPU 配额与本地 run queue”，解决两个核心痛点：</p>
<ul>
  <li>把就绪 G 分散到 P 的本地队列，提升缓存命中并减少锁竞争；</li>
  <li>通过 work stealing 在 P 之间均衡负载，避免个别 P 饥饿。</li>
</ul>

<p>因此，GMP 的真实目标不是“多一个字母”，而是让“可伸缩的用户态调度”成为现实。</p>

<h2 id="三模型总览gmp-分工与数量关系">三、模型总览：G、M、P 分工与数量关系</h2>

<ul>
  <li>G（goroutine）：用户态轻量执行单元，拥有栈（可动态增长）、状态（就绪/运行/阻塞/等待）与入口函数。</li>
  <li>M（machine/OS thread）：真实的内核线程，负责执行 G 的载体。M 必须绑定一个 P 才能运行 Go 代码；无 P 的 M 只能执行 syscalls 或处于空闲。</li>
  <li>P（processor）：调度器中的“核”和本地运行队列，数量等于 <code class="language-plaintext highlighter-rouge">GOMAXPROCS</code>。每个 P 维护 run queue、runnext 插槽、定时器等。</li>
</ul>

<p>典型约束：</p>
<ul>
  <li>同一时刻最多有 <code class="language-plaintext highlighter-rouge">GOMAXPROCS</code> 个 M 持有 P 并并行执行 Go 代码；</li>
  <li>G 的创建很廉价，调度器倾向把新 G 放入当前 P 的 run queue；</li>
  <li>无事可做的 P 会从全局队列或其他 P 窃取 G（work stealing）。</li>
</ul>

<h2 id="四调度循环一条-g-的旅程">四、调度循环：一条 G 的旅程</h2>

<p>1) 创建/就绪：<code class="language-plaintext highlighter-rouge">go f()</code> 创建 G，优先放进当前 P 的本地队列；
2) 取出与执行：持有该 P 的 M 从 run queue 取 G，放到寄存器与栈上开始执行；
3) 阻塞分流：</p>
<ul>
  <li>如果 G 调用 <code class="language-plaintext highlighter-rouge">syscall</code>/<code class="language-plaintext highlighter-rouge">cgo</code> 进入内核阻塞，M 也会阻塞；调度器把“被困”的 P 转借给其他空闲的 M，以保证 <code class="language-plaintext highlighter-rouge">GOMAXPROCS</code> 并行度；</li>
  <li>如果 G 因 channel/锁/I/O 等用户态阻塞，M 让出当前 G，切回调度器，从本地队列或其他 P 继续取活；</li>
  <li>网络 I/O 由 netpoller（epoll/kqueue/IOCP）负责等待并唤醒相关 G；
4) 抢占与让出：</li>
  <li>协作式：函数 prologue 设置安全点，允许在调用边界被切走；</li>
  <li>异步抢占（Go 1.14 起）：runtime 可向线程注入信号，在抢占安全点强制把 G 让出，避免大计算长期独占；
5) 完成与回收：G 正常返回或 panic 结束后，M 继续从队列取下一个 G。</li>
</ul>

<h2 id="五关键机制详解">五、关键机制详解</h2>

<h3 id="51-本地队列全局队列与-runnext">5.1 本地队列、全局队列与 runnext</h3>
<ul>
  <li>本地队列：每个 P 维护一个环形队列，push/pop 均无锁或轻锁；</li>
  <li>全局队列：系统级备用队列，多个 P 在饥饿时会从中批量拉取；</li>
  <li>runnext：为提升缓存命中，调度器保留“下一个立刻运行”的插槽（如 <code class="language-plaintext highlighter-rouge">go ready</code> 刚唤醒的 G）。</li>
</ul>

<h3 id="52-work-stealing">5.2 Work Stealing</h3>
<p>当某个 P 的队列耗尽，会从全局队列或随机挑选另一个 P 窃取一半任务（按块移动），在保持均衡的同时减少锁冲突。该策略在大规模 goroutine 场景下显著降低尾延迟。</p>

<h3 id="53-系统调用与-mp-解耦">5.3 系统调用与 M/P 解耦</h3>
<p>对于可能长时间阻塞的内核调用：</p>
<ul>
  <li>进入 syscall 前记录状态；</li>
  <li>M 进入内核后若长时间不返回，调度器将其 P 迁出给其他可运行的 M；</li>
  <li>当 syscall 返回，若原 P 已被转移，则尝试从全局获取 P 或把 G 放回队列等待调度。</li>
</ul>

<h3 id="54-netpoller">5.4 Netpoller</h3>
<p>Go 的网络库用平台相关的 poller 将“看似阻塞的 Read/Write”转为“注册事件 + 等待唤醒”。当事件就绪，poller 把对应 G 标记为 runnable，放回某个 P 的队列。这是“看似同步、实则异步”的关键一环。</p>

<h3 id="55-抢占从协作到异步">5.5 抢占：从协作到异步</h3>
<p>早期 Go 主要依赖协作式抢占，即在函数调用边界（safe point）让出。对于紧密循环或内联后的长计算，可能长时间不让出，导致延迟抖动。Go 1.14 引入异步抢占：</p>
<ul>
  <li>runtime 向执行线程注入抢占信号；</li>
  <li>在线程到达可抢占的安全点（如栈检查、轮询点）时挂起 G，切回调度器；</li>
  <li>减少“计算型 goroutine”对系统的拖滞，提升吞吐与 P99 延迟。</li>
</ul>

<h3 id="56-栈管理">5.6 栈管理</h3>
<p>goroutine 使用“连续可增长栈”，初始很小（KB 级），随着深度增长按需扩容（拷贝并修正栈指针）。这使得创建百万 goroutine 成为可能，也与调度器的轻量切换协同增效。</p>

<h3 id="57-与-gc-的协作">5.7 与 GC 的协作</h3>
<p>调度器与 GC 紧密耦合：</p>
<ul>
  <li>标记辅助（mutator assist）在分配压力大时让运行的 G 协助标记；</li>
  <li>写屏障保证并发标记期正确性；</li>
  <li>STW 窗口尽量缩小，但仍需要在世界停止时统一栈扫描与根收集；</li>
  <li>抢占点也服务于 GC 对“尽快看到所有栈”的诉求。</li>
</ul>

<h3 id="58-系统监控线程sysmon">5.8 系统监控线程（sysmon）</h3>
<p>后台监控 goroutine/线程状态、定时器、抢占信号、垃圾回收触发等，是调度系统“保安 + 协调员”。</p>

<h2 id="六gmp-解决了哪些实际问题">六、GMP 解决了哪些实际问题？</h2>

<ul>
  <li>低成本并发原语：创建/销毁 goroutine 成本远低于线程，栈按需增长；</li>
  <li>多核可伸缩：<code class="language-plaintext highlighter-rouge">GOMAXPROCS</code> 决定并发执行 goroutine 的上限，通过 P 的本地队列与 stealing 在多核扩展；</li>
  <li>同步代码风格的高性能 I/O：netpoller 让“看起来阻塞”的 API 拥有“异步性能”；</li>
  <li>更好地处理混合负载：系统调用阻塞与用户态阻塞分流，保持整体吞吐；</li>
  <li>可观测性与可调优：<code class="language-plaintext highlighter-rouge">pprof</code>、<code class="language-plaintext highlighter-rouge">trace</code>、<code class="language-plaintext highlighter-rouge">schedtrace</code> 等工具帮助定位性能瓶颈与调度异常。</li>
</ul>

<h2 id="七权衡与潜在弊端">七、权衡与潜在弊端</h2>

<ul>
  <li>实现复杂度高：调度器、GC、分配器、netpoller 的耦合提升了 runtime 复杂性与维护难度；</li>
  <li>尾延迟与公平性：尽管有抢占与 stealing，极端负载下仍可能出现饥饿或抖动；</li>
  <li><code class="language-plaintext highlighter-rouge">syscall</code>/<code class="language-plaintext highlighter-rouge">cgo</code> 交互成本：频繁进入内核或调用 C 代码，会触发 P 迁移/线程增减，影响稳定性与预测性；</li>
  <li>G 泄漏更隐蔽：看似阻塞的 goroutine 更容易“被遗忘”，如未消费的 <code class="language-plaintext highlighter-rouge">time.After</code>、无界 channel；</li>
  <li>调参误区：盲目调大 <code class="language-plaintext highlighter-rouge">GOMAXPROCS</code> 可能加剧锁竞争与切换开销，未必提升吞吐；</li>
  <li>平台细节差异：netpoller 依赖 epoll/kqueue/IOCP，不同平台边界行为可能不同。</li>
</ul>

<h2 id="八如何直观理解一个工厂的类比">八、如何直观理解：一个工厂的类比</h2>

<p>把 P 想象成“装配线”，M 是“工人”，G 是“待加工的零件”：</p>
<ul>
  <li>每条装配线（P）有自己的待加工队列（本地 run queue），减少不同线之间的争抢；</li>
  <li>工人（M）必须绑定一条装配线才能干活；</li>
  <li>如果某条线不饱和，工人会去别的线“偷”一半零件回来（work stealing）；</li>
  <li>遇到需要外部检验（syscall）时，工人要暂时离开车间，但这条线会很快分配给另一名工人，保证机器不停；</li>
  <li>车间主任（sysmon）偶尔会打断某个工人，防止他在一个零件上磨蹭太久（异步抢占）。</li>
</ul>

<p>一个近似的 ASCII 示意：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P0(runq) ←→ M0  执行 G...
P1(runq) ←→ M1  执行 G...
P2(runq) ←→ M2  执行 G...
       ↖ stealing ↗
   全局队列 / netpoller 唤醒
</code></pre></div></div>

<h2 id="九实验观察-gomaxprocs-与调度行为">九、实验：观察 <code class="language-plaintext highlighter-rouge">GOMAXPROCS</code> 与调度行为</h2>

<p>下面的程序用递归 <code class="language-plaintext highlighter-rouge">fib</code> 制造 CPU 压力，观察不同 <code class="language-plaintext highlighter-rouge">GOMAXPROCS</code> 的吞吐变化（实际结果取决于机器核数与调度器负载）。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>
<span class="k">import</span> <span class="p">(</span>
  <span class="s">"runtime"</span>
  <span class="s">"sync"</span>
  <span class="s">"time"</span>
  <span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="m">2</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span> <span class="p">};</span> <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="m">1</span><span class="p">)</span><span class="o">+</span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="m">2</span><span class="p">)</span> <span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">8</span><span class="p">}</span> <span class="p">{</span>
    <span class="n">runtime</span><span class="o">.</span><span class="n">GOMAXPROCS</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
    <span class="n">start</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">100000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
      <span class="k">go</span> <span class="k">func</span><span class="p">(){</span> <span class="n">_</span> <span class="o">=</span> <span class="n">fib</span><span class="p">(</span><span class="m">20</span><span class="p">);</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span> <span class="p">}()</span>
    <span class="p">}</span>
    <span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"P="</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="s">"cost="</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">Since</span><span class="p">(</span><span class="n">start</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>观察调度轨迹：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">GODEBUG</span><span class="o">=</span><span class="nv">schedtrace</span><span class="o">=</span>1000,scheddetail<span class="o">=</span>1 ./app
<span class="c"># 也可打开 pprof：</span>
<span class="c"># go tool pprof -http=:0 http://localhost:6060/debug/pprof/profile</span>
</code></pre></div></div>

<p>示例：对“长计算不让出”的可观测性（Go 1.14 前后对比思路）：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 紧密循环若无函数调用，旧版本更难被协作式抢占，</span>
<span class="c">// 新版的异步抢占可显著改善系统整体延迟。</span>
<span class="k">func</span> <span class="n">busyLoop</span><span class="p">(</span><span class="n">deadline</span> <span class="n">time</span><span class="o">.</span><span class="n">Time</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">Before</span><span class="p">(</span><span class="n">deadline</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// 做一些计算</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="十可观测性tracepprofschedtrace-看什么">十、可观测性：trace/pprof/schedtrace 看什么</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">schedtrace</code>：周期打印 P/M/G 的数量、全局/本地队列长度、spinning 线程数，快速判断是否存在饥饿或过度抢占；</li>
  <li><code class="language-plaintext highlighter-rouge">pprof</code>：
    <ul>
      <li>CPU profile 看热点函数与调度器开销；</li>
      <li>Block profile 观察 channel/互斥等待；</li>
      <li>Mutex profile 关注 runtime 锁与业务锁竞争；</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">go tool trace</code>：时间轴上展示 G 的生命周期变化、网络事件与 syscalls，更直观地定位抖动来源。</li>
</ul>

<h2 id="十一实战建议与反模式">十一、实战建议与反模式</h2>

<ul>
  <li>合理设置 <code class="language-plaintext highlighter-rouge">GOMAXPROCS</code>：通常默认即可。CPU 密集场景接近物理核心数；过大只会带来锁竞争与切换成本；</li>
  <li>避免无界 goroutine：对输入做限流，用 worker pool 或 <code class="language-plaintext highlighter-rouge">errgroup</code>；</li>
  <li>小心 <code class="language-plaintext highlighter-rouge">time.After</code> 泄漏：未读取的计时器会保留 G；可改用 <code class="language-plaintext highlighter-rouge">time.NewTimer</code> 并 <code class="language-plaintext highlighter-rouge">Stop</code>；</li>
  <li>处理 <code class="language-plaintext highlighter-rouge">syscall/cgo</code>：尽量缩短阻塞时间，必要时隔离到专用池或进程；</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">context</code> 超时/取消：避免永久阻塞 goroutine；</li>
  <li>明确选择 <code class="language-plaintext highlighter-rouge">channel</code> 与 <code class="language-plaintext highlighter-rouge">mutex</code>：小临界区用锁更直白，复杂编排用 channel 更可靠；</li>
  <li>对热点路径保持函数边界：协作式抢占仍依赖安全点，过度内联与紧密循环要谨慎；</li>
  <li>善用 <code class="language-plaintext highlighter-rouge">pprof/trace</code>：在压测环境下先度量再优化，避免拍脑袋调参。</li>
</ul>

<h2 id="十二常见问答">十二、常见问答</h2>

<ul>
  <li>为什么不是 1:1？线程创建/栈成本与上下文切换太高，难以支撑数十万并发；</li>
  <li>为什么不是 N:1？无法用多核并行，一次 syscall 可能阻塞整个进程；</li>
  <li>P 的存在感是什么？减少全局争用、提升局部性，并成为并发度的“配额器”；</li>
  <li>抢占是否 100% 及时？不是。异步抢占已大幅改善，但仍依赖安全点；</li>
  <li>goroutine 真的“无限便宜”吗？不是。内存、调度、GC 都付成本；设计时要有边界与限流。</li>
</ul>

<h2 id="十三小结">十三、小结</h2>

<p>GMP 模型是 Go“以工程为中心”的体现：</p>
<ul>
  <li>以 goroutine/channel 的直观抽象降低并发编程的心智负担；</li>
  <li>以用户态调度与 P 的本地队列/work stealing 实现高伸缩；</li>
  <li>以 netpoller 与异步抢占保证 I/O 与计算的双向友好；</li>
  <li>以完善的可观测性工具支撑“先度量再优化”的最佳实践。</li>
</ul>

<p>它并不完美，但在“简单可用”与“高性能可伸缩”之间给出了极佳的工程折中。这也是 Go 在云原生时代持续流行的底层原因之一。</p>

<hr />

<p>附：命令速查</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 调度打印（每秒一次）</span>
<span class="nv">GODEBUG</span><span class="o">=</span><span class="nv">schedtrace</span><span class="o">=</span>1000,scheddetail<span class="o">=</span>1 ./app

<span class="c"># 运行时剖析（HTTP pprof）</span>
go run main.go &amp;
go tool pprof <span class="nt">-http</span><span class="o">=</span>:0 http://localhost:6060/debug/pprof/profile

<span class="c"># 时间轴跟踪</span>
go <span class="nb">test</span> <span class="nt">-run</span><span class="o">=</span>NONE <span class="nt">-bench</span><span class="o">=</span>BenchmarkX <span class="nt">-trace</span> trace.out ./...
go tool trace trace.out
</code></pre></div></div>

    </div>
  </div>

  
  
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
    
    
    
    
  
    
    
    
      
        
    
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
    
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
      
        
      
    
    
    
  
    
    
    
      
        
    
    
    
    
  
    
    
    
      
        
    
    
    
    
  
  <section class="related-posts">
    <h2>相关阅读</h2>
    <ul>
      
        <li><a href="/%E6%8A%80%E6%9C%AF/nginx/2025/07/01/Nginx-Ingress-%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5.html">Nginx Ingress 高并发场景优化实践</a> <small>(2025-07-01)</small></li>
      
        <li><a href="/%E6%8A%80%E6%9C%AF/nginx/2025/06/28/Nginx-%E9%9B%B6%E5%81%9C%E6%9C%BA%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E4%B8%8E%E5%9B%9E%E6%BB%9A%E7%AD%96%E7%95%A5.html">Nginx 零停机灰度发布与回滚策略</a> <small>(2025-06-28)</small></li>
      
        <li><a href="/%E6%8A%80%E6%9C%AF/nginx/2023/12/05/Nginx-Ingress-%E5%9C%A8Kubernetes%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E9%85%8D%E7%BD%AE.html">Nginx Ingress 在 Kubernetes 的高可用配置</a> <small>(2023-12-05)</small></li>
      
        <li><a href="/%E6%8A%80%E6%9C%AF/mysql/2023/02/27/MySQL-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E4%BB%8E-explain-%E5%88%B0%E7%81%AB%E7%84%B0%E5%9B%BE.html">MySQL-慢查询优化-从-explain-到火焰图</a> <small>(2023-02-27)</small></li>
      
        <li><a href="/%E6%8A%80%E6%9C%AF/golang/2022/10/07/Go-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-Channel%E4%B8%8EContext%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html">Go 并发模型：Channel 与 Context 最佳实践</a> <small>(2022-10-07)</small></li>
      
    </ul>
  </section>
  

  <footer class="post-footer">
    <div class="share">
      <a href="https://twitter.com/intent/tweet?text=Go%20goroutine%20%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%EF%BC%9AGMP&url=http://localhost:4000/%E6%8A%80%E6%9C%AF/golang/2015/11/02/Go-goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86GMP.html" target="_blank">Share to X</a>
      <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/%E6%8A%80%E6%9C%AF/golang/2015/11/02/Go-goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86GMP.html" target="_blank" style="margin-left:12px;">Share to Facebook</a>
    </div>

    
    <section id="comments" style="margin-top: 24px;">
      <script src="https://giscus.app/client.js"
        data-repo=""
        data-repo-id=""
        data-category="General"
        data-category-id=""
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="light"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
      </script>
    </section>
    
  </footer>
</article>

<button id="back-to-top" title="回到顶部">↑</button>

<script>
// 构建目录
(function(){
  const content = document.getElementById('post-content');
  const toc = document.getElementById('toc');
  if (!content || !toc) return;
  const headings = content.querySelectorAll('h1, h2, h3');
  if (!headings.length) return;
  const ul = document.createElement('ul');
  headings.forEach(h => {
    if (!h.id) h.id = h.textContent.trim().toLowerCase().replace(/\s+/g, '-');
    const li = document.createElement('li');
    li.style.marginLeft = ({H1:0,H2:12,H3:24})[h.tagName] + 'px';
    const a = document.createElement('a');
    a.href = '#' + h.id;
    a.textContent = h.textContent;
    li.appendChild(a);
    ul.appendChild(li);
  });
  const title = document.createElement('div');
  title.textContent = '目录';
  title.style.fontWeight = 'bold';
  title.style.marginBottom = '8px';
  toc.appendChild(title);
  toc.appendChild(ul);
})();

// 代码复制按钮
(function(){
  document.querySelectorAll('pre > code').forEach(code => {
    const pre = code.parentElement;
    const btn = document.createElement('button');
    btn.textContent = '复制';
    btn.className = 'copy-btn';
    btn.onclick = async () => {
      try { await navigator.clipboard.writeText(code.innerText); btn.textContent = '已复制'; setTimeout(()=>btn.textContent='复制',1000);} catch(e) {}
    };
    pre.style.position = 'relative';
    btn.style.position = 'absolute';
    btn.style.right = '8px';
    btn.style.top = '8px';
    pre.appendChild(btn);
  });
})();

// 回到顶部
(function(){
  const btn = document.getElementById('back-to-top');
  const onscroll = () => { btn.style.display = window.scrollY > 300 ? 'block' : 'none'; };
  window.addEventListener('scroll', onscroll); onscroll();
  btn.onclick = () => window.scrollTo({top:0, behavior:'smooth'});
})();

// 图片懒加载
(function(){
  document.querySelectorAll('#post-content img').forEach(img => {
    img.loading = 'lazy';
    if (!img.hasAttribute('alt') || img.getAttribute('alt') === '') {
      try {
        const u = new URL(img.src, window.location.origin);
        const name = (u.pathname.split('/').pop() || '').split('.')[0];
        if (name) img.setAttribute('alt', decodeURIComponent(name));
      } catch (e) {}
    }
  });
})();
</script>

<style>
.post-body{display:flex; gap:24px}
#toc{min-width:200px; max-width:240px; position:sticky; top:80px; height:max-content}
#post-content{flex:1}
#back-to-top{position:fixed; right:16px; bottom:24px; display:none; padding:8px 10px}
.copy-btn{font-size:12px; padding:2px 6px}
@media (max-width: 900px){ .post-body{flex-direction:column;} #toc{position:static;}}
</style><script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go goroutine 调度器原理：GMP",
  "description": "系统拆解 Go 的 G-M-P 三元模型、work stealing、抢占与 netpoller 协作机制，配合实验/可观测手段理解调度器的性能与权衡。",
  "datePublished": "2015-11-02T00:00:00+08:00",
  "dateModified": "2025-08-09T19:09:21+08:00",
  "author": {
    "@type": "Person",
    "name": "TayloyChen"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:4000/%E6%8A%80%E6%9C%AF/golang/2015/11/02/Go-goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86GMP.html"
  },
  "url": "http://localhost:4000/%E6%8A%80%E6%9C%AF/golang/2015/11/02/Go-goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86GMP.html"
}
</script>



      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">TayloyChen Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">{&quot;name&quot; =&gt; &quot;TayloyChen&quot;, &quot;url&quot; =&gt; &quot;https://taylorchen.github.io&quot;}</li><li><a class="u-email" href="mailto:cherrycmd@gmail.com">cherrycmd@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/taylorchen"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">taylorchen</span></a></li><li><a href="https://www.twitter.com/shlchen"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">shlchen</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>这里是 TayloyChen 的个人博客，与你一起发现更大的世界 | 要做一个有 ikigai 的程序员</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
