<!DOCTYPE html>
<html lang="zh-CN"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Go goroutine 调度器原理：GMP | TayloyChen Blog</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Go goroutine 调度器原理：GMP" />
<meta name="author" content="TayloyChen" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="系统拆解 Go 的 G-M-P 三元模型、work stealing、抢占与 netpoller 协作机制，配合实验/可观测手段理解调度器的性能与权衡。" />
<meta property="og:description" content="系统拆解 Go 的 G-M-P 三元模型、work stealing、抢占与 netpoller 协作机制，配合实验/可观测手段理解调度器的性能与权衡。" />
<link rel="canonical" href="http://localhost:4000/%E6%8A%80%E6%9C%AF/golang/2015/11/02/Go-goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86GMP.html" />
<meta property="og:url" content="http://localhost:4000/%E6%8A%80%E6%9C%AF/golang/2015/11/02/Go-goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86GMP.html" />
<meta property="og:site_name" content="TayloyChen Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-11-02T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Go goroutine 调度器原理：GMP" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"TayloyChen","url":"https://taylorchen.github.io"},"dateModified":"2025-08-10T00:22:34+08:00","datePublished":"2015-11-02T00:00:00+08:00","description":"系统拆解 Go 的 G-M-P 三元模型、work stealing、抢占与 netpoller 协作机制，配合实验/可观测手段理解调度器的性能与权衡。","headline":"Go goroutine 调度器原理：GMP","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/%E6%8A%80%E6%9C%AF/golang/2015/11/02/Go-goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86GMP.html"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/images/favicons/favicon-96x96.png"},"name":"TayloyChen"},"url":"http://localhost:4000/%E6%8A%80%E6%9C%AF/golang/2015/11/02/Go-goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86GMP.html"}</script>
<!-- End Jekyll SEO tag -->

  
  
    <meta property="article:modified_time" content="2025-08-10T00:22:34+08:00">
  
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="alternate" type="application/atom+xml" href="http://localhost:4000/feed.xml" title="TayloyChen Blog" />
  <link rel="icon" href="/assets/images/favicons/favicon.ico" type="image/x-icon">
  
  
    <meta property="og:image" content="http://localhost:4000/assets/images/2e9ea54a25bedd353d5e06c076d9c7e4.jpeg">
    <meta name="twitter:image" content="http://localhost:4000/assets/images/2e9ea54a25bedd353d5e06c076d9c7e4.jpeg">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&family=Noto+Serif+SC:wght@400;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet"><link rel="stylesheet" href="/assets/css/custom.css"><script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebSite",
    "name": "TayloyChen Blog",
    "url": "http://localhost:4000",
    "potentialAction": {
      "@type": "SearchAction",
      "target": "http://localhost:4000/search/?q={query}",
      "query-input": "required name=query"
    }
  }
  </script>
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Person",
    "name": "TayloyChen",
    "url": "https://taylorchen.github.io",
    "sameAs": ["https://github.com/taylorchen","https://twitter.com/shlchen"]
  }
  </script><script src="/assets/js/theme.js" defer></script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/">TayloyChen Blog</a>
    <nav class="site-nav">
      <a class="page-link" href="/">首页</a>
      <a class="page-link" href="/categories/">分类</a>
      <a class="page-link" href="/tags/">标签</a>
      <a class="page-link" href="/archives/">归档</a>
      <a class="page-link" href="/search/">搜索</a>
      <a class="page-link" href="/feed.xml" rel="alternate" type="application/atom+xml">订阅</a>
      <a class="page-link" href="/about/">关于</a>
    </nav>
  </div>
</header>

<style>
  .site-header {
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-card);
    backdrop-filter: blur(10px);
    position: sticky;
    top: 0;
    z-index: 100;
    box-shadow: var(--shadow-sm);
    transition: all var(--transition-base);
  }

  .site-header .wrapper {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-top: 1rem;
    padding-bottom: 1rem;
  }

  .site-title {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--text-primary);
    letter-spacing: -0.5px;
    transition: color var(--transition-fast);
    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .site-title:hover {
    opacity: 0.8;
  }

  .site-nav {
    display: flex;
    gap: 0.25rem;
    align-items: center;
  }

  .page-link {
    padding: 0.5rem 1rem;
    color: var(--text-secondary);
    font-weight: 500;
    font-size: 0.9375rem;
    border-radius: var(--radius-md);
    transition: all var(--transition-fast);
    position: relative;
  }

  .page-link:hover {
    color: var(--primary-color);
    background: var(--bg-code);
  }

  .page-link::after {
    content: '';
    position: absolute;
    bottom: 4px;
    left: 50%;
    transform: translateX(-50%) scaleX(0);
    width: 70%;
    height: 2px;
    background: var(--primary-color);
    transition: transform var(--transition-base);
    border-radius: 2px;
  }

  .page-link:hover::after {
    transform: translateX(-50%) scaleX(1);
  }

  /* 响应式菜单 */
  @media (max-width: 768px) {
    .site-header .wrapper {
      flex-direction: column;
      gap: 1rem;
      align-items: flex-start;
    }

    .site-nav {
      width: 100%;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .page-link {
      padding: 0.4rem 0.75rem;
      font-size: 0.875rem;
    }
  }
</style><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">
  <header>
    <h1>Go goroutine 调度器原理：GMP</h1>
    <p class="post-meta">
      <time datetime="2015-11-02T00:00:00+08:00">2015-11-02</time>
       · 最后更新于 <time datetime="2025-08-10T00:22:34+08:00">2025-08-10</time>
       · 技术 / Golang
       · 技术, Golang, GMP, 调度器, 并发
    </p>
    <nav class="breadcrumbs" aria-label="Breadcrumb">
      <a href="/">首页</a>
      
      
      &nbsp;/&nbsp;<a href="/categories/">技术</a>
      
      &nbsp;/&nbsp;<a href="/categories/">Golang</a>
      
      
      &nbsp;/&nbsp;<span aria-current="page">Go goroutine 调度器原理：GMP</span>
    </nav>
    
    <meta name="description" content="系统拆解 Go 的 G-M-P 三元模型、work stealing、抢占与 netpoller 协作机制，配合实验/可观测手段理解调度器的性能与权衡。">
    
    
    <meta name="keywords" content="技术, Golang, GMP, 调度器, 并发">
    
  </header>

  <div class="post-body" id="post-body">
    <aside id="toc"></aside>
    <div id="post-content">
      <p>这篇文章不只是“是什么”，而是从语言设计动机与系统实现细节出发，系统性拆解 Go 调度器的三元模型：G（goroutine）、M（OS thread）、P（processor）。围绕“为什么要引入 GMP”“GMP 解决了什么问题”“有哪些代价与权衡”“如何直观理解并用实验证明”，我们给出多维度、可操作的深度解读。</p>

<h2 id="一动机go-想解决什么问题">一、动机：Go 想解决什么问题？</h2>

<p>如果回到 2007–2009 年 Go 诞生的背景，Google 内部已经在大规模分布式系统中挣扎：</p>
<ul>
  <li>需要写高并发服务，却要在复杂的回调、线程与锁之间艰难取舍；</li>
  <li>线程创建与上下文切换成本高，每个线程动辄 MB 级别栈内存；</li>
  <li>I/O 与 CPU 混合型负载让“要么阻塞、要么回调”的模型两头不讨好；</li>
  <li>C/C++ 缺少一等公民的并发原语，异步代码可读性差而且脆弱。</li>
</ul>

<p>Go 的答案可以浓缩为三点：</p>
<ul>
  <li>基于 CSP 的并发观：以 goroutine 与 channel 为一等公民，用“看起来可阻塞”的直观代码描述并发；</li>
  <li>用户态调度器：把大量 goroutine 以 M:N 方式复用到少量 OS 线程上，降低成本并提升可伸缩性；</li>
  <li>面向工程实战：自动栈增长、抢占、网络 poller、分配器与 GC 协同，提供“默认高效、按需可调”的体验。</li>
</ul>

<p>GMP 模型正是在这样的目标约束下诞生：既要“写起来像同步”，又要“跑起来像高性能异步”，还要“在多核机器上自然扩展”。</p>

<h2 id="二设计思想从-11-到-mn再到-p-的引入">二、设计思想：从 1:1 到 M:N，再到 P 的引入</h2>

<p>线程模型的历史谱系大致有三类：</p>
<ul>
  <li>1:1（每个用户线程映射一个 OS 线程）：实现简单，但创建/销毁、上下文切换和栈内存都昂贵；</li>
  <li>N:1（绿色线程，全在用户态）：切换快，但无法利用多核，遇到系统调用就会整体阻塞；</li>
  <li>M:N（用户态与内核态混合）：折中路线，但实现复杂，边界条件众多。</li>
</ul>

<p>Go 选择 M:N，但早期只存在 G 和 M，很快遭遇扩展性与缓存局部性问题：多个 M 抢同一把全局锁从全局 run queue 取任务，导致抖动。Go 1.1 引入 P（processor）作为“执行 goroutine 的逻辑 CPU 配额与本地 run queue”，解决两个核心痛点：</p>
<ul>
  <li>把就绪 G 分散到 P 的本地队列，提升缓存命中并减少锁竞争；</li>
  <li>通过 work stealing 在 P 之间均衡负载，避免个别 P 饥饿。</li>
</ul>

<p>因此，GMP 的真实目标不是“多一个字母”，而是让“可伸缩的用户态调度”成为现实。</p>

<h2 id="三模型总览gmp-分工与数量关系">三、模型总览：G、M、P 分工与数量关系</h2>

<ul>
  <li>G（goroutine）：用户态轻量执行单元，拥有栈（可动态增长）、状态（就绪/运行/阻塞/等待）与入口函数。</li>
  <li>M（machine/OS thread）：真实的内核线程，负责执行 G 的载体。M 必须绑定一个 P 才能运行 Go 代码；无 P 的 M 只能执行 syscalls 或处于空闲。</li>
  <li>P（processor）：调度器中的“核”和本地运行队列，数量等于 <code class="language-plaintext highlighter-rouge">GOMAXPROCS</code>。每个 P 维护 run queue、runnext 插槽、定时器等。</li>
</ul>

<p>典型约束：</p>
<ul>
  <li>同一时刻最多有 <code class="language-plaintext highlighter-rouge">GOMAXPROCS</code> 个 M 持有 P 并并行执行 Go 代码；</li>
  <li>G 的创建很廉价，调度器倾向把新 G 放入当前 P 的 run queue；</li>
  <li>无事可做的 P 会从全局队列或其他 P 窃取 G（work stealing）。</li>
</ul>

<h2 id="四调度循环一条-g-的旅程">四、调度循环：一条 G 的旅程</h2>

<p>1) 创建/就绪：<code class="language-plaintext highlighter-rouge">go f()</code> 创建 G，优先放进当前 P 的本地队列；
2) 取出与执行：持有该 P 的 M 从 run queue 取 G，放到寄存器与栈上开始执行；
3) 阻塞分流：</p>
<ul>
  <li>如果 G 调用 <code class="language-plaintext highlighter-rouge">syscall</code>/<code class="language-plaintext highlighter-rouge">cgo</code> 进入内核阻塞，M 也会阻塞；调度器把“被困”的 P 转借给其他空闲的 M，以保证 <code class="language-plaintext highlighter-rouge">GOMAXPROCS</code> 并行度；</li>
  <li>如果 G 因 channel/锁/I/O 等用户态阻塞，M 让出当前 G，切回调度器，从本地队列或其他 P 继续取活；</li>
  <li>网络 I/O 由 netpoller（epoll/kqueue/IOCP）负责等待并唤醒相关 G；
4) 抢占与让出：</li>
  <li>协作式：函数 prologue 设置安全点，允许在调用边界被切走；</li>
  <li>异步抢占（Go 1.14 起）：runtime 可向线程注入信号，在抢占安全点强制把 G 让出，避免大计算长期独占；
5) 完成与回收：G 正常返回或 panic 结束后，M 继续从队列取下一个 G。</li>
</ul>

<h2 id="五关键机制详解">五、关键机制详解</h2>

<h3 id="51-本地队列全局队列与-runnext">5.1 本地队列、全局队列与 runnext</h3>
<ul>
  <li>本地队列：每个 P 维护一个环形队列，push/pop 均无锁或轻锁；</li>
  <li>全局队列：系统级备用队列，多个 P 在饥饿时会从中批量拉取；</li>
  <li>runnext：为提升缓存命中，调度器保留“下一个立刻运行”的插槽（如 <code class="language-plaintext highlighter-rouge">go ready</code> 刚唤醒的 G）。</li>
</ul>

<h3 id="52-work-stealing">5.2 Work Stealing</h3>
<p>当某个 P 的队列耗尽，会从全局队列或随机挑选另一个 P 窃取一半任务（按块移动），在保持均衡的同时减少锁冲突。该策略在大规模 goroutine 场景下显著降低尾延迟。</p>

<h3 id="53-系统调用与-mp-解耦">5.3 系统调用与 M/P 解耦</h3>
<p>对于可能长时间阻塞的内核调用：</p>
<ul>
  <li>进入 syscall 前记录状态；</li>
  <li>M 进入内核后若长时间不返回，调度器将其 P 迁出给其他可运行的 M；</li>
  <li>当 syscall 返回，若原 P 已被转移，则尝试从全局获取 P 或把 G 放回队列等待调度。</li>
</ul>

<h3 id="54-netpoller">5.4 Netpoller</h3>
<p>Go 的网络库用平台相关的 poller 将“看似阻塞的 Read/Write”转为“注册事件 + 等待唤醒”。当事件就绪，poller 把对应 G 标记为 runnable，放回某个 P 的队列。这是“看似同步、实则异步”的关键一环。</p>

<h3 id="55-抢占从协作到异步">5.5 抢占：从协作到异步</h3>
<p>早期 Go 主要依赖协作式抢占，即在函数调用边界（safe point）让出。对于紧密循环或内联后的长计算，可能长时间不让出，导致延迟抖动。Go 1.14 引入异步抢占：</p>
<ul>
  <li>runtime 向执行线程注入抢占信号；</li>
  <li>在线程到达可抢占的安全点（如栈检查、轮询点）时挂起 G，切回调度器；</li>
  <li>减少“计算型 goroutine”对系统的拖滞，提升吞吐与 P99 延迟。</li>
</ul>

<h3 id="56-栈管理">5.6 栈管理</h3>
<p>goroutine 使用“连续可增长栈”，初始很小（KB 级），随着深度增长按需扩容（拷贝并修正栈指针）。这使得创建百万 goroutine 成为可能，也与调度器的轻量切换协同增效。</p>

<h3 id="57-与-gc-的协作">5.7 与 GC 的协作</h3>
<p>调度器与 GC 紧密耦合：</p>
<ul>
  <li>标记辅助（mutator assist）在分配压力大时让运行的 G 协助标记；</li>
  <li>写屏障保证并发标记期正确性；</li>
  <li>STW 窗口尽量缩小，但仍需要在世界停止时统一栈扫描与根收集；</li>
  <li>抢占点也服务于 GC 对“尽快看到所有栈”的诉求。</li>
</ul>

<h3 id="58-系统监控线程sysmon">5.8 系统监控线程（sysmon）</h3>
<p>后台监控 goroutine/线程状态、定时器、抢占信号、垃圾回收触发等，是调度系统“保安 + 协调员”。</p>

<h2 id="六gmp-解决了哪些实际问题">六、GMP 解决了哪些实际问题？</h2>

<ul>
  <li>低成本并发原语：创建/销毁 goroutine 成本远低于线程，栈按需增长；</li>
  <li>多核可伸缩：<code class="language-plaintext highlighter-rouge">GOMAXPROCS</code> 决定并发执行 goroutine 的上限，通过 P 的本地队列与 stealing 在多核扩展；</li>
  <li>同步代码风格的高性能 I/O：netpoller 让“看起来阻塞”的 API 拥有“异步性能”；</li>
  <li>更好地处理混合负载：系统调用阻塞与用户态阻塞分流，保持整体吞吐；</li>
  <li>可观测性与可调优：<code class="language-plaintext highlighter-rouge">pprof</code>、<code class="language-plaintext highlighter-rouge">trace</code>、<code class="language-plaintext highlighter-rouge">schedtrace</code> 等工具帮助定位性能瓶颈与调度异常。</li>
</ul>

<h2 id="七权衡与潜在弊端">七、权衡与潜在弊端</h2>

<ul>
  <li>实现复杂度高：调度器、GC、分配器、netpoller 的耦合提升了 runtime 复杂性与维护难度；</li>
  <li>尾延迟与公平性：尽管有抢占与 stealing，极端负载下仍可能出现饥饿或抖动；</li>
  <li><code class="language-plaintext highlighter-rouge">syscall</code>/<code class="language-plaintext highlighter-rouge">cgo</code> 交互成本：频繁进入内核或调用 C 代码，会触发 P 迁移/线程增减，影响稳定性与预测性；</li>
  <li>G 泄漏更隐蔽：看似阻塞的 goroutine 更容易“被遗忘”，如未消费的 <code class="language-plaintext highlighter-rouge">time.After</code>、无界 channel；</li>
  <li>调参误区：盲目调大 <code class="language-plaintext highlighter-rouge">GOMAXPROCS</code> 可能加剧锁竞争与切换开销，未必提升吞吐；</li>
  <li>平台细节差异：netpoller 依赖 epoll/kqueue/IOCP，不同平台边界行为可能不同。</li>
</ul>

<h2 id="八如何直观理解一个工厂的类比">八、如何直观理解：一个工厂的类比</h2>

<p>把 P 想象成“装配线”，M 是“工人”，G 是“待加工的零件”：</p>
<ul>
  <li>每条装配线（P）有自己的待加工队列（本地 run queue），减少不同线之间的争抢；</li>
  <li>工人（M）必须绑定一条装配线才能干活；</li>
  <li>如果某条线不饱和，工人会去别的线“偷”一半零件回来（work stealing）；</li>
  <li>遇到需要外部检验（syscall）时，工人要暂时离开车间，但这条线会很快分配给另一名工人，保证机器不停；</li>
  <li>车间主任（sysmon）偶尔会打断某个工人，防止他在一个零件上磨蹭太久（异步抢占）。</li>
</ul>

<p>一个近似的 ASCII 示意：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P0(runq) ←→ M0  执行 G...
P1(runq) ←→ M1  执行 G...
P2(runq) ←→ M2  执行 G...
       ↖ stealing ↗
   全局队列 / netpoller 唤醒
</code></pre></div></div>

<h2 id="九实验观察-gomaxprocs-与调度行为">九、实验：观察 <code class="language-plaintext highlighter-rouge">GOMAXPROCS</code> 与调度行为</h2>

<p>下面的程序用递归 <code class="language-plaintext highlighter-rouge">fib</code> 制造 CPU 压力，观察不同 <code class="language-plaintext highlighter-rouge">GOMAXPROCS</code> 的吞吐变化（实际结果取决于机器核数与调度器负载）。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>
<span class="k">import</span> <span class="p">(</span>
  <span class="s">"runtime"</span>
  <span class="s">"sync"</span>
  <span class="s">"time"</span>
  <span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="m">2</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span> <span class="p">};</span> <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="m">1</span><span class="p">)</span><span class="o">+</span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="m">2</span><span class="p">)</span> <span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">8</span><span class="p">}</span> <span class="p">{</span>
    <span class="n">runtime</span><span class="o">.</span><span class="n">GOMAXPROCS</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
    <span class="n">start</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">100000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
      <span class="k">go</span> <span class="k">func</span><span class="p">(){</span> <span class="n">_</span> <span class="o">=</span> <span class="n">fib</span><span class="p">(</span><span class="m">20</span><span class="p">);</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span> <span class="p">}()</span>
    <span class="p">}</span>
    <span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"P="</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="s">"cost="</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">Since</span><span class="p">(</span><span class="n">start</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>观察调度轨迹：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">GODEBUG</span><span class="o">=</span><span class="nv">schedtrace</span><span class="o">=</span>1000,scheddetail<span class="o">=</span>1 ./app
<span class="c"># 也可打开 pprof：</span>
<span class="c"># go tool pprof -http=:0 http://localhost:6060/debug/pprof/profile</span>
</code></pre></div></div>

<p>示例：对“长计算不让出”的可观测性（Go 1.14 前后对比思路）：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 紧密循环若无函数调用，旧版本更难被协作式抢占，</span>
<span class="c">// 新版的异步抢占可显著改善系统整体延迟。</span>
<span class="k">func</span> <span class="n">busyLoop</span><span class="p">(</span><span class="n">deadline</span> <span class="n">time</span><span class="o">.</span><span class="n">Time</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">Before</span><span class="p">(</span><span class="n">deadline</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// 做一些计算</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="十可观测性tracepprofschedtrace-看什么">十、可观测性：trace/pprof/schedtrace 看什么</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">schedtrace</code>：周期打印 P/M/G 的数量、全局/本地队列长度、spinning 线程数，快速判断是否存在饥饿或过度抢占；</li>
  <li><code class="language-plaintext highlighter-rouge">pprof</code>：
    <ul>
      <li>CPU profile 看热点函数与调度器开销；</li>
      <li>Block profile 观察 channel/互斥等待；</li>
      <li>Mutex profile 关注 runtime 锁与业务锁竞争；</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">go tool trace</code>：时间轴上展示 G 的生命周期变化、网络事件与 syscalls，更直观地定位抖动来源。</li>
</ul>

<h2 id="十一实战建议与反模式">十一、实战建议与反模式</h2>

<ul>
  <li>合理设置 <code class="language-plaintext highlighter-rouge">GOMAXPROCS</code>：通常默认即可。CPU 密集场景接近物理核心数；过大只会带来锁竞争与切换成本；</li>
  <li>避免无界 goroutine：对输入做限流，用 worker pool 或 <code class="language-plaintext highlighter-rouge">errgroup</code>；</li>
  <li>小心 <code class="language-plaintext highlighter-rouge">time.After</code> 泄漏：未读取的计时器会保留 G；可改用 <code class="language-plaintext highlighter-rouge">time.NewTimer</code> 并 <code class="language-plaintext highlighter-rouge">Stop</code>；</li>
  <li>处理 <code class="language-plaintext highlighter-rouge">syscall/cgo</code>：尽量缩短阻塞时间，必要时隔离到专用池或进程；</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">context</code> 超时/取消：避免永久阻塞 goroutine；</li>
  <li>明确选择 <code class="language-plaintext highlighter-rouge">channel</code> 与 <code class="language-plaintext highlighter-rouge">mutex</code>：小临界区用锁更直白，复杂编排用 channel 更可靠；</li>
  <li>对热点路径保持函数边界：协作式抢占仍依赖安全点，过度内联与紧密循环要谨慎；</li>
  <li>善用 <code class="language-plaintext highlighter-rouge">pprof/trace</code>：在压测环境下先度量再优化，避免拍脑袋调参。</li>
</ul>

<h2 id="十二常见问答">十二、常见问答</h2>

<ul>
  <li>为什么不是 1:1？线程创建/栈成本与上下文切换太高，难以支撑数十万并发；</li>
  <li>为什么不是 N:1？无法用多核并行，一次 syscall 可能阻塞整个进程；</li>
  <li>P 的存在感是什么？减少全局争用、提升局部性，并成为并发度的“配额器”；</li>
  <li>抢占是否 100% 及时？不是。异步抢占已大幅改善，但仍依赖安全点；</li>
  <li>goroutine 真的“无限便宜”吗？不是。内存、调度、GC 都付成本；设计时要有边界与限流。</li>
</ul>

<h2 id="十三小结">十三、小结</h2>

<p>GMP 模型是 Go“以工程为中心”的体现：</p>
<ul>
  <li>以 goroutine/channel 的直观抽象降低并发编程的心智负担；</li>
  <li>以用户态调度与 P 的本地队列/work stealing 实现高伸缩；</li>
  <li>以 netpoller 与异步抢占保证 I/O 与计算的双向友好；</li>
  <li>以完善的可观测性工具支撑“先度量再优化”的最佳实践。</li>
</ul>

<p>它并不完美，但在“简单可用”与“高性能可伸缩”之间给出了极佳的工程折中。这也是 Go 在云原生时代持续流行的底层原因之一。</p>

<hr />

<p>附：命令速查</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 调度打印（每秒一次）</span>
<span class="nv">GODEBUG</span><span class="o">=</span><span class="nv">schedtrace</span><span class="o">=</span>1000,scheddetail<span class="o">=</span>1 ./app

<span class="c"># 运行时剖析（HTTP pprof）</span>
go run main.go &amp;
go tool pprof <span class="nt">-http</span><span class="o">=</span>:0 http://localhost:6060/debug/pprof/profile

<span class="c"># 时间轴跟踪</span>
go <span class="nb">test</span> <span class="nt">-run</span><span class="o">=</span>NONE <span class="nt">-bench</span><span class="o">=</span>BenchmarkX <span class="nt">-trace</span> trace.out ./...
go tool trace trace.out
</code></pre></div></div>
 </div>
    </div>

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <section class="related-posts">
      <h2>相关阅读</h2>
      <ul>
        
        <li><a href="/%E6%8A%80%E6%9C%AF/nginx/2025/07/01/Nginx-Ingress-%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5.html">Nginx Ingress 高并发场景优化实践</a> <small>(2025-07-01)</small></li>
        
        <li><a href="/%E6%8A%80%E6%9C%AF/nginx/2025/06/28/Nginx-%E9%9B%B6%E5%81%9C%E6%9C%BA%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E4%B8%8E%E5%9B%9E%E6%BB%9A%E7%AD%96%E7%95%A5.html">Nginx 零停机灰度发布与回滚策略</a> <small>(2025-06-28)</small></li>
        
        <li><a href="/%E6%8A%80%E6%9C%AF/nginx/2023/12/05/Nginx-Ingress-%E5%9C%A8Kubernetes%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E9%85%8D%E7%BD%AE.html">Nginx Ingress 在 Kubernetes 的高可用配置</a> <small>(2023-12-05)</small></li>
        
        <li><a href="/%E6%8A%80%E6%9C%AF/mysql/2023/02/27/MySQL-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E4%BB%8E-explain-%E5%88%B0%E7%81%AB%E7%84%B0%E5%9B%BE.html">MySQL-慢查询优化-从-explain-到火焰图</a> <small>(2023-02-27)</small></li>
        
        <li><a href="/%E6%8A%80%E6%9C%AF/golang/2022/10/07/Go-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-Channel%E4%B8%8EContext%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html">Go 并发模型：Channel 与 Context 最佳实践</a> <small>(2022-10-07)</small></li>
        
      </ul>
    </section>
    

    <footer class="post-footer">
      <nav class="post-pager" aria-label="Post Navigation">
        
        <a class="prev" href="/%E6%8A%80%E6%9C%AF/java/2015/09/08/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8F%AF%E8%A7%81%E6%80%A7%E5%AE%9E%E8%B7%B5.html" rel="prev">← 上一篇：Java 内存模型与可见性实践</a>
        
        
        <a class="next" href="/%E6%8A%80%E6%9C%AF/mysql/2016/04/12/MySQL-%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%83%AD%E7%82%B9%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8FID%E5%AE%9E%E8%B7%B5.html" rel="next">下一篇：MySQL 自增主键热点与分布式 ID 实践 →</a>
        
      </nav>
      <div class="share">
        <a href="https://twitter.com/intent/tweet?text=Go%20goroutine%20%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%EF%BC%9AGMP&url=http://localhost:4000/%E6%8A%80%E6%9C%AF/golang/2015/11/02/Go-goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86GMP.html"
          target="_blank" rel="noopener">Share to X</a>
        <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/%E6%8A%80%E6%9C%AF/golang/2015/11/02/Go-goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86GMP.html"
          target="_blank" rel="noopener" style="margin-left:12px;">Share to Facebook</a>
        <a href="https://www.linkedin.com/sharing/share-offsite/?url=http://localhost:4000/%E6%8A%80%E6%9C%AF/golang/2015/11/02/Go-goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86GMP.html"
          target="_blank" rel="noopener" style="margin-left:12px;">Share to LinkedIn</a>
      </div>

      
      <section id="comments" style="margin-top: 24px;">
        <script src="https://giscus.app/client.js" data-repo=""
          data-repo-id="" data-category="General"
          data-category-id="" data-mapping="pathname" data-strict="0"
          data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom"
          data-theme="light" data-lang="zh-CN" crossorigin="anonymous" async>
          </script>
      </section>
      
    </footer>
</article>

<button id="back-to-top" title="回到顶部">↑</button>

<script>
  // 构建目录
  (function () {
    const content = document.getElementById('post-content');
    const toc = document.getElementById('toc');
    if (!content || !toc) return;
    const headings = content.querySelectorAll('h1, h2, h3');
    if (!headings.length) return;
    const ul = document.createElement('ul');
    headings.forEach(h => {
      if (!h.id) h.id = h.textContent.trim().toLowerCase().replace(/\s+/g, '-');
      const li = document.createElement('li');
      li.style.marginLeft = ({ H1: 0, H2: 12, H3: 24 })[h.tagName] + 'px';
      const a = document.createElement('a');
      a.href = '#' + h.id;
      a.textContent = h.textContent;
      li.appendChild(a);
      ul.appendChild(li);
    });
    const title = document.createElement('div');
    title.textContent = '目录';
    title.style.fontWeight = 'bold';
    title.style.marginBottom = '8px';
    toc.appendChild(title);
    toc.appendChild(ul);
  })();

  // 代码复制按钮
  (function () {
    document.querySelectorAll('pre > code').forEach(code => {
      const pre = code.parentElement;
      const btn = document.createElement('button');
      btn.textContent = '复制';
      btn.className = 'copy-btn';
      btn.onclick = async () => {
        try { await navigator.clipboard.writeText(code.innerText); btn.textContent = '已复制'; setTimeout(() => btn.textContent = '复制', 1000); } catch (e) { }
      };
      pre.style.position = 'relative';
      btn.style.position = 'absolute';
      btn.style.right = '8px';
      btn.style.top = '8px';
      pre.appendChild(btn);
    });
  })();

  // 回到顶部
  (function () {
    const btn = document.getElementById('back-to-top');
    const onscroll = () => { btn.style.display = window.scrollY > 300 ? 'block' : 'none'; };
    window.addEventListener('scroll', onscroll); onscroll();
    btn.onclick = () => window.scrollTo({ top: 0, behavior: 'smooth' });
  })();

  // 图片懒加载与缺失 alt 自动补全
  (function () {
    document.querySelectorAll('#post-content img').forEach(img => {
      img.loading = 'lazy';
      if (!img.hasAttribute('alt') || img.getAttribute('alt') === '') {
        try {
          const u = new URL(img.src, window.location.origin);
          const name = (u.pathname.split('/').pop() || '').split('.')[0];
          if (name) img.setAttribute('alt', decodeURIComponent(name));
        } catch (e) { }
      }
    });
  })();
</script>

<style>
  /* 文章页整体布局 */
  .post-body {
    display: flex;
    gap: 3rem;
    margin-top: 2rem;
  }

  /* 面包屑导航 */
  #post-body .breadcrumbs {
    margin: 1rem 0 1.5rem 0;
    font-size: 0.875rem;
  }

  .breadcrumbs a {
    color: var(--text-secondary);
    transition: color var(--transition-fast);
  }

  .breadcrumbs a:hover {
    color: var(--primary-color);
  }

  /* 目录样式优化 */
  #toc {
    min-width: 220px;
    max-width: 260px;
    position: sticky;
    top: 100px;
    height: max-content;
    max-height: calc(100vh - 120px);
    overflow-y: auto;
    padding: 1.5rem;
    background: var(--bg-card);
    border-radius: var(--radius-lg);
    border: 1px solid var(--border-color);
    box-shadow: var(--shadow-sm);
  }

  #toc>div {
    font-weight: 600;
    font-size: 1rem;
    margin-bottom: 1rem;
    color: var(--text-primary);
    border-bottom: 2px solid var(--primary-color);
    padding-bottom: 0.5rem;
  }

  #toc ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  #toc li {
    margin: 0.5rem 0;
    line-height: 1.5;
  }

  #toc a {
    color: var(--text-secondary);
    font-size: 0.875rem;
    transition: all var(--transition-fast);
    display: block;
    padding: 0.25rem 0;
  }

  #toc a:hover {
    color: var(--primary-color);
    padding-left: 0.5rem;
  }

  /* 文章内容区域优化 */
  #post-content {
    flex: 1;
    min-width: 0;
    font-size: 18px;
    line-height: 1.8;
    color: var(--text-primary);
  }

  #post-content p {
    margin: 1.2rem 0;
  }

  #post-content img {
    max-width: 100%;
    height: auto;
    border-radius: var(--radius-md);
    box-shadow: var(--shadow-md);
    margin: 1.5rem 0;
  }

  #post-content blockquote {
    border-left: 4px solid var(--primary-color);
    padding: 1rem 1.5rem;
    margin: 1.5rem 0;
    background: var(--bg-code);
    border-radius: 0 var(--radius-md) var(--radius-md) 0;
    color: var(--text-secondary);
  }

  #post-content ul,
  #post-content ol {
    padding-left: 2rem;
    margin: 1rem 0;
  }

  #post-content li {
    margin: 0.5rem 0;
  }

  #post-content table {
    width: 100%;
    border-collapse: collapse;
    margin: 1.5rem 0;
    border-radius: var(--radius-md);
    overflow: hidden;
    box-shadow: var(--shadow-sm);
  }

  #post-content th,
  #post-content td {
    padding: 0.75rem 1rem;
    border: 1px solid var(--border-color);
  }

  #post-content th {
    background: var(--bg-code);
    font-weight: 600;
  }

  /* 返回顶部按钮 */
  #back-to-top {
    position: fixed;
    right: 24px;
    bottom: 24px;
    width: 48px;
    height: 48px;
    border-radius: var(--radius-full);
    background: var(--primary-color);
    color: white;
    border: none;
    font-size: 20px;
    cursor: pointer;
    box-shadow: var(--shadow-lg);
    transition: all var(--transition-base);
    z-index: 999;
    display: none;
    align-items: center;
    justify-content: center;
  }

  #back-to-top:hover {
    background: var(--primary-dark);
    transform: translateY(-4px);
  }

  /* 代码复制按钮优化 */
  .copy-btn {
    position: absolute;
    right: 8px;
    top: 8px;
    font-size: 12px;
    padding: 4px 10px;
    background: var(--primary-color);
    color: white;
    border: none;
    border-radius: var(--radius-sm);
    cursor: pointer;
    transition: all var(--transition-fast);
    opacity: 0.9;
  }

  .copy-btn:hover {
    opacity: 1;
    background: var(--primary-dark);
  }

  /* 文章导航 */
  .post-pager {
    display: flex;
    justify-content: space-between;
    gap: 1rem;
    margin: 2rem 0;
    padding-top: 2rem;
    border-top: 1px solid var(--divider-color);
  }

  .post-pager .prev,
  .post-pager .next {
    flex: 1;
    max-width: 48%;
    padding: 1rem 1.5rem;
    background: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: var(--radius-md);
    transition: all var(--transition-base);
    color: var(--text-primary);
  }

  .post-pager .prev:hover,
  .post-pager .next:hover {
    border-color: var(--primary-color);
    box-shadow: var(--shadow-md);
    transform: translateY(-2px);
  }

  /* 相关阅读 */
  .related-posts {
    margin-top: 3rem;
    padding: 1.5rem;
    background: var(--bg-card);
    border-radius: var(--radius-lg);
    border: 1px solid var(--border-color);
  }

  .related-posts h2 {
    margin-top: 0;
    font-size: 1.5rem;
    border-bottom: 2px solid var(--primary-color);
    padding-bottom: 0.75rem;
  }

  .related-posts ul {
    list-style: none;
    padding: 0;
    margin: 1rem 0 0;
  }

  .related-posts li {
    padding: 0.75rem 0;
    border-bottom: 1px solid var(--divider-color);
  }

  .related-posts li:last-child {
    border-bottom: none;
  }

  .related-posts a {
    color: var(--text-primary);
    font-weight: 500;
  }

  .related-posts a:hover {
    color: var(--primary-color);
  }

  .related-posts small {
    color: var(--text-muted);
    font-size: 0.875rem;
  }

  /* 分享按钮 */
  .share {
    display: flex;
    gap: 0.75rem;
    margin-top: 1.5rem;
    flex-wrap: wrap;
  }

  .share a {
    padding: 0.5rem 1rem;
    background: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: var(--radius-md);
    color: var(--text-primary);
    font-size: 0.875rem;
    transition: all var(--transition-base);
  }

  .share a:hover {
    background: var(--primary-color);
    border-color: var(--primary-color);
    color: white;
  }

  /* 响应式设计 */
  @media (max-width: 900px) {
    .post-body {
      flex-direction: column;
      gap: 2rem;
    }

    #toc {
      position: static;
      max-width: 100%;
      max-height: 400px;
    }

    #post-content {
      font-size: 16px;
    }

    .post-pager {
      flex-direction: column;
    }

    .post-pager .prev,
    .post-pager .next {
      max-width: 100%;
    }
  }
</style><script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go goroutine 调度器原理：GMP",
  "description": "系统拆解 Go 的 G-M-P 三元模型、work stealing、抢占与 netpoller 协作机制，配合实验/可观测手段理解调度器的性能与权衡。",
  "datePublished": "2015-11-02T00:00:00+08:00",
  "dateModified": "2025-08-10T00:22:34+08:00",
  "author": {
    "@type": "Person",
    "name": "TayloyChen"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:4000/%E6%8A%80%E6%9C%AF/golang/2015/11/02/Go-goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86GMP.html"
  },
  "url": "http://localhost:4000/%E6%8A%80%E6%9C%AF/golang/2015/11/02/Go-goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86GMP.html"
}
</script><script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {"@type": "ListItem", "position": 1, "name": "首页", "item": "http://localhost:4000/"}
    
      
      
        ,{"@type": "ListItem", "position": 2, "name": "技术", "item": "http://localhost:4000/categories/"}
        
      
        ,{"@type": "ListItem", "position": 3, "name": "Golang", "item": "http://localhost:4000/categories/"}
        
      
    
    ,{"@type": "ListItem", "position": 4, "name": "Go goroutine 调度器原理：GMP", "item": "http://localhost:4000/%E6%8A%80%E6%9C%AF/golang/2015/11/02/Go-goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86GMP.html"}
  ]
}
</script>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">TayloyChen Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name"><a class="u-url" href="https://taylorchen.github.io">TayloyChen</a></li><li><a class="u-email" href="mailto:cherrycmd@gmail.com">cherrycmd@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/taylorchen"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">taylorchen</span></a></li><li><a href="https://www.twitter.com/shlchen"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">shlchen</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>这里是 TayloyChen 的个人博客，与你一起发现更大的世界 | 要做一个有 ikigai 的程序员</p>
      </div>
    </div>

  </div>

</footer>


</body>

</html>
