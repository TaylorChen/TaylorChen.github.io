[

  {
    "url": "/%E5%88%9B%E4%B8%9A/2025/08/24/%E6%9D%8E%E6%83%B3%E9%A6%96%E6%AC%A1%E7%B3%BB%E7%BB%9F%E5%9B%9E%E9%A1%BE25%E5%B9%B4%E5%88%9B%E4%B8%9A%E5%8E%86%E7%A8%8B%E4%B8%8E%E4%BA%A7%E5%93%81%E6%80%9D%E8%80%83.html",
    "title": "李想首次系统回顾25年创业历程与产品思考",
    "content": "李想首次系统回顾25年创业历程与产品思考一、童年成长与环境影响  7个月至7岁由爷爷奶奶在河北乡下抚养，父母考入北京高校无力照顾  爷爷（老爷）的深刻影响：曾任军官，为人正直热心，常为村民解决纠纷，树立榜样  形成正义感与乐观精神：爷爷帮助他人不求回报，晚年时受助者纷纷前来祝寿，让李想相信”做好事会有好结果”  小学三年级返回父母身边，但初期因口音和外来身份遭遇校园欺凌，最终通过反抗解决二、家庭氛围与早期教育  父母均为文艺工作者（毕业于戏曲学院），但李想对文艺兴趣不大  父亲藏书丰富：家中一整间屋子藏书，培养阅读习惯与文字兴趣  父亲开明的教育方式：          主动购买游戏机（FC），约定每天游戏时间并严格执行      支持购买第一台PC（8000元，占家庭存款近半）        母亲的财商教育：按月给零花钱，要求自主管理，初中起通过倒卖漫画书赚取差价三、技术启蒙与创业萌芽  初中接触计算机：在学校机房首次接触中华学习机等设备，产生浓厚兴趣  无电脑时期的自学：通过《大众软件》《电脑报》等书籍理论学习  高中阶段：          给IT媒体写稿，首篇5000字稿件即获整版发表，稿费500元      自学装机，在电脑城兼职销售，成为销量冠军，单台提成100-200元      建立个人网站（显卡之家），自费运营，早期通过广告联盟获利      四、创业历程：泡泡网与汽车之家  1998年高三创业：与合伙人创办泡泡网，早期内容全部自写  管理教训：曾因忽视团队感受，一天内90%员工集体辞职  2005年创办汽车之家：          坚持真实客观内容，拒绝软文，采用用户视角（如测量实际乘坐空间）      2008年金融危机时遭遇股东逼宫，最终在投资人支持下度过危机      2013年上市前夕遭竞争对手恶意收购股份，延迟上市后最终成功IPO      五、理想汽车的创立与挑战  2015年创立理想汽车，选择增程式技术路线  技术路线争议：          团队内部反对增程，用日产e-Power成功案例说服团队      初期选择的1.5L自吸发动机因高转速问题失败，紧急更换1.2T发动机        融资困境：          2019年特斯拉股价暴跌、蔚来股价低迷，影响融资环境      见过150家投资机构被拒，个人资金全部投入，公司濒临破产      最终由美团王兴投资3亿美元救命        供应链斗争：芯片短缺时期派人驻守生产线，躺生产线逼供应商供货六、产品哲学与组织管理  产品定义原则：          坚持单一配置策略（理想ONE），降低用户选择难度与生产成本      后期因竞争压力增加配置，但仍保持极简SKU        设计理念：          追求家庭用车定位，打破MPV的”商务车”标签（如理想MEGA）      学习苹果设计哲学，经常问”乔布斯会怎么做？”        组织管理进化：          从”对事不对人”到”对人不对事”，重视人才与人心      建立合伙人制，鼓励激烈争吵但相互信任的决策文化      亲自面试所有18级以上员工，重视人才密度      七、人工智能与未来战略  智能驾驶研发：          开发Wareway系统，通过虚拟重建+生成技术训练AI司机      使用等效5万张GPU卡进行模型训练        AI发展观：          将AI发展分为五阶段：聊天机器人→推理者→智能体→创新者→组织者      认为当前处于智能体阶段，AI应像”同事”一样专业协作        全球化布局：计划进军亚洲和欧洲市场，但暂不进入北美八、个人反思与家庭生活  性格转变：从独断专行到重视团队沟通，学会分享困难而非独自硬扛  家庭支持：妻子在事业和家庭中发挥关键作用，帮助分析行业信息  子女教育：强调兄弟姐妹团结，反对内部争斗  工作态度：视工作为生命一部分，暂无退休计划，以”是否成为公司负担”为继续标准九、行业观点与中国机遇  中国新能源汽车优势：          制造基础雄厚，供应链完整      电价比油价便宜90%，充电网络发达      互联网人才进入制造业带来创新活力        竞争格局：认为雷军是唯一同样懂产品的造车创业者  舆论环境：遭遇有组织的黑公关攻击，但坚持”用产品回应”的原则十、总结：创业25年的核心感悟  选择三要素：选得准、选得长、高频迭代  价值观传承：爷爷”做好事不求回报”的理念影响至今  持续学习：每年精读20-30本书，通过预训练、后训练和强化训练不断提升  核心信念：创造优秀产品是最高的价值体现十一、文字版如下由于是四小时马拉松访谈，内容比较长。整体处理采用whisper解析到txt文本，在通过deepseek对txt文本内容解析生成，内容片段存在有错别字以及部分语句不够通顺，请见谅～好，咱们开始吧。开始我听说，你中学之前一直是在乡下跟姥姥和姥爷长大的，对吗？我是小学三年级之前，就是从七个月到七岁。是因为什么家庭原因？当时忙不过来没法照顾，还是因为恢复高考以后，父母考上了北京的戏曲学院？两人都是同一年考上的。生完我以后就考上了。我七个月的时候，就被姥姥姥爷接到山东老家，所以他们去读书没法带孩子，所以就放到爷爷奶奶…是姥姥姥爷家。你觉得这件事对你成长和性格，或者是其他方面，有什么影响吗？我觉得是特别好的影响。怎么讲？因为我姥姥和姥爷给我塑造了一个特别好的环境。就是在老家，然后村里出现的所有问题，各家各户都来找我姥爷。他原来也是读书人，他俩都是军人，也都是离休干部。那个时候还有离休，对。所以他们对教育孩子有一些基本概念吗？我觉得没有什么基本概念，就是你能看到他们在做什么东西。比如他的战友的孩子，战友去世了，就是孩子一直被欺负，然后我都跟着我姥爷一起去，他帮着解决这些问题，然后让整个村里的人没有人再说…他来保护，就是他说“这就是我干女儿”，然后没有人敢欺负他。反正就是所有的问题，他都帮着去解决。所以是一个很好的榜样，我就特别…正义，反正各种问题都到了。所以到后来什么呢？我印象特别深，就是我姥爷去世得早，然后我姥姥现在已经超过100岁了。基本上他80岁以后过生日的时候，原来他帮助过的所有的人都会来参加他的生日。然后你在一个很小的地方，场面是非常好的。而且我觉得最大的好处是，我姥姥姥爷帮助别人没有任何的诉求，就是认为必须要帮，天生就是热情的那种人。所以对你的童年其实是很好的一个…而且我能看到我姥姥姥爷后来被大家认可的那种回报。所以我觉得这是一个挺正向的激励：你只要去做你认为对的事、好的事，其实就会有好的结果。所以你当时对这个还挺向往的？就想成为他那样的人？我自己其实是后来才发现，这个东西对我的影响是那么大。对，当时太小了，没有自觉的感受，但是后边想起来是这样。对，就是我创业过程中遇到各种各样的困难，然后有的时候我跟身边的一些创业者比的话，可能很多时候他们就放弃了、不做了，但是我还能坚持下去。我很多时候是受益于我姥姥姥爷给我这种乐观精神，对，这种乐观的精神。我之前看关于你材料提到这个的时候，我还以为这个事对你童年成长有什么不好的影响。因为现在的教育理念会讲，说跟爷爷奶奶姥姥姥爷长大的孩子可能会有各种各样的问题，但你这儿刚好是一个很正向的一个情况。非常正向。那后来回到父母身边是他们都读完书了对吗？对，他们都读完书了，正好也是差不多回去正好就是上小学三年级。你父母都是文艺工作者，然后你自己，我一直从你出道以来感受就是一个特别理工男的这么一个人。然后你父母其实都是文艺工作者，所以他们从事的事业和相关的这些，让你小时候没有产生过兴趣吗？他们也希望培养过类似这种兴趣，比如我还学过好几年画画，但画得实在太差，也不喜欢。我对他们的戏剧，因为他们后来就是现代剧为主了。所以我一个比较好的特长就是，我能背过我爸写的剧本。因为我爸是导演加编剧，所以他们出去演出的时候，很多演员在台下有时候抽烟，我说该谁上了？我说“你，该你上了”。然后包括这些剧本的大概情节我都能记住。我对他写剧本那时候是很感兴趣的，但我对唱戏、翻跟头啊这些表演没什么兴趣。所以你从小到大对文艺方向的东西都兴趣一般？我对文字方向的东西其实挺感兴趣，喜欢看书。对，因为我爸买了特别多书，我们家应该是一间屋子里全是书，各种各样的书。这点其实还是对孩子特别幸运的一件事。我比较幸运的就是我爸也看书，所以我小的时候书柜里就有看不完的书，相当一段时期。但是跟我家境实际上收入状况差不多的很多人，甚至比我们家收入状况好的，他父亲不看书，这对孩子小时候应该是一个很不好的事情。所以你父亲还看书，让你小的时候有很多书看，他也愿意给你买书对吗？对，这个观念是很重要的。所以我有时候看每个人长大以后成长，回头去看他童年是幸运来自不幸运的有很多维度，其中一个就是父母爱看书对子女的影响，这是一个始终都是特别好的一件事。小的时候其实没这些感觉，对，长大，当然在二十、三十岁都没感觉，当然再往后，你才会想，尤其当自己有了孩子以后，才发现这些东西的影响其实挺大的。甚至有时候感觉，我姥爷包括父母给我传递的这些特质，也并不是自己有什么后天信念出来的，是的，有一些是运气，纯运气。所以你自己从来没想过任何文艺方面的事？比如说你看书，你想过当作家或什么？小时候有过这种念头吗？没有。但是我有一个比较受益的一点就是，我的其实创业是从写稿开始的。所以我印象特别深的时候，我是高一开始写稿。至少在文艺方面，因为看书是收益很多的，因为我作文一直很好，我作文一直很高的分数，甚至大部分都是班里第一，在上初中的时候。明白。所以高一的时候，我印象特别深，那时候给这些电脑的媒体投稿，然后拿纸写的，也没有电脑，什么传真传过去的？对对对，然后写完之后，我第一个稿就写了五千字，直接就发了，然后直接就整版发了。你第一次投稿直接就发表了？然后就拿了五百稿费？那时候一百块钱一千字，那很厉害了。后来就持续这么写。你想，最开始我做网站的时候，也就是自己一直在写内容。对，这个一会儿我们会聊到。我先问一下你的第一台PC，我之前看媒体报道是你父亲花了八千块吧？当时算是一笔巨款了。是在那个时候买给你的？然后据说是你一直跟他央求，然后说服了他给你买这么一台，是这样吗？是初三毕业的时候买了那台电脑。那时候你父亲一个月工资大概多少？我父亲那时候就开始出去拍戏了，对，所以在过去之后，我的估计的话，那时候我们家大概有两三万块钱的存款吧，就大概拿了差不多一半，拿出去买了一台电脑。那这还挺夸张的。你父亲非常有意思，就是他开明，懂这些趋势？还是因为重教育？然后你是独生子吗？我是独生子。这些特别特别好的一个，我后来当父亲真的…我现在这么跟孩子在一起，孩子也跟我关系特别好，就是我父亲从来不过提条件，他认为你应该有什么的时候，他就主动给你买回来。就是包含我是我们小区的第一个有那个FC，就是任天堂游戏机子。然后他就是因为他，我们小时候可都是要去那种游戏厅，一小时多少钱才能玩，是。然后他就是来北京然后拍戏，看到北京这边鼓楼那边看这边非常流行，其实就给我买了一台回去了。他不担心影响你学习什么的吗？他不仅不担心，他到什么程度？他是他跟我，他是怎么给我约定的？非常有意思，完全不一样。他给我约定是，说你每天都可以玩，但是你每天玩多少时间，你要给我一个约定。对，然后到时间就收走。所以他是跟你商量这些？对，而且不给你数字。比如说我当时定的是，我每天中午玩两小时，他就真让我玩两小时。而且我们那儿小孩都来我们家玩。其实你真是很幸运的家庭，因为亚洲父母很少这样的，特别是那个年代。是，而且他，我也真的能做到，就两个小时我就真的不玩了。对，甚至后来我主动说我不想玩两小时，我玩一个半小时就可以了。所以他对你这个尊重和信任，也是跟你自己表现有关吗？因为很多孩子说两小时，爸爸答应了，一玩玩四个小时，肯定后边就不让玩了嘛。对，但他就是让你自己说两个小时。其实中间很长，就中午一回来，然后因为那时候上课的时候中午上来会来的，这个年代对吧？那一回来其实除了吃饭时间，你都可以在玩，那你也不能超时间，再超两小时你都没法上学了。所以到这种程度。在那个年代，玩任天堂，孩子们都玩疯了，逃学都要玩，你还是比较很小就有自律的意识吧？我觉得是因为有这么一个方式才自律的。你说是因为父亲跟你交流的方式？对，相互尊重。是，我就觉得特别特别重要。这个在那个年代的亚洲家庭其实还挺罕见的，就我爸在那里面，我父母是唯一的。然后上了大学关键意识就…相对那个大环境是比较超前的。是，明白。那你提到要买这个PC，花8000块钱，到他同意是很顺畅的过程吗？很顺畅的过程，他说明了半天还是什么呀？很顺畅的过程，没有什么难度。对。然后我妈另外一种方式，我妈也特别有意思，然后我发现对我后边都特别重要。对，这个特别重要。我妈又跟所有的小朋友不一样，就是从小学开始，我的零花钱是按月给的。大家都是每天一块钱，我是一个月三十块钱。然后我妈就要求，你自己随便花，但是你花光了不要来找我要。所以我第一个月的时候，三天时间就把三十块钱全花光了，会找我妈要，我妈一个月没给我。然后后边的话，我就自己完全知道怎么管钱了，甚至我可以攒几个月，然后花一百多块钱去买一个多合一的游戏卡。而且还造成什么？还造成我一上初中开始会赚钱了。就是因为你会发现这玩意是非常有意思的，他前面这个规划让你有了基本的最初的理财观念。我初中开始赚钱的一个方式是买漫画书，因为我们发现的时候什么，一块九一本漫画书？我们发现批发市场上一块，所以我就给同学们，然后一块五、一块六卖给他们，我就去批发市场说好了，我就去晚上买回来然后给大家。所以你商业方面的意识很早就有的？你没有刻意地去做，就知道？有可能是天生的，有可能是我父母早期对你的一些教育和沟通方式，让你自然培养出了这个。那你会发现同年的同学完全没这个意识？对，完全没这个意识，我到三十四岁都几乎没有商业方面的这个意识。然后我看了很多企业家传记，很多都是很早的时候，不管是天生还是父母引导的，他就有很好的这方面的意识。但我父母在商业方面也没有什么天赋，对，但我就觉得他们可能打小跟你沟通的方式…对，跟你沟通的方式比较健康，所以产生了一些良好的影响。是，那你还真是挺幸运的。我们都看过那个Elon Musk的传记，他小的时候很小，计算机方面就表现出来特别聪明和不一样的人，他就参加一个那个大学教授的一个讲座，他是个小孩，然后听完了以后跟那个教授一直交流，然后交流到特别晚，然后他爸去接他，以为出什么事了。结果那个教授跟他爸说，你一定要给这个孩子买一个计算机，要不然你会后悔的。然后他爸犹豫了半天就给孩子买了一个。但你比他还幸运，他是借助外力才实现了这个东西。我还觉得我长大的时候挺幸运的，我觉得你长大的时候那个小时候的环境比我还要幸运多。我小时候就是看书这方面还可以，其他方面我觉得我父母还是有不少就是那些观念的，所以后来我还去看过心理医生。这个是特别幸运。然后你是在高中时代开始给IT媒体写稿？还是初中就开始？高一开始。高一就开始？初中的时候我其实最开始是倒漫画书，最后是挣的最多的钱都买了电脑书了。那时候能买的电脑书不多，什么大众软件啊、电脑报啊、计算机世界，对对对对对，然后这个微电脑计算机啊，然后电脑爱好者啊就全买了，而且每年还他们都出合订本，还把合订本买回来。对对对对，我那些也全买过。然后你是在小学初中的时候就感到自己是一个跟同学比是一个早慧的孩子吗？有这个有这个模糊的意识吗？没有没有，你觉得跟大家差不多啊？其实我在初中的时候受到的更多反馈并不好，因为那时候没有电脑。因为我是上了第一堂计算机课，我印象特别深的计算机课的时候是接着一个黑白显示器的，然后有中华学习机，还有IBM？IBM PC？还有IBM的…对，有IBM，有中华学习机。我接触完以后说，哇这玩意太厉害了。所以你提到就开始来学电脑，那时候你拿着书学电脑，别的孩子以为这是…机器都没接触，孩子有自闭症？你进入那个世界了，你真的进入那个世界里去了，好几个小时，所谓现在流行叫什么心流状态？对，而且你就是看书，而且没有电脑可实践，就是纯粹看书。所以你小时候会被同学老师当成书呆子吗？也不会当书呆子。但是有一点事比较难受，初中的时候最难受的一件事情是什么呢？就是我看到电脑书了，然后跟班里家里有电脑的…那时候真买不起，那时候电脑贵，我上初中的时候买一个386DX要三到四万块钱，我还印象特别深一个牌子叫AST。所以家里真买不起，但是有的家里有买了。所以你跟他去聊，然后他就基本上说“我有电脑的时候你还没见过电脑呢”，所以就不跟我聊。所以那个其实是挺受打击的？不跟你玩？对，不跟你玩，因为你没电脑。他有电脑的同学在一起玩？小孩不懂事也容易在这些方面表现那些比较残酷的东西。对对，对你打击还挺大？也没有太大打击，就羡慕有电脑的孩子。其实你属于书里的一个世界，就在这个世界里边。对，就是你说不出来为什么，就是喜欢你感觉你属于这个世界，你一摸电脑就有这感觉了，对吧？对。还有你小的时候没有觉得比同学更聪明或者是什么啊？但是你有没有那种有一些什么天生的使命感？不一定跟同学说，可能羞于跟他们说，或者让他们觉得反感，但是你自己觉得是要做大事的？有没有这种感觉小时候？小时候有过一件事，就是应该是在上小学的时候，有一门课叫思想品德课，老师问大家说，长大以后想要当什么？我说我长大想当总经理。那个时候是最大的官了，后来又叫CEO、董事长、董事局主席，这个官越来越大。对，那时候总经理是特别高高在上的一个头衔。对对对，我们小时候总经理是特别高的。那时候在班里是被同学嘲笑的？肯定的，因为都是当战士啊、当科学家啊、当军人啊那是当年啊。对对对对对是。那是几几年啊？商业已经个体经商已经很普遍了吗？应该是90年代初吧？90年代初应该还可以了？一期没有到，90年代初你是82年生？我是81年生的，81年生对，然后反正就90年左右吧。对。这个其实在那个年代肯定在老师学生眼里是一个古怪的愿望。但是呢，其实我说我做的所有的这些判断选择都是有一个真实的一个外界的反馈，也并不像大家想…我从小天生就有这么一个特点。初中的时候我就明白，我小的时候可能比你情况更糟糕。我出生在很落后的地区，你们是思加装势力对吗？是加装势力对吧？那还是很大的了。我们小时候，反而是我在东北三高里长大的嘛。所以我小时候要讲一些雄心壮志，那是被无情地嘲笑。同学和老师倒不至于，老师就是会古怪地笑，他也不会说一些残忍打击孩子的话，但老师也明显是不屑的。然后同学都是那种古怪的笑容。最打击我的时候，一个同学就说：“你明明是个傻子，为什么有这么多不切实际的想法？”然后我说：“怎么是什么？”他说：“我们都是这样，你为什么不能像我们一样？”他老给我讲这个。然后我就老觉得，我可能是能做一些大事的。这在小时候被打击得特别厉害，就连我父母虽然没打击我，也没鼓励我，他们就觉得我有一点异想天开。所以你小时候并没有很强烈的这种感觉，所以没受这方面的阻碍吗？我有点像强化训练，都是靠外界反馈来构建自我认知的不同变化。你看，我第一次有当第一的感觉是那个作文——我作文拿到最好的成绩，其实我各科成绩并不好，就作文好。但真正一个稳定的循环开始，其实是从买了电脑以后，尤其是初三的那个暑假。对，初三那个暑假开始，我就彻底变成另外一个人了。因为有了电脑，之前的电脑基础真的很扎实，我的电脑基础相当扎实。就是说上机操练不够，很快，基本上一天时间就全解决了。我知道你是说你过去理论学习的时候，因为去机房上的时间非常有限，是的。然后相当于我做了特别好的一个预训练，基础模型后面推理就变得很好了，底子都砸得很扎实。那我最重要的第一个反馈是什么呢？就是我买电脑的那个商家，它原来是在一个流量并不多的街上一个小门店，然后它进了一个最大电脑城，在做得特别好的一个地方。因为那个电脑都是自己DIY的，就自己定的配置，对。我回来以后就把电脑拆了，再把它组装起来了。后来我干了一些什么事呢？整个暑假是非常开心的，我去电脑城里帮助它来组装电脑。因为它生意很好，人手不够，而且我比较能说，我给别人推荐的时候，别人就特别相信我给的配置，而且你长了一张特别讨人信任的脸，所以卖电脑肯定有优势的。那时候印象特别深，英特尔CPU、华硕的主板、飞利浦显示器，对，全玩过，都玩过。那时候它基本上卖一台电脑，因为我们都能算价格嘛，因为我要跟顾客讲价格，讲完价格弄完配置以后，有些顾客就去别的店里来串，然后过来装台电脑。它一般一台电脑赚800到1000块钱，它会给我提成，每装一台100到200块钱。所以那时候有个特别好的反馈，而且就一个暑假，因为我是装得最多的、卖得最好的，他们变成整个电脑城销量第一了，销量变成整个电脑城的销量了。所以那个时候就有一个特别正常的反馈了。上高一开始，整个学校都知道，装电脑找理想。那时候包括写稿子也是，搞技术不是随便写的，都是从用户的反馈里获得的，而且用户量还挺大。是你那个高三的时候就做了显卡支架？我是知道你辍学去做了POPPO，但我不知道显卡支架。后来就是POPPO，我当年也是显卡支架的重度用户。但是我这次准备采访的时候才发现，那个显卡支架后来就变成了POPPO，都是你做的？其实大家很容易忽略一段，我并不是直接做的个人网站，还有在前面是一两年时间。Telnet BBS，我没玩过，所以在那时候还不知道后边很多人会很厉害。因为在Telnet BBS的时候，我是跟着石鸦庄的时候，当时又叫书路，我跟她学，对。然后我就上Telnet，因为那时候还没有开放互联网，然后拿那个帮盾Modem拨号BBS，对，那时候珠海的就已经是求伯君和雷军了，深圳的然后是马化腾，那时候都是叫什么IT英雄，对，就是那个时代。那时候我在帮着石鸦庄，因为石鸦庄也是一个比较活的站。那你启动做那个网站的时候都是自费的？用稿费做的吗？还是自费的？都是自费的，对。因为那时候上网费很贵，所以我基本是高一上的Telnet，然后高二开始上互联网了。主要是因为有了互联网以后，你能看到，也是从杂志上看的，很多人建了互联网站，放那种广告就能挣着钱。所以我最开始的动机就比较简单，我就把自己写的内容放到了自己的网上，而且跟杂志有一个约定：发布一周以后，我就可以放到网上。后来发现还不行，就是我还会去看一下国外的网站，把他们的内容做一些简单的翻译，找一些新闻，每天有这样更新。我看到说你当时高三大概18岁的时候，月收入就有2万多，是你父母的差不多10倍，这个样子，这个没错吧？这个数字没错。这个放到哪个国家、哪个时代都是一个很离谱的事。所以你那时候没有因为这个小小年纪能赚这么多钱，产生特别强大或者特别不一样的感觉？感觉自己是一个超人，特别是在同龄人当中？我觉得首先，从高中开始的时候我还印象特别深。初中同学跟我分到了一个高中，基本上一个暑假以后，我有电脑，我在看他们聊的时候，你就觉得他就是个菜鸟。而且我刚才讲的是，第一我做到了整个电脑城装机量的第一，然后第二呢，同学们都知道，亲戚都知道“买电脑装电脑找理想”，可能没错，而且大家装完都很满意。从那时候我形成了一个对自己的认知，跟今天没变过，算下来应该有30年没变过了，真的。那时候的想法就跟今天一模一样——掌握自己的命运，挑战成长的极限。那时候我就在纸上写下来这句话。所以你其实从青春期开始就没怎么迷茫过？对未来没有迷茫过？我各种打击肯定有啊，对，无数的打击都有。我知道，但是因为我不是做过几年教师吗？是高校巡讲跟学生活动交流特别多，那些年就感觉很多毕业即将毕业的孩子，甚至是毕业多年的孩子，其实他对未来还是很迷茫的，他不知道自己真正想干什么。我觉得你跟那些像乔布斯、比尔·盖茨他们都很一样的一点就是说，在很早的那个年纪接触了计算机，然后迷上这个东西，并且很早就确定了自己终身热爱的方向，或一个大致的方向。这个我不知道是天生的还是后天的环境塑造的，但反正是一个非常幸运的事。因为你让我比你大九岁吧，然后我很早也是接触了计算机，一摸上手也是完全沉迷，我觉得这个东西很神奇。但是我小的时候是非常严重的文科生思维，所以我就觉得，哎呀这些，特别喜欢，每一代都会买，一有钱就会去升级，这些也都做，天天玩。可能是打小就是文科生思维，自己也有严重的不自信，在别的方面可能很自信，这方面不自信，所以我从来没觉得这个行业跟我有什么关系。但是到了那个移动互联网那波的时候，突然就是心里蠢动，就开始尝试了，然后觉得好像我也能做手机，然后去做的。但是现在回头看我那个感觉，那个算是来得特别特别的晚。可能就是我年轻的时候固定地认为，我就是只能做文科生做的事。你们是没有这方面，虽然你家庭出身是文艺家庭，但是也没有这方面的限制？我觉得这些有一些还是很难说的，你根本不知道是发生了什么会导致这个。我自己也是到27、8岁其实还挺迷茫，30岁前基本上想清楚，但是你18岁就有这样的认知，这真是一个不可思议的黄金年代。那么好的一个时代，其实住在那个时代的年轻人也有很多从来没想过去干这个事，所以这个命运这种安排有时候还确实挺神奇的。是你刚才说的就是做个人网站，我做个人网站又和其他做个人网站有个本质的不同，一个更根本性的不同就是：我有员工。你是在自己家里本地就开始招员工了？我当时的时候，总共是有两个员工的。一个员工是在加拿大，他在上学，他来帮我写那种——他帮我拿美国和加拿大的信息，所以他是直接能够接触国外源头去获取内容的。所以那时候我们又能拿到最早的内容。这么离谱？对。然后这个人是怎么在互联网上勾搭上的？对，就是那时候拿ICQ认识的，他是我们的用户。还有一个写文章特别厉害的叫陈韫珠，那时候是写文章最厉害的，然后他是我的另外一个员工。我们三个其实合伙来干的。这两人都比你大吧？那个在加拿大的其实比我要小，因为他那时候正在上学，那应该比我大？我忽然想象他在那边上大学。那波风起云涌的时候，你们同龄就表现出这种不一样的优秀品质的孩子多吗？我怎么感觉好像还都不是，要比你大个好几年才有这些行动吧？我自己认为自己一个人不行，自己一个人做不了最好。包括你刚才讲的说我的收入比父母多十倍了，但是我又不跟我父母比，我跟那些其实做得更好的比。但那时候有同龄的比你做得更好的吗？没有，过得没。我那些群里聊的都是一些海归，那时候做个人网站的以海归为主，而且硬件和软件分开的：做硬件的是我们是一波，做软件的像华军什么的，是另外一波。对，华军、高春辉啊，是。那时候你没有产生羡慕想去留学什么的吗？因为他们明显在自信方面要比我们快很多。也没有没有，因为学习没有给我带来一个正反馈，你是这个意思。所以我学习还有另外一个特别——就是今天我也有这样的一个问题：上课的时候，我觉得90%以上的课其实15分钟这场课所有东西都讲明白了，那老师聪明吗？老师非要讲45分钟。这种方式其实我感觉上课有时候是一种折磨，15分钟讲完了，再拿30分钟把大家讲的心里糊涂。那你要是特别学霸的话，有可能就因此去了那个什么科大少年班之类的呀，你听说过吗？那个时候没有，后来才知道。其实咱们那个已经算正常了，你就是因为太聪明，神童，所以从学习考试上得不到什么正反馈，明白。还有就是你是不是不愿意学的科目就不好？是特别偏科对吧？对我比较好的是物理和语文，历史连政治我都很好，但是像化学、像数学我就比较差。那你后来学了写代码什么的吗？没有，始终都没有。我写代码是什么时候？我在写代码当时最开始做网站的时候，为了效率高，所以那你可以拿FrontPage配置让它自动生成，也可以自己手写。我为了网页速度快，我都自己手写，我会写那些代码，那个HTML码会写，对，网页代码、ASP那些代码会写。但那时候用工具写的吗？如果你用FrontPage配置是拿工具写，然后如果你拿Dreamweaver或者我拿记事本写，我为了网页大家访问速度快、流量快，我就自己来写，包括一些简单的SQL什么的我是会写的。你高三的时候要退学跟父母之间有一些争执吗？还是他们很痛快就被你说服了？我没有退学，我是毕业了——不，我说错了，就是你辍学，不决定不考大学了吗？你肯定能考得上吗？你不准备考大学了，对他们没有什么辛苦的说服工作或争执吗？我觉得我用了一个比较好的方式，我并没有跟父母在讨论是否上大学的事，我在跟他们科学讨论的是“上大学还是创业”这个事儿，就是跟父母一起来做个选择题，不是做个对错题。我一直在强调这件事情，明白。有很多人太容易做对错题，如果我跟父母说不上大学，我肯定赢不了，对，父母肯定没法支持我。但是最后我是把这摆出来说：上大学怎么样，我还推理了毕业以后我可以去哪里当一个编辑，然后后边收入多少钱；然后这边，其实是因为我当时还未成年，所以我的稿费是写的父母的名字，那时候邮局汇款然后去取，那个稿都有留个存根，她一台存根就在放着，我妈妈就把这拿出来，“我这些年轻轻松松多了很多钱”，对，然后我能挣钱了。这个应该还是很重要的一个因素。因为不要说你父母那么开明，即使是特别保守和那种控制欲强的父母，如果儿子在18岁的时候就比自己挣的多十几倍，他可能也就觉得我这孩子不是正常孩子，然后也没有那么大信心就是粗暴地去干涉了。我觉得还要一个要素就是说，其实基本上就我们这一代人的父母，大部分都没有上大学，都是希望把“上大学改变命运”的初衷放在孩子身上了，而且在他们看来是一个不能放弃的、必须攀登的高峰。但你父母读了大学，也就觉得读了肯定是好，但是如果孩子有更好的选择也可以商量。对，我觉得跟他们俩已经读了大学也是非常相关的。怎么听着全是幸运的？给我讲讲童年创伤、青少年时代的挫折和挫败感什么的，失败也算。就是你太早成功了，就是18岁以前有什么挫折创伤一点都没有吗？我刚回到石家庄的时候，整个小区的孩子都欺负，因为是刚搬来的，对，而且我一嘴的昌平口音被嘲笑，对，那小孩都是这样的，对，然后残酷。我刚回到学校的时候，因为是一个插班生，我坐的位置是什么呢？是老师的讲桌的侧面，就没有正常的桌，没有正常的座位，明白。所以有一个阶段其实挺痛苦的，而且小朋友们，都欺负厉害的，比我大的人。我今天脸上很多疤，都是在小学的时候被他们抓的、打的，很非常狠，就把我脸都抓烂了，对，然后这没想到。对，因为那时候你是一个，你进入一个陌生环境，对，所以你不敢反抗？我也因为转学来被欺负，但是也没说打的都把脸上打出、脸都抓烂了，对，太后果了。小孩特别坏，小孩很多时候坏的时候坏到没有良心，对。今天看什么校园暴力，我们当时都经历过，对。然后我那时候报警也没用，没用，不像现在你说报警还有人管。然后我妈说你只能自己打回去？你父母都这么教育？对，然后你妈也这么教育？挺神奇，我妈说“你必须自己打回去”，对，没有什么别的招。然后其实我是沧州陌生县，我小的时候练八极拳，其实我打架很厉害，著名的习武的地区，是的，然后我哥就是个武师，然后我每天都跟他，每天一院子的学生跟他练。那为什么没有一开始就反抗？就是你进入环境的时候，你其实是用自卑感的，他们都说普通话，然后你说话他们听不懂，然后你晒得特别黑？我那时候晒得特别黑，在老家可能还有像高原红什么的，然后牙——是黄的。因为那时候，那个沧州那边的水是有水碱的。那就是，你觉得你不属于这里，你自己也不自信，打你的时候你也不反抗，明白？对，这样的。然后自从我妈说那句话以后——几个月后，我妈说，我说他们老欺负我、打我，你看两个招似的，就突突要。你得自己打回去。我就开始往回打，我把那个最厉害的打了，因为他比我大两岁。后来我妈说，你不能欺负别人。我小时候印象是一直被打，从初一村一直都是来打的。到村下学期，有一次被打急眼了，就是“我为兔子急了也跳墙”。我小时候，虽然淘气、嘴欠，但是打架欺负人这种没有过。后来被逼急了，反抗了一次以后发现——学校附近的流氓再来我们学校欺负人，上来就跟我打交道。所以很早就突然明白那个道理：他们欺负你的时候，是要算欺负的风险和成本的。如果你一直好欺负，他就会输出负负负负贺贺负；但如果你反抗一次——我就反抗那次，被打得特别惨。其实因为不像你，你还练过，我没有这个，所以我被打得特别惨。但是那个“惨”特别值——他就知道你是会反抗的，然后就再不欺负你。所以到学校门口欺负人的时候，下班的小朋友，一个哥抢钱，到我这儿的时候开始管我叫“哥们”。然后附近的那些流氓听说了我反抗的事以后，也都过来打交道了。所以其实就反抗一次就管用。但我后来跟那个教书的时候跟大区交流，他们就给我讲：他在生活里被欺负，其实很多时候你就只要反抗一次，就就没事了。你说对。而且还有一个问题就是，当时的时候我为什么开始我都不敢跟我妈说？是他们欺负人，生活会变美加利的——就几个月的时间，越来越狠。当然你越忍，他越来越狭隘、越来越狠。对对对对。所以我后来跟那个学生交流的时候经常讲一个命题：就说不管是校园暴力，还是长大以后走进社会，你被欺负的时候，其实你就要很凶狠的反抗一次。我甚至把这个就当成真正意义上的成人礼。有的人到了30多岁，还很多人都一直被欺负。所以这个东西我觉得也是，也是一个跟命运有关的一个事情——就有的孩子，不管是成长环境还是天生的基因，他就会一直忍。而且我当时还担心一个问题：我当时特别担心我打完以后，然后小朋友就隔离我。但是我后来发现，我打完以后小朋友都给我示好、靠近我。我变成了小区的孩子王，上来就开始叫“李哥”了。那时候还没有“人”啊，就那意思吧。对，是的。那你要重新选择的话，你还是不会上大学，对不对？你不会上。你对没上大学有任何遗憾吗？遗憾肯定是有的。比如类似什么样？就是你不可能什么都获得好的，你还是有取舍。对，我觉得还是少了一份人生的经历，那个经历可能也挺珍贵的。是的，对。我听我身边朋友讲他们大学时代那些快乐的时候，我心里还是有一点就觉得：还有这样的东西？其实后边的话，你像我也上了一些商学院这样的。其实我上商学院我从来不缺课，就很多时候也是不藏。但是你说回过去以后是不是这么选择？因为它还是个取舍，因为每一项都有得和失。但我还是会选择创业。其实对，我觉得这肯定是一个正确选择。就像BIRD该词那种事，就是第一，赶上时代机遇了，自己很早就证明在这时有可能做成了，其实确实没有理由去读书。但是少数这样的人的成功，有时候也会在高校里形成一种氛围，就说大家都应该就是觉得有个什么机会就出去创业。其实这个也是成功率特别低的。我也遇到了人问题。比如说我们正常的话，我们招聘的话肯定还是要求是本科。但是就会有个人说：那凭什么你没上过大学，对你又不招？我也碰到过。你好，你又要招本科。然后我说两个方面，你怎么跟他们解释？我说如果你真的水平特别高，对，比如说你是什么技术社区的大牛，你是什么的，你能证明这个，对，你没有学历我也找你。然后第二，其实我当时面对的问题不是上不上大学，是创业和上大学。而且我当时选择创业的时候，我已经有一个访问量很大的个人网站了，对，已经证明了自己了。对，所以其实不一样的，不是盲目的。对。所以我说，你该好好上大学还是好好上大学；要么你有一个真的一技之长，能够证明的。对，差不多。我也是跟以前去高校做很多活动互动的时候也是这么说的，就不过力他们轻易辍学，就是除非你能证明什么。然后另外一个就是，大学生辍学创业或者刚毕业就创业，成功率其实很低。他要确信他的自信是有一些逻辑和理性的基础的话就可以。是。所以就是，你没有上大学这件事，甚至没上过班，因为直接就创业了嘛。后边对于做公司，你发现因为这个会有一些误判，或者是一些别人都很能轻易处理的，但你因为缺乏这方面经验，导致有一些奇怪的那些东西。然后似乎意识到是跟这个有关系的。有这类当的利益吗？我觉得肯定会有的。对，我觉得也同样是有利有弊嘛。就不是为了说把话说圆了。当然弊的话就是，很多东西你没法感同身受。对，所以你不知道他为什么那样反应。对。然后呢，比如说是利的话，很多时候你可以最理性或者平直地去解去做判断，而不需要有那么多顾虑。因为很多这些顾虑其实会影响判断的。那我举个例子来问：比如说你的员工找你希望加薪，他有两种方式。一种是找你坦诚地讲“我为什么应该加薪水”；然后另外一种是他希望你给他加，但你没有及时给他加，然后他觉得他表现得不错你没有得到认可，然后他就决定辞职——这个辞职未必是真要辞职，就是他要走，你问他为什么，你觉得有什么薪资待遇问题的话你可能就给他加。就这两种，你通常更接受哪一种？就是他希望加薪的时候采用这两种方式的话，我觉得就是这是一个训练的过程。从最开始的时候对，就说开始的时候最开始的时候就肯定不知道怎么做。比如说他说要来辞职，让你说“你赶快走吧”，你就直接这么错了，最开始就这样的。那你的反应是什么呢？比如说这个人挺优秀的，你不会想着挽留他吗？所以你开始就后来又吃亏，然后你会发现这个人去到别的公司，对，然后对自己影响很大的，对吧？那你训练到现在这种阶段的话，就如果他要加薪的话，对，那挺简单的方式。我觉得就不要不要做什么对立。对，然后就准理性分析，我觉得也不是，就是我这理性感情都有吗？我觉得核心的就是说，第一你先接受他这个这个需求；然后我这儿第二的话，然后你让HR和财务跟他分享，是不是给他薪水给低了。然后作为一个对外对内的一个分析，我们会发现其实很多时候就是给低了——他现在的工作出去找不到一个比较好的人，那就应该给人家涨这个，有啥可犹豫的？我之所以问这个，是我有一个朋友跟你一样，也是大学就创业了，然后很快就赚了钱。然后他因为没有打过工，所以他有一个奇怪的反应：就是他的员工跟他要加薪的时候，如果找到他屋里来坦诚地沟通，他相对容易接受；但如果对方要假装辞职看他留不留和加不加薪，他甚至会很愤怒。他就说“想加薪就直接说，为什么还要假装离职什么的”，他就会这样。然后我当时听了就很奇怪，我说你是不是因为没打过工，缺乏这种理解？我说我会觉得每个人想法不一样，比如说我去打工的时候如果老板工资给低了，我感觉那我其实是不好意思跟他坐下来谈为什么，我觉得应该更多的——这没有对错，就是我是这样性格，然后我可能会辞职看他留不留、给不给我加薪，这个对我容易很多。但是我那个朋友就因为没打过工，他觉得一个人想加薪不直接说、假装要辞职，是一个令人愤怒的事儿。所以我当时还觉得挺奇怪的。我的一个比较大的转变其实是刚创业的那些年。我关注都是事，其实看不到人的层面的东西。对，本来是事情优先，所以听起来像特别理工男的那种思维，纯理性的。大家那时候也讲什么特别鼓励“对事不对人”，对，就是都是这么来讲。但是后来的话，你规模做大了以后，然后你也吃了各种各样的亏以后，你发现其实人才是最重要的，人心向上，还是把人放在地上。现有人才有事，而且“对人不对事”——应该先把人对待好，然后事情就水到渠成了。这也是吃了很多苦头。是的，非常多的苦头，非常多的苦头。还有一个就是，很多事没有那么顺。因为像我是1998年，高三，然后就开始创业了。当时都是，我是把我们那个所在的个人——就是信息港，因为大家把这个个人网站放在信息港里，然后信息港的第二名就是樊铮，我就把它拉过来跟我一起来做了，我们俩一起来创的业。因为它技术好，它会管服务器什么东西，它懂技术，它在那种比较差，我就抓那种抓产品。回到我们就合作这么来做了。其实第一年就出问题了。问题是，美国的互联网泡沫破灭了。因为我们原来放的一些广告都是美国的广告，美国厂商吧，就是美国那种通用的广告。就是有一个——不是，它不是DoubleClick，在那时候DoubleClick这些广告，它就是，还有谷歌广告那些，它有点像后边的广告网络、广告联盟。但那时候是一个，哪儿放上去显示，然后显示一千次给十块钱到三十块钱，我们靠那个东西做收入。所以你的广告客户并不是国内厂商，我们没有去谈过任何广告客户，就是放这些广告联盟里给你的广告，然后来这边一千入一面就走回来。然后那时候美国开始互联网就出问题了，99年、2000年，所以忽然收入就清零了，就基本接近清零了。我们一般做着网站，一边接触出客户，然后另外一番我们都想什么了？为了活下去，我们都想着去做这个系统集成，就这个公司要不我们去取来做，对，都想着这么活下去了。但是很意外的一个机会就是，然后一个中关村在线的销售说“你们为什么不来北京”。所以，你到那个点还在石家庄。那时候泡泡网已经启动了，已经启动了。所以2000年初，春节一过我就来北京了。带了多少钱我都忘了，带多少钱，但反正那时候其实作为你那个年纪是不缺钱的，完全不缺钱的。我们一直不怎么缺钱，因为我们比较省，也比较省钱，因为一直不怎么缺钱。所以就来北京。来北京，他已经拉到了几个客户了，像什么爱国者、华硕啊，国产品牌，他已经拉到了好多客户。还这么着，其实才真正开始商业化的。那你之前为了买东西或者是什么发稿也经常去北京吧？经常来。但是我对中关村什么都很熟。所以为了创业来北京的那一次，跟平时去买东西或者干嘛的时候感受有明显的不同？还是因为缺了太多？没有什么特别感觉。我高中时代的时候就开始去各种地方了。然后我印象，我去了去北京比较多嘛，因为不差钱，所以就可以很早就行万里路。也没有，就是他经常邀请你来，比如说C3、G3，邀请你来参加活动，因为你是知名写手。对，然后帮我他组织这种比赛，我那时候我还能来当评委。那时候有什么DIY大赛，对，随来北京，然后还会去，还经常去。你当评委的时候被你评的那些人都比你大吧？他都不知道年龄什么这样的，你装成熟点。而且评传的时候也没有什么在线，也没有什么直播。对，我看你那个时候脸上也不自乱，所以当那还能护住。对。然后那时候去北京，我还印象特别深，那时候我第一次坐飞机，然后还去了苏州工业园。那时候是明基，我们叫“笨球”，笨球，笨球，笨球的显示器是其中产的。所以我那时候很小就去了。那时候印象最深去的时候，然后阳澄湖吃大闸蟹。那时候是邀请的吗？邀请的。我第一次吃大闸蟹，觉得好吃吗？很多都是北方过去的，然后呢觉得没有肉。两个事特别怪：第一次呢，因为在北方你很少去过南方嘛，那时候那不像现在那么大家都去的。第一次然后去的时候，晚上吃饭的时候，然后先上来一个那个洗手水，茶的那种洗手水，很好，我当时没有动，然后结果就有一个媒体的人拿着喝了。对，吃第一个特别有意见。对对对对对对对。第二个上来什么呢？我也经常理会，上来大闸蟹，一个人只有一个。我说我们吃海鲜的时候都是上来一个大盆，对对对对，然后四股汁这么吃，一个人只上来一个，我当时觉得特别奇怪，而且特别没有肉。而且吃饭的时候，而且吃饭的时候，而且他们用这种饭是吃，完全不理解，一大堆器具也不会用。对，不会用，就像那么就跟吃海鲜一样的，不可能。对，而且没什么肉。对。所以高中的时候很多事，很多事也挺丰富的。真羡慕啊你，因为你很年轻就有那个赚钱的能力，所以真是真是挺好的。因为我小的时候想法很多，看书很多，但是因为经济上没有能力，所以就是咱们老说“读万卷书行万里路”，行万里路都是30岁以后，30岁差不多到30岁才开始的。所以你很早就跟同龄人完全不一样。所以你当时因为到处去，而且北京也去过很多趟，来到北京创业的时候没有什么特殊的感觉？只是说要到大的地方做更大的事了？是。而且我特别喜欢北京，因为我对象那边是一个很大的不满意的是什么？就是你在你身边找不到能学习的对象了。对，我知道，因为我特别需要反馈。是是。现在我特别喜欢找北京的人来聊，因为你觉得这里边牛人太多太多了。对。然后当时我还印象，那时候来北京的时候，西直门那个FM365的广告，你觉得哇这才是你该来的地方。但是一直下着一个决心，还是都亏了当时少认，然后跑了趟谁要装跟我聊了一下，就是让我下定决心了。虽然你已经去过很多次北京了，但要下决心离开家，心里还是有运了？因为他们都不去，所以就我一个人来，对不对？你说你们三个合伙人，那俩都不敢去。对，就是包括石家庄当时招了一些员工了，他们都不愿意、都不敢去。我一个人来。他们怕什么呢？你们已经盈利了，他们怕什么呢？可能跟那个城市的一个范围有关，就大会，很少有人出去。像我，我的初中同学对关系都很好，真正离开石家庄的就那么三五个，一个班的同学。对，这个也是挺奇怪的事。我小的时候在家乡，很多特别特别聪明的也没有很多，有一些特别特别聪明、特别优秀的，我在读书的时候就是很佩服他们或者是很喜欢他们。但是这些人由于我不知道原因，都对离开家乡这件事打心底有恐惧，然后没走的。我离开家乡五六年、七八年回去，就发现他们已经心态已经都完全不对了，就老牌子抗陶而去生，小时候也都是有雄心壮志了。所以我始终都不知道。我感觉离开家乡这个深层的心理和先天后天的因素到底是什么，就特别奇怪。我来的北京的时候是特别开心的，前所未有的开心，我也是。但是我们刚来北京的时候，居住条件比较差，我们就是当时印象特别深，在石家庄租了个三十多平米的一个房子，不是地下室，已经不错了，因为你们已经很早赚了钱了。当时一个月有几个月广告收入了，穷小伙来了都是先住地下室，白天在这里办公，晚上睡觉。我们还做了三个月左右时间，钱赚的更多了，所以当时就在那儿放了个公司，就在这个硅谷电脑城那儿放了一个公司。我看那时候你那个泡泡网就打了一个CEO、首席执行官这样的头衔，那个时候这还是比较新的名称，在之前不是都叫总经理吗？对对对对，那时候大家都崇拜硅谷，特别高大上，特别洋气了。所以我当时要去硅谷电脑城，因为崇拜硅谷，所以你印了个名片，也已经赚了很多钱，然后印了个名片，上是CEO或者是什么首席执行官。这个时候自己感觉还是特别意气风发的吧，所有的反馈都特别好的。对，这困难很多，但是其实机会无限。那你到那边开始就是也好起来，开始批量的招人的时候，应该大部分员工都是比你岁数大的，对吧？对，都是比较大的。那他们有什么一样的感觉？或者你因为这个有什么不一样的感觉吗？没事，就是我说对事不对人，我几乎不在乎别人的感受，那时候还是比较粗暴的。什么员工沟通，反正就一间屋子，就是沟通基本上简单粗暴，直接就简单粗暴直接，所以伤害了人也不知道，也不关心，也不关心这一事。那他们来面试的时候发现自己比你大很多，他们没有留了什么吗？我们面试基本上都是通过QQ，哦，SQL？还不连硅谷，哪有什么正常面试？没有一串，哪有一串啊？因为到多少人的时候有一串？那要到几百上百人的时候才有那一串，发现没有，实在不行了，实在不行了。那前半帮你砍一串工作的是谁呢？没有正式的一串之前，少镇就合伙人。对，所以开始就是纯做内容和纯做技术的两伙人，其他什么都没做。技术在石家庄做所有的技术，对对对，石家庄为什么呢？因为那一串都没来，对对对对对啊，所以他没来，到技术还远程做。对，而且我们装的技术人都很怪，什么一个技术大拿是石家庄做大机厂的，然后下岗职工自学的，他在那儿管IT的，所以技术水平很高，尤其是成本优化特别好，你这服务器什么优化特别好。所以没有因为到北京来，然后找了一堆很优秀的，原来那些就逐渐不是你故意，而是被事实上的能力淘汰了？没有发生这个吗？还是过了些年也就发生了？就是因为做技术一直在石家庄，那后来的话，那帮人全来北京了，就全来北京了。不是，是到了70人他们才来的北京，其实是家之后才来的。对他们就来北京了。我看那个早期的报道，你24岁吧，应该05年就已经身家过亿了。反正那时候按照过，那时候按照互联网的泡沫的PE算，就是你有一个收入有一个利润，然后给你三个那个市盈率，三个是市盈率来折算出来的。还有就是你很早这么年轻实现了可以说是中产的财务自由，我这个对你后边的持续创业和整个人生，你觉得就是你今天回头去看，有什么特别明确的正面和负面的影响吗？没有，是个中性的，是个很中性的。这个很中性的，因为这个财富也是逐渐积累的，所以你没有觉得特别怎么样。是你像就我创业这么多年，其实真正融资是从理想汽车开始了，因为实在太烧钱了。前半都是靠自己挣钱就滚动起来，对，然后泡泡网和汽车之家其实没有融过资。那为什么那个我记得汽车之家后来说是我看到以前的媒体报道，是因为资金问题然后引进了大股东以后被夺权了。对，所以当时的时候也没有融资，是直接卖的股份。还有投资机构如果想买股份，原则上也会让创始团队控股，他为什么买了那么多买了55%？他不是投资机构，他这个大公司他买业务，他需要这个业务，对他要买业务，他觉得你们走了也没问题，对他买互联网媒体业务，他不想你走，然后所以呢他要买一个买一个控股权，所以买55%相当于你们就给他打工了。而且那本身他那笔钱也是我们化解那部矛盾的一个重要的一个然后一个要素。我看到一个好玩的理论是说，计算机革命之后才会出现20多岁成为亿万富翁的这种批量出现的现象，因为在计算机革命之前的传统的那些工业商业时代，财富积累要达到亿万这种级别，通常都是在聪明绝顶的天才也是需要20、30年的时间才能积累，除了因为速度没有互联网和计算机这个时代快。因此原来历史上第一次从批量的出现了20多岁的亿万富翁，那这些人20多岁已经彻底财产自由了，财富自由了。所以除了几个别的人，其实绝大多数人从基因上是不能终生过那种他年轻的时候没赚到钱想象我要赚到钱我就要花天酒地、我要纸醉金迷、我要什么90、90年什么这种，其实是做不到的，因为人需要自己的价值感。所以你整天这么生活，其实很多受不了就又回来干活了。在做的时候钱已经很难刺激他了，因此就会当然还有一种人就是喜欢财富榜上排名，这也是很常见的现象。另外更多的人可能就说不管自己去投身做那些高风险周期长偏理想主义的科技项目，还是愿意出资去资助那些年轻团队去做这些年轻团队去做这件事，都是那个之后才出现的。你觉得这个理论有道理吗？我比较认同。我一向我真正有了现金其实是2008年给那一次，上次不是他收购你那时候，大家装好多不好的时候就比较有钱了，而且都是现金。比较大的一个变化就是买了两三套房子，然后甚至现在住的房子的时候买的，然后还有买了很多车。你自己喜欢车嘛？有的时候你觉得挺过瘾的，对，然后跑车什么也都买了，跑车都买了对。就很多人说你现在买跑车，其实我说我十几年前就已经买超跑了，对，然后所以我就就那么一个变化。然后紧接着就是你想做更大的事了，对，然后当时的有很重要的一个目标就是当时谈得也很清楚，就是整个汽车之家规模管理，这就是他把他收购的另外一个业务也交给了我们管理，所以我和秦致可以管一个更大的团队了，那个团队的收入规模人员规模是我们的两倍，所以我们管的是原来的三倍了。所以就一直在做上市，然后整个的发展的很好，就是秦致反正主管技术，我们技术特别强。在其中秦致是你那个汽车之家的合伙人？还是到北京找的？到北京找的，对，然后实验上合伙人的反正他来管技术，然后我来管然后产品和内容，然后秦致来管整个公司的商业然后整个运营，他是COO，所以我是总裁，然后反正是COO，所以我们三个特别强的一个合伙人的一个体系就建立起来。那个阶段基本战无不胜，我们就从几千万的时候很快就做到了大几十亿的收入。你是不是骑车子鞋子？然后2011年其实就有第一次上市的一个机会，但是好像当时就是因为知火的VIE结构大家都上不成了，所以那个时候因为我的股份很少了，我只有五个多点股份，所以我说上完事以后我就想再去创业去了。对，但是你这么一个想法，所以那次没上成我其实又想走了，因为秦致说你做COO我就可以走了，所以我说不行，你把我招进来对我给你拼，然后咱们得把这场你得把这公司搞上市，然后在那把收入得做到然后往117做对。所以我就说115我没答应，我们做到上市，所以到2013年然后上市以后我就开始其实在外面找机会了，我想下次创业。然后我当时的时候说实话最大的一个遗憾，我最痛苦的一件事情是汽车之家从2009年以后太容易了，没有遇到过任何的竞争，其实有竞争但根本没有能力跟你够从实力上去对，就是我们的整个商业体系内容产品还有技术都很强。对，但是我很遗憾的一点其实我们只放在这个垂直网站上，所以我当时的时候说我要去选择再次创业，多难，我要找一个更大的，不能做这么垂直的，对，不能做那么垂直，不能做一个是容易赢的。所以这时当时我就做了很多选择，我先通过一些天使投资，这还是先实现了财富自由才会有财富自由对，就13年以后我就做了一些天使投资，大部分都打水漂了，对，所以我投资肯定不行。然后很多时候投资的时候就说他有一个好的想法对，我就投了，但是其实忽视了原来很多人是你自己带起来的，这些人后来成不成其实才是跟什么跟这个事对不对一样的重要。但是看了很多的这些方向，但其实最想做的真的是汽车，但是一直不跟你，有些你做汽车之家也是因为喜欢汽车？把一部分原因。做汽车之家存在市场选择，因为什么已经没有机会了，那时候电脑已经进入负增长了，明白？那时候没有机会了，你在一个负增长的市场你怎么竞争？你做一个老三，因为那时候不会做管理而且浪费生命吗？对，所以我说要做一个新的，就是在旅游然后房地产和汽车两人我们选了汽车，因为汽车是标准品类的，跟这样所以你做汽车之家并不是因为喜欢汽车？但实际上你也特喜欢汽车？我最初是一点都不喜欢汽车，我不喜欢汽车到什么程度？其实做汽车网站，樊铮很长就建议，樊铮是个汽车迷，那时候我们每年都来北京看车展，他们特别高兴，他们车展的时候他们只看车，他们跟过节似的，我要车展特别无聊，我说你今天喜欢这东西干啥？直到2003年在他们的建议下，他们的一个车因为那时候有钱，你这时候有钱不用考虑什么高速发展对吧？其实就是个小作坊，但是钱是能挣的了的，所以那时候我才买了第一辆车，后来慢慢喜欢上车的。然后也在反正你是做汽车之家的过程中喜欢上车？我是先买了车然后开始对车有了解了，然后决定做汽车的时候就特别喜欢车了。你在那个时期就你在整个从想创业到创业到今天整个过程里，或者说早期吧，你有一些什么商业上或者说科技上的这种偶像和英雄人物吗？在那个时期就我们当年不都是看那个什么比尔盖茨吃血的那个未来之路？我一直有两个，我一个是一个是宫本茂？对我也是，我最喜欢这家公司，而且他做的游戏我都喜欢，这个公司挺梦幻的，就很不正常，对对，特别神奇的。然后我我习近小的时候一直喜欢宫本茂对，然后因为那时候你买什么给母集中营什么的数理吧？对这些人物都有介绍的，全玩疯了。然后我人天能任何一代游戏有全买，我那个年代我不知道你，我那个年代那个人天堂的那些板卡什么全是盗版，然后机器也有很多仿冒都盗版，所以我就没用过正版。然后我也不知道正版盗版，我就知道是一个日本的游戏公司卖的，而且那个盗版也都打上日本什么的，所以家里终于给我买一个的时候已经是红白机流行很多年之后变得很便宜了才买的。买完了以后我也不知道那些板卡是正版盗版，反正就全有卖的，我就买回来就玩。然后很多年以后才知道我们用过的全是盗版，是那个期间偶尔用过一两个正版，就觉得这个怎么精美的不正常，因为正常都挺糙的，正常都多少盗盗合一，对，到晚都多了一百合一、一百合一什么二百合一。然后我长大了以后就一直就觉得就像那时候网上大家说都欠周星驰一张电影票，我就觉得我小时候带给我那么巨大的快乐，难以想象的快乐，而且是那么大量的快乐，这个东西全是靠盗版。所以后来买那个Switch的时候，我生平第一次开了那个任天堂的账号，然后因为忙，实际开完了账号，我现在有好几年了吧，可能就是累计玩的时间不超过十个小时。然后那个账号每次想起来我就觉得不取关了，就是它不是定月费吗？可以取消因为你不玩嘛，但是我就老觉得这个是欠宫本茂，然后我就一直在那儿放。所以我对宫本茂的感情也是特别那个什么，对小的时候宫本茂，然后大流行真的是乔布斯。乔布斯你觉得乔布斯特牛是从什么时候开始的？是iPod的吗？还是更早？我就从iPod的开始，因为它被赶出苹果的那个十几年在硅谷被当成笑柄嘛，所以那个时候我对这个人就感受就挺奇怪的，我觉得是个怪人，但更多的了解没有。但是我生平买第一个iPod的时候震惊了，因为我买的时候那时候还没有正式引进，都是那些水货商代购还卖贼贵，然后买了生平第一个第一代就是，我是因为它的工业设计给吸引的，太漂亮了，像一个艺术品就买回去街上电脑把歌倒进去以后我就疯了，我是怎么会有这么好用的东西？它比在电脑上选歌播歌还要方便一万倍。因为我很早就买过Mac，我对Mac没啥感觉，因为那时候Mac确实有兼容性问题和软件生态严重不足的问题，是的那时候我们买的Mac有还有买一个软件装虚拟Windows。对，Mac是变得好用是被iPod带起来了更大的量，有更多的开发者进去以后。而且当时对我一个影响挺大的还要一件事什么呢？就是我人生最喜欢的一部电影是玩具总动员，对，然后我没想到就是它它的皮克斯做的，对对对，它是最大股东。我特别喜欢玩具总动员，因为玩具总动员就是我希望的一种动画片，我就觉得我就是里边的牛仔，我觉得那个感觉太好了，包括后边的话然后皮克斯所有动画片我都会特别扔你那看，对对。所以你这辈子上夜上的或者说做产品科技这些方面的两个偶像是乔布斯和宫本茂？对，包括对乔布斯的这些分析和研究，除了看这些公开视频这些东西，然后我最多的什么呢？我还得去研究Tim Cook和那个乔纳森·艾夫的交叉，因为很多时候就是写的它一定不是那个样的人，对，但是你交叉有发现这才是个符合真实的一个场景。你自己具体自什么？具体自什么？就是大家总是拿乔布斯很早的粗暴然后来举这个例子，但是你从乔纳森那里边看到的其实是一般人怎么在建立信任以后的高要求，不是简单粗暴。很多人比如我们小的时候，我们年轻人比较傻的就简单去学着简单粗暴，其实不是，对，是先建立了信任，高要求，甚至这些脾气啊其实就是变成高要求了。对，但是如果没有建立信任，然后做的很多东西其实就是简单粗暴，这是根本性的不同。因为有了信任，所以大家都有一个高标准的情况下，只要没达到就在那开始吵起来了，对，但是如果没有这个信任基础和前半的合作基础的话，这样子会把事情搞糟，而且它会在信任上花很多时间，会花很多的时间，我也这是非常重要的，这是很多被很多人忽视的，否则会学会学出问题的。那再——第一次创业的时候，为什么会选择汽车这个方向？整个思考的前因后果能不能分享一下？我觉得，当时其实移动互联网和流量相关的机会还挺多的，对吧？至少在我印象里，市场还没完全进入后半场。那你之前的成功经验主要在流量和互联网领域，为什么没有继续做那个方向？而且那一块操作起来相对更轻、更熟——你是想追求一个更高难度、更长期的东西，是吗？对，一方面确实是追求高难度，但另一方面，也得看能不能延续我的能力——我到底能不能赢。当时我在房地产、旅游和汽车这几个方向中，最终选择了汽车。因为我觉得汽车是标品，而我们团队做标品特别强。旅游属于服务，房地产每个城市差异巨大，更多是销售行为，产品力不强。所以，我就选择了汽车。紧接着上市之后，我就开始准备下一次创业。其实我的路径和雷军有点像——先做了一些投资，比如投了汽车后服务、汽车设计公司等等，帮助自己深入了解行业。还投了一些汽车相关的硬件和智能设备。因为我始终认为，汽车是一个超级大的行业，工业制造里面规模应该是最大的，仅次于房地产。这些投资让我不断观察和等待机会。对我影响最大的，是2014年4月23号，马斯克给我交付第一批Model S的时候。一开上这车，我就觉得：这就是我想要的。其实在那之前，我已经是电动车的早期用户了，买过宝马i3，也开过雪佛兰Volt——那时候很多人甚至还没听说过特斯拉。在特斯拉量产成功之前，传统车企也做过电动车，比如宝马的i3是纯电的，但续航只有200公里，更像是个实验品。通用的Volt是增程式的，其实是被政府推动的——他们当时拿了政府救助，必须做新能源。我一开始开的时候还觉得“什么破玩意儿”，但后来发现增程技术其实很有意思。所以我比大多数人更早接触了纯电和增程两种路线。那个时候，全世界有没有哪家增程车卖得特别好？没有，都非常边缘。那你决定做汽车，有多大程度是出于对汽车本身的喜欢？我对汽车确实很了解，也和中国很多车厂老板很熟。但真要去做车，又是另一回事——我跟市场、公关层面熟，和研发体系其实并不熟，所以基本上还是从零开始。当时开完Model S，我的感觉就是：这就是我想要的。而且我发现，马斯克原来也是做互联网的，PayPal出身，他能做，我应该也能试试。于是就真正开始规划了。从一个互联网背景的创始人转型做硬件，你不觉得这是一个很大的挑战吗？事实上，全世界从互联网成功跨到硬件的公司，除了特斯拉，几乎就没有第二家。雷军勉强算一个，但小米早期其实是从软件和系统切入，后来才靠硬件走起来的。有一次我听人说，这几家手机厂商虽然很强，但严格来说不算互联网公司。因为他们手里握着一个硬件入口，每天有上亿人使用，如果他们真想做互联网应用，直接预装或强推就好了——但华米OV这么多年，并没真正做出一个国民级的互联网应用。有人觉得，他们自称互联网公司，更多是种包装。你怎么看？我个人觉得，这种说法有点像“守株待兔”。用户在选择高频需求时，永远会回归到自己真正的需求是什么，不会仅仅因为你有一个入口，就自然接受你的服务。就像早期大家觉得，微信做电商肯定能成——其实没那么简单。我还有一个角度：不同的事情，所需要的组织方式是完全不同的。我自己既做过纯互联网公司，也做过智能汽车，这两者的方法论和组织架构根本就不是一回事。全世界科技公司的组织方式，大致可以分为两类：一类是强流程驱动的，比如华为，适合复杂硬件和系统工程；另一类是强人才密度 + OKR驱动的，比如阿里和Google，适合创新、平台和AI类业务。两类各有优劣，我们就在想，能不能把两种优点结合起来——用高人才密度做主体，同时把流程工具化，而不是被流程绑架。这就有点像AI发展的过程：一开始很多人觉得基座模型能解决一切，后来大家意识到，还是要让模型学会使用工具。人和工具，从来都不是互相淘汰的关系，而是协同。说到这个，我记得OpenAI刚推出GPTs的时候，有一种论调是：以后不需要程序员了，也不需要产品经理了，用户只要用自然语言描述需求，AI就能自动生成应用。但我们公司内部讨论后认为，工具和交互的价值短期内根本不会被替代——好工具和差工具，差距是天壤之别。如果真的完全不需要人机交互和产品设计了，那我可能就得退休了。至少十年之内，工具、应用和人这三者，都还会持续创造价值。我也同意这个判断。再回到最初团队搭建的问题。你从互联网跨界做硬件，最初是怎么组建核心团队的？我受益于之前在汽车之家有过非常互补的搭档，比如秦致和樊铮，虽然他们没跟我一起来做理想，但我很清楚——必须找到能力互补的联合创始人。所以我第一件事就是先找合伙人，尤其是在我不擅长的领域。比如硬件供应链，我完全没经验，就只能从科技制造业里找——当时我觉得只有华为和联想的人符合要求。华为的人根本接触不到，后来通过朋友介绍，认识了联想全球供应链的负责人马东辉。他做过联想和IBM的整合，管过日本、巴西、印度的工厂，实战经验非常丰富。他来了之后做了一个特别关键的建议：第一款车全部用大厂供应商。虽然贵一点，但不会出大错，而且大厂不会轻易挖我们的人——因为早期根本没量，他们看不上。等之后规模起来了，我们再逐步引入第二、第三梯队的供应商。这个判断对我们特别重要。如果一开始就选小厂，风险会大很多。而且从品牌角度讲，全用大厂供应商，也显得配置更靠谱。吃什么回扣这样的，因为公众链，他说公众链都是很腐败的，明白吗？那些小厂上来就会腐败。你是找到公众链的这个负责人了。然后第二个比较难的是什么？其实是研发。然后我不懂研发，对。那所以你不怕软件，不怕硬件研发？软件不怕，对。然后那所以在这个整个的整车的研发的时候，我就觉得这个人得有一个能力：交管团队，并且有交付经验，要做过完整的交付，就从立项到最后交付。对对对对对对，对对对对对。我想要的什么？我想要的找一个人，他是个真正的、一个运营者、技术出身的运营者，对，技术出身的一个运营者。对他不要有任何技术的……然后这个，而且最后他做超大项目管理。对，然后我发现这是我想要的。我就面了几个，院长朋友介绍了几个，而且面的时候都很奇怪，就是很多元贩都是特别奇怪的。我当时投了一个HOD的，然后一个创业公司，就汽车上了HOD的公司。过程那个小孩是家舟，然后设计学院的，所以他其实是学汽车设计的。他现在汽车上了做汽车设计，他自己想创业做这个。他那个虽然没做成，但他帮我推荐了我们第一个设计师。我说我想找90年的设计师，我不想找岁数大的，然后最后在豪华品牌里工作过几年的。所以他就给我介绍了我们的设计总监那家。然后我又认识了那家在中央美院的汽车系的老师，然后汽车系的老师给我介绍了一个人，他们原来一起工作过，在汽车公司里，然后就认识了马东辉。所以面试马东辉，这就是我想要的，跟我想要的完全一样，你们交流想的都完全一样。对，那时候他在长沙，而且他在汽车公司也干过，那时候他去了那个三一重工的研究院，然后到院长。两个以后说，这就是我想要的。多大岁数？他是79年的，比你大得多，对对。车当然得有做，他有做过几个完整车的经验？因为这设计生命安全跟设计的比较好，带过大团队吗？然后两万以后，然后我当时问他，我说你在这的工资多少钱？他说工资大概一年下来一百多万。然后我说我们创业公司，我当时就觉得这个人就是，因为我面了很多了，我面了就有二三十个了，面了多了你就知道研发什么回事了，你就不停就去问他嘛，开放进去问题，什么是个好的研发？这样的。他当时其实早期的面试很多是上免费课，被面试的人是过来跟你上课的。所以我有时候新的领域不懂，面对人其实是会招一个的。但是那些给我上课的人，我等他们走了，心里隐隐的有一些愧疚，就是我不是故意让他过来给我上免费课，我确实要招，但我可能面了二三十个最后招了一个。我就觉得那些人给我的课有一些也很有价值。当时我问他，你要有多少钱工资？他说咱们创业公司，你一个月给我两万，我能生活下去就可以。我这样讲是我爱挺真经的这个创业精神，太猛了，特别好。他是对你要做这件事完全打动了吧？是。然后我当时我当然问了一个问题，说你心中最大的追求什么？他说我先我做的产品，人面的朋友然后都在用，介绍到处都是。对，他说只要这件事能做成了，我这一辈子就值了，这个是最大的满足感。你也是吧？是。你看我手机没成，然后我每次听这种就受不了，特难过。然后我真正做的满地都能看到的是，我们当时跟厦门的一个做箱包的公司合作，我们是小股东，他们是大股东，我帮他做了早期的设计和前期的发布会，然后后边就没什么太管了，他们有事就找我，没事就不找了。这个箱包现在在国内是排前三的，所以我去机场老能看到，叫level 8，中文叫地平线，我听说过。对，就是那个轮子上那时候我们原来设计总监给做，轮子上有两个不在圆心的小黄点，所以你推的时候那个小黄点就不停地跳跃，视觉上特明显。机场满机场都能看到，我每次机场看到那个箱子就特别高兴，就觉得我做了一个产品一样，里做了一个东西，现在中国有这么多人用，上千万人用，所以那感觉特别特别好。所以你们汽车这种这么大的东西，如果满街跑的话，那个满足感和幸福感应该是特别强烈的，我真羡慕这个。所以当时的时候两个最重要的联合创始人其实就找到了，那个人其实非常非常重要。用了多长的时间在那两个人？因为大概三四个月的时间，就是不停地找人、不停地见人。而且我到今天为止，公司的18级以上，18级、18级以上我全都面试，全都亲自面对。因为对AI领域、对芯片、对操作系统，很多这些东西的了解都是没来的。我这件事什么时候开始收益呢？我这件事情是在2006年我们招财务总监的时候。对，然后当时是ID系的朋友说，你应该找个财务总监了，你不能天天靠中关村的会计每个月做一次账。所以我完全不知道财务总监怎么回事，所以那我说你给我介绍一些，我就见了好多的财务总监。第一反应就是什么？财务总监不就是个大会计？对，很多人都那么说，我看了一层楼上后来我就开始问一个问题，说什么是个好的财务总监？什么就没有公司财务好？慢慢他就开始讲的越来越多了。对，直到后面招到了李铁。我是2006年就招到了李铁，你是在汽车之家期间就跟李铁做了合伙人？是的，但是他不是合伙人，他在理想汽车才是合伙人。那为什么到了他？除了我特地明白了财务是怎么回事以外，然后我还明白知道200年事，就是你招的财务总监必须特别关注业务。当然其他的财务总监老用什么时候上市啊、什么OTCBB啊、那个借壳上市啊什么的，只有李铁全程关心业务。对，我觉得这个其实完全不一样的。所以你跟他已经合作十来年？是，多年了，快二十年了吧，2006年。所以这几个合伙人都很扎实。然后供应链负责人刚才说过，销售渠道这块呢？你自己不愁这块还是你这块本来就懂？有赛事还是销售渠道多少会懂一些？对，所以销售渠道的开始我管，后来其实也交给谁啊？男来管了嘛。对，就是还说我不太上上运营。还有很少有性格上或能力上擅长那种精细化运营的人，同时非常有创意、非常有创新或者非常懂产品，这个是完全不同的两种能力，在一个人身上出现的概率极低。所以后来像谁啊？男走了以后，然后最重要的运营工作又回到了马东辉身上，就他把整个供应链全接走了，管得很好。最近他又把销售接走了，销售也能接。我公司有三点四万人，然后马东辉管三点二万人。这个人刚才是说在那个三一重工工作对吗？对，也有十来年了。理想到今年是十年了，2015年加入的，十年了，十年了。市场营销这块呢？市场营销那块我们就找了几个，其实奔驰宝马的朋友，传统车企的。对，传统其实是长长的，然后走到现在还是那批人吗？也换了一些人了。你觉得你们公司市场营销做得好吗？我就符合我们的阶段了。你觉得这个阶段这个水准的营销团队就够了？因为我们的销售、我们的销售收入增长得快。对，所以很多人总是说你为什么不按着那个更大规模的公司其实来做？对，但是我觉得我不是指营销团队的规模或者是这样，我就不是规模，就是操作方式。对，操作方式或者一把手。然后其实我们正式卖车其实只卖了五年时间，然后这个过程中其实用户的积累什么的其实我们也都是个程量过程。虽然他们过去在这些大品牌工作过，但这些公司都一百多年了，然后重新创造一个品牌到底怎么来做，其实还是要重新学的。对，因为他们原来那套其实到这个公司里，如果不学习转型的话也不好使。是的，是的，因为其实你阶段不一样，对对对对。而且他们在那些大企业里，那个品牌已经有光环了，你其实在前边讲好的品牌故事实际上是填砖加瓦，对对对，完全不是从零的。而且他们这些品牌怎么形成那些关键转折点，其实他们本身也不知道，都是后来人写的故事了。所以你们工业设计当时找的人到今天也是他？对，他在，但是他非常有意思，他虽然很年轻，但他敢用别人，所以他基本上现在是一个非常强的中外混合的一个团队。那你们设计团队有外国人吗？我们一半以上的外国人，他们工作都是英语。那比如说每款车的主设计师是谁？最终拍板的那到最终决策肯定是你在，你之前在设计部门是他来拍板吗？我们内饰的负责人是个中国人，我们外饰的是一个德国人，欧洲的，是欧洲的。所以这个国际化的过程中，团队沟通啊什么这些没出什么问题？没出什么，因为他本身也在像奥迪啊、然后像E-PhanyV这样企业工作过。因为我们招的那派国内的也都是在后来有那些大品牌的车企的经验，然后是在海外的，有的其实是在他们国内的设计中心工作的。所以需要语言很顺畅？是，而且他们只能找这个人，他招其他人，他们没法在一起沟通。你们汽车工业设计团队现在有多少人？现在应该有七八十人吧。因为我问这个问题是因为车企不像手机，手机一年一款嘛，车企这么多年十年也就是几款嘛，是那么大的一个团队，其实他们工作是饱和的吗？我就存好起来非常饱和，因为他要设计一大堆，从里边挑出一个，还是有一些所谓的工作。今天你过去，今天两年就得改一次款，而且其实复杂度还是很高的。当然，当然，其实比手机复杂度，因为现在大家有一段时间大人可以靠数字化、靠VR来一眼正，发现其实根本不是那么回事，因为他跟建筑是一样的，你在那里面看到的真眼看到是不一样的。因为他们要一边设计一边做数字化验证，还得做其实物理的验证，对，得把模型搭进来，对对对对，一比一的搭出来。我们说一下你做的几款车，我们大概里边就提到理想ONE吗？你当时这个问题可能很多人问过了，但是我还希望我的听众听一下，所以我们还简单说一下。你做第一款理想ONE的时候，当时是为什么选择了增程式？因为那个时候有比较流行的观念说这是落伍的旧技术，然后，当然我不知道这次科技界的普遍共识还是你的竞争对手放出的共识？我们说的是个访工程师。对，所以你们做这个之前不是做了之后被你的同行去抹黑，而是本来科技界就认为它是个落伍的技术？是的。那你是怎么做前期调研的时候发现实际上它是一个核心经济力？其实就是因为充电桩不够吧？其实说实话，我从来不做前期调研，我觉得跟所有人想象的都是不一样的。那你怎么做这种判断的？对，就是我有我电动车真实的体验，你充电焦虑始终是一个巨大的问题。对，然后我甚至可以再往上延伸一下，我觉得泡泡网没有成功，我们一直是个千年老三，最大的问题是我们头做技术，我们的技术做得特别好，显卡的评测你肯定看过，对那些所有的细节啊、对什么像素的这些分解我们都是关于做得最好的，一个显卡评测五六千字，每个技术给你讲到想得后者就几次高天测量特别高。对，所以很多程度上有点做得有点自嗨。那所以呢？包括我们在创业的时候，如果进入汽车领域，我们得先看其中一最大的问题什么？就是我说这个行业我们要进入，说一定有些问题没被解决。所以我们当时发现汽车行业然后就是巨大的问题，就是第一所有媒体写的内容都不是真实的，因为那是个卖方市场。对，然后第二大家所有查的图片和资料都查不到的。你们早年做泡泡网的时候写那些评测，那时候还是挺干净的吧？对，干净，真的就是独立客观第三方，独立客观第三方，然后因为大家喜欢PC的那种热情，用进来自发看，你们靠广告就能活得很好了？是我们纯粹指服务发招勇那时候。然后这个其实我还挺难过的，因为有些行业先就全靠写软文才能那个维持。到了我们泡泡网到后半，是因为我们是第三，给人家老大老二然后都写软文，你不写软文连测试的样品都不第一时间给你，写不到这种程度了。所以我没会写写软文就很恶心了，就做的不想做了。做汽车之家从来就没有写过任何的软文，明白。然后呢，做汽车之家有一个很重要的就是，我要站在看用户市场的需求，就是技术很重要，但是必须得看然后用户和市场的需求，然后怎么能让大家看的懂汽车，怎么让大家看的真实懂汽车。等一会儿汽车自驾的时候，那些评测是用报告什么全身你们自由团队写的？自由团队写的，自由团队写的。而且呢，跟泡泡完全不一样，比如说过去的时候大家的写车内空间多少，给你一个多少多少毫米，我们不是，我们会告诉你然后你坐在这里，前面还要提前，对对对对对对对对对对。然后呢你放在这个杯架，不是杯架多宽，是能放可乐还是能放脉动，我们全变成这样方式来写了，所以一下就大受欢迎。那其实相当于这是一个正反馈。所以在做理想汽车的时候也是一样的，首先正反馈来自我自己，就我要看这个行业最大的问题。那所以我们当时的时候看到了看到了一个机会和两个问题。然后一个机会什么呢？我深刻的知道，因为我做泡泡网的时候，当我明白怎么去管理一家公司的时候已经晚了，然后整个的电脑硬件已经进入一个衰退期了。所以在一个市场不增长的时候，如果你想去过的成功，那个太难了，就老大就是掌握的所有的优势。对，然后就增长嘛。对，那所以当时说做汽车的时候，我要做增长市场。但是其实进入了汽车市场的以后，一样的问题，其实汽车上增长并不多了，就是我们如果在这边找到一个增长市场，那我就自己比较敏感。然后是发现二胎，因为2014年还是13年放开的二胎，几个省份立刻就长了，那这些人其实开始需要六座车了，所以我们得做个六座车。但六座车能用不能是MPV，因为那时候MPV都是别克GL8，那因为大家觉得开着像司机、像公司商用车，不像家庭用车，因为别克在GL8做得太成功了，路上商务舱对吧？那就是推理的全体，你看到坐在那里你就自己本能觉得自己像个司机。对，那我说怎么做一个六座的SUV家用车？那时候你能买到三排的比较空间好的SUV，我印象就是奔驰GLS，都100多万，还有加价，那不是买不了。比较合适之外，能不能30多万买一个？所以这是当时给自己出的一道题。同时又看到两个问题：我们只能做新能源的原因，我们不能做燃油车，资质也不允许，国家也不允许，我也做不过人家。我们就在想，其实电动车其实并不难，因为SUV几个大车跟SUV没有区别，电动车其实并不难的，就跟我们今天做纯电动其实上来就能做到最好的水平。我们再看这个问题，我自己在使用问题，我当时开的特斯拉的Model S。那时候，高速服务区那个Model S的续航是多少？我当时买的是P85，然后续航是500多公里，然后冬天的话其实只有200多公里。对对对，那时候也没有什么热泵，啊，是这样的。所以我印象最深的一个感触，真实的感触就是：我开那辆Model S去得最远的是固安水镇，对，当时参加的是一个基金的会。再远就回不来了，对。而且印象特别深的是，基金会当时的时候，我去听那个基金会，然后坐在台上讲的，三个人印象特别深，是张一鸣、王兴，还有左晖，对，特别真正地听他们在那台上来讲。然后回来的时候，中间有一个地方显示有充电桩，进去发现不能工作。我当时就把我吓到了，因为那个续航剩非常少了。你记得那些新闻都是马路上几个车没电，人在推那个车，对，而且那是冬天，对，那车只能跑200多公里。而且当时来的时候就没有充满，因为觉得中间有一个充电桩是可以用的，所以回去的时候完全命好——为什么呢？因为固安水镇回去的路上是下坡路，所以对电动车特别好，所以我的续航一直到开到了北六环，续航没有任何下降，然后顺利回到家。剩十几公里我就发现，这个问题必须解决。而且即使不出这种事，你其实心里永远是焦虑的，那时候电桩太少了。而且我当时还说的事是，你怎么可能一家人出去玩的时候，所有人等着你跟着你小充电桩？而且那时候充电速度很慢，所以我说这是我们看到的一个问题。好，另外一个问题是太贵。我买那个P85，100多万，对，那时候电池价格下不来。但它的乘坐空间其实就是一个宝马3系，就是一个宝马3系，我电动版本的对吧？这对于普通人哪受得了？但是我又不能赔钱卖，原来大家都是赔钱卖，我融资难。所以我们上来融资很困难，大家说你做增程，我又不投了嘛，都这样的。因为主要是因为我过去没有融过资，我的投资人对这个也都是偏见，都有偏见，对，都有偏见。所以我说其实我怎么把成本降下来？因为我之前用，比如说大电池小电池没法连接，把增程器的控制方式都是有问题的，所以我们就把这个增程进行改造，然后去做。其实没那么顺利，以上我们选的增程器都是错的。那这个过程里，你对内部团队就没有说服问题吗？如果当时大家对增程都是那么大的偏见，当然有了。团队说一定要做PHEV，是因为不能做增程，你怎么说服的呢？因为那个时候你已经不是带着一帮小弟了，也都是一些分量很重的那些合伙人，他们就是反对的声音很大吗？怎么说服的呢？我用了一个比较意外的方式说服的，有点连哄在骗，对对，这也是CEO的必修课，对，连哄在骗。为什么呢？我让他们看了一件事情，其实完全不一样——就是在日本销量最好的车是日产的一台Note，用的是增程结构，但它用的是一个不到一度电的，然后不能纯电驱动的、纯粹的一个增程结构，全程都要增程，但它很平顺，动力分身边，开起来像个电动车，但是它其实并没有电池形式的那个电池，只是中间做一个功率放大器来做电驱动的。所以让他们说，你看在日本已经获得了，已经销量最好的，超过了普锐斯。所以慢慢他们开始来相信，我说你们至少去做一些研究测试，对，最后慢慢的就在那里。你们买了那个车拿回来当原型车研究吗？没有没有，结构完全不一样，结构完全不一样。你就拿着一个成功案例去忽悠他们了？是的是的。而且我们上来设计的是一个纯电结构的增程，不是那个结构的。我们先做了一个相当于先做个电动车，只是在前面把那个放进去的。你刚才说研发过程其实并不顺利，除了多大的工程灾呢？过程中我觉得第一个工程灾是，你看理想ONE用的是1.2T，因为增程一个最重要的一点是，你要在一个很好的恒定的转速范围之内提供功率。所以我们最开始认为一个1.5自然吸气就能满足这功率就行了，但是真正上车以后发现是个灾难。为什么呢？因为它的转速达到比较高，它达到4500转，但是你4500转其实你有个变速箱，有一个变速箱体系的。其实这个转速那么高的时候，其实噪音没那么大，但是如果没有变速箱，它是个没有负载的4500转，那彻底受不了，基本就是这个灾难。所以我们都已经研发完了那款增程机，都研发完了，最后又把它推倒重来。那时候时间很紧了，如果按了正常机的上下，根本没法研发了，所以我们就又去在市面上找，谈了很多家，谈了一个1.2T的，这种机器装上去的。那你整个过程里，按原来规定的，延迟了多长时间？还是按原计划就交付了？还是按原计划就交付的？那这个很厉害。那不算特别大的灾难？是因为我们2018年10月18号开的，那时候我们得先开一个技术发布会，技术发布会先预热一下，2019年的4月份上下车，大家就能订车了。而且那时候订车以后也都是半年以后交付，因为特斯拉都这样的，对，所以基本上到年底我们就交车了。但一交车就遇上疫情了，2019年的12月，12月15号交的批量车，全赶上了。赶上大家都不出行了。是，那你们其实大家很愿意听创业者故事里就是所谓产能地狱那个阶段，你们对你那个发布完了预定是很好的吗？预定还不错，还不错，对，达到我们目标了。那交付的时候就很多退车了，你赶上疫情啊，因为大家也不出来了。是的，退的比例高吗？挺高的，退了一半吧。当时资金没问题？最严重的资金问题是在那个理想ONE发布前也发布后？19年初发布？什么时候发布？什么时候来的？我们是2018年底发布的，2018年10月。那要量产的时候资金不够了。然后因为那时候同时遇到两个问题，第一个问题是特斯拉当时跌到只剩300亿美金了，那时候特斯拉要破产，那时候风向标嘛，对，那时候他都要回购公司了吗？对，然后所有人都在做空特斯拉，疯狂做空特斯拉。我记得那个第二个问题是，因为那时候蔚来汽车表现很好吗？蔚来汽车上市以后也是，低破发行价，从当时发行价我印象6-7块钱，然后一直跌到了一块多钱。而这时候是我们需要融资的时间点，但大家也不敢投了，大家就不敢投了。所以当时真的见了150个投资人，而且为了把那些投资做好，我们还请了高盛做的FA。对，所以那个时候是特别难的。而且那个时候最难受的是我病了，我活到那么大，第一次病了最严重的一次，症状是转，症状是没事转，症状没事，然后见完以后要在休息好长时间。是在这一波融资的全过程都是这样的，然后整个印象特别删断。然后最后那个钱根本就融不到，所以我没招了。当时因为我们前面几轮那是我们的C轮，C轮投资投我们最多的其实是张勇，就是经纬张勇，说我们也补不了你后面需要那么多钱，因为我还是一个VC，总是GPE中前期的，对。所以我们就把我们叫到他在大观展旁边的办公室，然后高盛的总监也去了，高盛中国区总监也去了，说分析了一下说没什么招，你市场就这样，然后说理想你还有多少钱？我说我唯一多少钱，反正以后我肯定都放进去。那时候你个人钱已经都放进去了？都放进去了，一分钱什么办法？赚的全人力了，全人力去了，基本上一分钱不剩。你应该接触还很大，钱没有白拿？我没有拿过任何股权，第一天就开始放钱拿的，对，就是我的所有的股份是我拿钱买的，跟别人平等着买。那你早期合伙人也都是吗？早期合伙人是买一半送一半，对，他们是有期权的。去天使我又没拿过，明白。然后没有原始股，我知道了对。最主要就是一个状况，然后所以当时的时候，那时候张颖说那没办法，理想你还是认识一些有钱的朋友，你就去想办法，有钱的朋友看还有没有一线生机，见上一大佬对。所以我就见几个上一大佬，有一些拒绝的我就不说了。然后其实我拒绝的特别多，你想听你不点名字就好了，有没有好玩的？因为咱们节目也不能太远，可以啊可以啊对。有一个跟我们合作最多的，其实最后拒绝我们了，对，是你们合作商的老板？对，很重要的一个合作伙伴，然后拒绝我们了。这个然后也见了见一鸣，然后开完了以后，他们决定要投，对，但是投了不多，投了3000万美金，因为那时候我们肯定要一亿美金的，股份对，但是他还是说比较认可我们，投一点，但他们当时也没有那种大手臂的投资，对，那是字节没有今天那么辉煌。当时一样的人去见一个好人，那是那是我人生最惨的一刻。其实从节目效果上想听听你被羞辱的那一刻，我可以跟你讲被羞辱的，对。最惨的一刻是那时候坐着飞机去，因为那时候疫情已经开始了，所以去的时候还是很麻烦的。那所以呢？我当时的时候到什么程度？就下了飞机以后已经走不了路了，我在机场找了一个角落椅子躺了一个多小时。你是自己出差？自己出差，因为同时间先到了。所以呢我最后打电话说我不行了，你过来，然后助理就找了一个朋友的车，然后过来接着我，然后我们去见那个投资人。那时候他还这么聊啊？没有，就是你聊的时候又会变成另外一个人，我聊的时候会变成另外一个人，我知道你肯定有过这种感觉对，无数次，就无论多么弱，但你到那个场里有这种。所以我之前是特绝望的感觉，腿都是软的，进去就跟没事的激情表演来消失，对，经历过无数次是。然后所以呢，但是那个那天见的其实是他们一个老大，然后带了一个他们硬件方面的，然后负责投资的，基本上是一个被羞辱的过程，他全程过来过程证明怎么不行，对吧？而且那个公司当时也挺辉煌的，所以最后其实他为什么那么代要见你的？那些现场还见到刘江峰了，刘江峰也去找他们拿投资，全程关上了你被羞辱的过程，基本上可以这么说吧。见到那是我第一次见刘江峰，那他还在做黑鲨手机呢，对吧？那我回头细问他，是的。然后我最后见的一个人是王兴，对，太感谢他了对，这个事这个故事大家都知道了。为什么会感谢他呢？对，因为我们B轮B轮期去了，他人家要投手你还没要，对。然后我我们我们B轮的时候为了跟滴滴合作，其实那时候每天要做打车业务，对，所以其实王兴和滴滴好几个人来找我们，还委托很多人找我们，希望来投资我们，我们都没接受，开得条件非常地好，我们把他们拒绝，但这也正常吧对。然后呢只是到后边人家救了你的命的时候，这个感觉就不错对。然后怎么说呢就是当时我见的时候没有什么，我就是已经绝望了，所以我说最后我还是见一见，因为知道他上路是想要投我们那像自己对。然后这有这有这有这对对对。然后对，然后那时候到什么时候都到时候，你觉得到局上中的时候，有时候你开始对自己的信念了，你只有贵人相助，没什么别的可能性。所以当时的时候，就是你整个创业历史上最大的一个贵人相助是吧？对，最大的贵人相助。然后而且那时候那时候为什么绝望的？美团股价特别差，跌破发行价，非常惨了，还是他们也困难的是吗？他们也当时特别差，所以我就找他试了聊了一下，给他介绍了一下。因为我去每个聊的，一方面讲我们的意识，我们对他的价值，对吧？如果你当时要做运货车，我们能给你提供什么东西？他们计划做运货车来的吗？我们没有想过那么多，就至少我把我们对他们的价值，可能的价值，包括你们想做物流车，我们SEV可以给你提供生产线，这些东西都讲，都会给他讲。然后讲完以后我都没找他要投资，我只是找他聊一聊。然后现在我们聊的地方就是经常在那里遇到你，就是那个什么翻管凯越？那就凯越，就今天大堂，然后跟他聊的。因为那时候疫情你知道，他聊的就是，然后看到地方去不来，我都没提，他最后来说我能投你们吗？我当时就惊了。他上一次要投你被拒绝是几年前？就是二零一八年，就一年前，一年前。他说我能投你们吗？对，那时候你缺口是多少？十几个亿？几十个亿？我们想要三亿美金，美金二十多个亿。然后最后他就自己投了三个亿？好像他们内部也分歧很大对，而且他很多人不喜欢他投资我们，就很多人听说他要投资我们，无数人去说服王兴不要投我们。因为那时候全世界都看出来？全世界都看出来吗？也不是，因为很多人投了我们的，投了别人对了，别人对了，有人投了威马了，对，然后有的人投了蔚来，有人投了小鹏，都去说服王兴不要投资我们。你觉得你融资能力在这些明星创业家们当中算是高中低哪个段位的？融资能力我弟弟下你是最差的，弟下是冰，因为包括之前投资为什么能拿投资？因为我自己投啊，我跟大家签投都跟投，官你把投学啊，所以他们也敢啊，对啊。但到全世界看衰的时候就难了，是啊。我的一个感觉，我的事是什么？压力越大的时候我越往前走，就是没什么压力的时候我后撤一撤，有压力的时候我就，我确实本能往前走，而且很可能那个压力扛过去是一个巨大的转机，是对。那说回生产制造的时候，你们经历过所谓的产能地狱吗？尤其是第一代车的时候，当然遇到了。疫情的时候，然后你还有没有印象的时候，就要汽车半导体短缺对，缺芯片对，全世界都缺芯片，全世界缺芯片。还有有的供应商真的欺负我们，就明明给我安排的生产线给别人。我们最后到什么程度？我们到供应链，我们的我们的真是个供应链铁区，我们这帮人同事我太厉害了，他到供应现场去盯着，如果你生产别的，我躺在你机上，要么你捧我，要么你让我死，你全派人去捧我，然后要么你给我换成我的。就大家就这么这么这么在作战啊。这个这么吓人的？我也没经历过。我们也经历过小企业拿不到东西，去跟人家求啊，或者找中间商想办法，这些都做过，但是那么激烈的还没经历。他答应给我们的生产线排产别的时候，我们的人就躺在生产线上？对，所以我一说他答应了，但是最后又做别人的时候，你们就明白，对对。这么激进的事，但是后面的话这些供应链再不公平这样，因为他反而认可我们的团队人了，对，那肯定是很感人的嘛，是的。对，那你也经历过在那种恨不得在车间里到必定？真的夸张到在车间里睡觉，但是在车间里一定好几个月，最终也都经历。过嘛，我就是没有经历过。为什么呢？因为这一点确实是马农辉和谁啊男管得好——他们都能对。我知道了。而且这件事情有点累，就是他生产经验那些都是没问题的。“有点累死，有点累死”。其实我们一上来，一把分工讲得特别清楚，就是背靠背的。所以有时候在七十家的时候，大家都知道我是创始人，但我不见。其实厂商就是……其实厂商的这些业务什么我是不见的。所以大家又知道，找到情质或者找到小路团队，就能解决所谓问题，不需要找理想。对。然后在这也是这样的，就是供应链然后是谁啊男一个人就能说得算，最高到想让男就能说得算了。所以不需要找理想，找理想也没有用。所以那也自然就没人找我了。马斯克其实去车间盯，还有一个重要原因：他是懂工程的，一间工程的。就很多他招来的那些专家，在底层的那种思维上还不如他。所以他在前线钉，还是有实际作用的。还有另外一个，中国的汽车工程比美国扎实太多了，所以我们从来没有在生产现场担心。明白了，他们工程师断代是一个很严重的全社会的问题。包括他在美国招工程，他只能找到招的都是一些……然后墨西哥一样的人去做。对。中国的整个产业工程非常成熟，对。咱们工程师这些年是特别扎实的，对这个整个训练的体系非常地好。那你当时发布理想ONE，是一个专门的发布会，还是一个大型的车展活动上发布的？两次吗？一次是2018年，然后做了2018年时机就是发布，就是发布。然后第二次其实就是上海车展，这时候就开始接受订单，非常火。就是上海车展的时候，比如他是你们是最火的？在那他是18点，然后观场，然后我们到十九点的时候还有人，就只有我们的亮着灯。最后他们是没办法了，保安来赶我们，所以我说再给你们一个小时，你们是个特殊的。所以始终都有人不走。媒体反馈呢？媒体上反响也很好，也很好。那时候你还没有出城市，所以还那些什么行业露习的那些什么水军黑子都没有冒出来。所以那时候是为小礼嘛，因为他俩都比我先发车、先交付的嘛。现在我们又是融资最少的，然后又做了一个大家……那是媒体也不认真，成没太当回事。没太当回事吗？然后我当时印象特别深刻的就是，首先工业设计我特别喜欢，所以我后来就很快，我是有现货以后开始卖的。然后那个车出来的时候，我印象比较深刻就是你只做了一套配置，那个是在那个时间点有什么特殊考量和合理性吗？我觉得两个，因为传统车企业都不是这么做的吗？不是两个考量嘛。第一个，其实做一堆配置的话，很多时候是个人跟应付勾心斗角。因为我们在许多选择困难，现在其实还能看到说很多车能做十几个配置，但真正两款配置占90%的销量。所以我们当时说能不能其实做一款配置，从消费者角度还有销售理论上，就是如果你让用户有选择困难，有可能会丢单，对。另外一方面，其实是从研发成本上而言，因为一个不同的做意又是个研发费，然后一个不同的配置每个都要研发费，而且都要实验费。小厂刚起步，对。然后我们省进去，而且如果这里边有一个配置，有一个配置只占10%，我跟共产党没啥下单。我太小了，我比如说我一个月卖三千辆，但有个配置三百辆，三百辆，人气怎么生产？人气根本没法生产。然后我觉得这个其实一个是从整个供应链的这个角度来考虑的，一个是从消费者角度来考虑的。我觉得如果回到今天，我们今天那么多配置都不好，我觉得我们很多时候会不会本能的，因为竞争变得越来越像传统节列场上了？我觉得这个其实是我们也是我最近在认真反思的一件事情。但这个其实完全避免还挺难的。虽然传统车企业那个陋习，什么十几种配置然后加一点就多收多少钱，那个挺讨厌。但是你要是完全一个配置的话，有的时候就是一个让消费者普遍接受的区分定价，其实对企业还挺重要的。我觉得现在一个挺有意思的问题，比如我们几乎每一款车都有两到三个配置，但是都一样，然后会有一款配置超过70%。而且还有什么这种状况呢？就是另外两个配置是因为有库存。如果没库存，当然让大家放开了预定；因为有库存的话，销售要有动力把这库存去掉。对，因为有一些现车，要把这个高配啊低配的去掉。比如像Model这样的，有一个Model的顶配，有一个Model的后驱，92%人选Model的后驱。然后Model顶配呢，一些是用于商务，纯商务或者租车，他才会买Model顶配。如果把那页数去掉的话，基本上百分之百会选一个车型。所以今天越来越发现一个问题是说，市场给了你一个选择。如果你不提供那些选择，只提供一个最好的选择，因为提供一个更好的选择，因为你效率更高，你还可以把价格给得更好——就跟苹果的逻辑一样嘛，对，就打一个。我觉得我们很多时候就是随着市场的竞争，有点变得不像自己的初衷了。还是应该回归到自己的初衷。但是这个确定是通过做了一些调整，使得利润——合理的利润——能够被保证，才能做成这样吧。如果因为只做这一个，导致现实的经营上出现一些少收入啊或者什么的，也不好弄。我觉得至少我们证明了，在一些车上证明的，其实其实没什么问题，而且利润会更好的。你现在在售的所有车量里，哪个是单配置的？没有单配置，对，有两三种是吧？对，都是每个有两到三种配置。但你尝试回到原来的那个想法是吗？我觉得随着我们SKU变多，因为我的车型变多了，我得回到原来的想法。这个我一直都不是特别理解，所以就想问一下你怎么想的。因为做着做的，很多时候被竞争带偏。对。如果回到用户的初衷的时候，一个配置，因为提供简单的两到三个选择，其实最好的。反正我买理想ONE的时候，这一点特别舒服。对对，只是我老婆买的时候，她要你们当时有一个什么蓝，很少叫什么蓝。对，比如说我加了一两万块还是多少？你加一万块，对。她就特别特别喜欢那个颜色，然后就加了一万块了。而且你知道，我当时买了理想ONE以后特别特别喜欢，然后回家天天跟我老婆吹。她当时开了一辆Model X，然后一百多万嘛，然后开了不到一年，然后她就特不屑，她说有你说那么严重吗？她好奇了，那明天咱俩换着开。然后我们就换了一天，结果晚上下班一回家，她说咱们这个现在能卖多少钱？就那个Model X。然后我一看，就是那个二手车价跌得挺厉害的，我忘了具体多少了，反正得亏个几十万。然后我说那还换吗？她说换换换。她说开了一天，所有地方都舒服。她说Model X虽然很酷，整个还是体验是差的。她车一些扎实的东西做得好，但就是从特别从女性用的话，每个细节都是挺差的。然后我就问了一圈，把车处理掉了。其实还没拿到现车，她就去买了一个别的车回来。然后那时候因为我太喜欢那个车了，你知道像我们这些至少我这个年代，年轻时候就是最羡慕的，就是满大街跑的那些外国的牛车，特别牛的那些车。然后早期出国的时候，看人家满大街——因为咱们关税高嘛，满大街看着那么牛的车，然后他们告诉我，就在外国留学工作的朋友说，他们车多少多少钱，我们都羡慕得不得了。然后没想到就这么短短的十来年，中国新能源车现在牛到什么程度？我现在去美国出差什么的，满大街还是跑着那些他们那个市场上所谓好的车。然后我们中国的朋友在那看的时候，突然就感慨一句说，我们年轻时候那么羡慕，好像没多少年，现在我们对满大街跑的外国车，脑子里闪过的就是“洋破烂”。这个真的，我说实话，我每次想这个时候特别激动。我好像最激动的是去年车展吧，当时因为什么原因反而网上特火，几个大佬也都去了现场，造了无数的那个新闻话题。那个时候我就觉得，怎么能就不到十年间，中国车牛成这个样？特别特别对，就特别激动。所以我就不知道，就是我们要真的时代机遇充分给足了中国企业家，还能创造多少奇迹？所以我觉得这背后其实有几个重要的要素。第一个，是中国整个制造的底子其实很好，现在扎实的已经全球已经已经非常好，包括那些设备什么的。今天我们买的设备都是中国企业处的那种冲压机也什么的，做得非常的好。第二个是什么的，就是中国各行各业的人，就是比如科技圈的人愿意进入各行各业。比如说我们原来都做互联网，我们来做车了。但是美国其实只有马斯克一个人愿意干这些苦活。美国还是要么在硅谷，要么在西雅图，就是他只能接受我是做互联网、做软件，或者做脏活累活不干，高科技然后赚丰厚的利润，然后舒服。是的是的是的。然后我就这个其实中国不一样，中国人才进入各行各业，什么进零售啊去改造啊，我就这是中国的一个习惯——用新技术把旧产业全改造一遍，这个特别流行。然后我就第三个，为什么中国的新能源能起来，其实跟这个国家还是有很多关系的。比如说中国的油钱在全世界算偏贵的，就是分位置大概价格算七八十分位，对。在中国的电是全世界最便宜的，而且中国的电网基本上是全世界最好的。还有国家这种政策对。我再举一个你可能想象不到的例子：如果你去欧洲的很多国家，你想装一个充电桩，哪怕它国家鼓励，你要排九个月的队才能装上——效率问题。然后如果你可能去像新加坡这样的地方，然后你想装上充电桩，然后你有99%的概率会被否决，一族也会否掉你，会不会见，你不能装，他们有全拒绝这个事情。在中国，你要装一个充电桩，是今天决定要装，然后三天后已经装好了。而且它装上充电桩，乐公司已经帮着物业、帮着电网全协调掉了，而且最后你还晚上还是一个特价。我觉得这些东西其实是完全不一样的。中国它用电动车，就是用车成本的十分之一，但在国外基本上差不多成本，而且便利性差得多。对。所以我去欧洲出差什么时候就看，我说一些刻薄的话，因为我不点名，就我真的见过很多国内的庸才，然后因为家庭原因移民去欧洲的，就是我们以前都认识的，这个跟之底的能力、综合能力特别差，在那儿在华人企业里干点活，待遇什么都特别好。然后我们跟他们老板也认识，说起来说你们这些招的团队好像也不怎么样，我说有几个我都认识，说哎呀你可不知道，我们在本地招的比他们都差太多了。所以说这些到这边都是绝对的优秀人才。所以我就感觉真的，哎呀，现在我们也赶上一个就是这么一个比较兴奋的这么一个时期。把全球性的……如果没有这些什么国家冲突什么的，我觉得中国汽车十年内能把全世界都平趟了。我觉得这几个比较有意思的点就是，我觉得中国的很多时候我们说教育体系的问题，但其实教育体系的功劳也很大，挺重要的。就是其实比如说互联网这一波，也就是说基础、基础、基础教育体系。基础教育体系的小度，我们这一波互联网这一波，真正在写代码做工程师的，其实是以75年到95年的为主，对对对。然后75年到95年的这一帮主力的人才，就是它的数理化很好，也有一位的，其实它做软件啊工程啊，所以说的是运营这些系统啊数字化呀，它是新天就会的，而且有人才足够多。所以我说能进入各行各业，不只是互联网行业，各行各业都会进入。所以我说正是一个中国体系化的优势。同时呢，又接触互联网，互联网和智能手机又培养出来了这些人才，这些人才其实也是汽车数字化的基础。但是呢，如果国外也没有一个互联网精神那么激烈，然后没有在这个智能手机精神那么激烈——除了美国以外，剩下的国家那它其实就没有这方面人才，供应链也凑不起，然后那个技术站也凑不起。是啊对，是啊。你看整个欧洲到现在，没有没有一家能做电池的企业，投了200亿欧元，最后打了个水漂。对，连电池制造不出来。现在全球性的除了中国，然后能规模化造电池的只有特斯拉了吧？我说除了中国以外，有3000mg还有松下，他们汽车用的这个电池也都做了，也做早。对。特斯拉其实不如他们，是生是生是表达我，因为没仔细研究过。之前特斯拉不是搞它那个大型的电池工厂，然后是什么全球最大的，他竟然遇到了很多问题。对，还是他的供应链体系问题。然后他有一个很重要的就是，中国今天就全世界所谓的电池，如果从供应链、上游供应链的角度而言——就不跑去矿，把这个矿加成真正的然后上游的原材料，90%以上都是中国企业做的。然后你做那个理想ONE的时候，第一批用户拿到的时候，出了什么事故或者什么吗？我说的不是什么交通事故那类的，就是他们拿到了以后不满意啊什么这些。还是有很多都不满意的。所以有什么具体问题吗？我们在2020年的时候四五月份，这就出现了一些现象。就是我们当时为了保住安全，是希望撞完以后防止车的轮子挤入到车体，我们一直参考那个沃尔沃做了一个脱轮子的，就跟闭虎一样，就是我撞的时候轮子甩出去，从而避免轮子挤入到舱内。我们当时做的时候还是经验不足，我们做了这个东西的时候，但是把球头那个力做得有点偏弱，因为它是个球头，要从球头脱出去。但是我们做的脱的力比较偏小，所以就会出现有点用户，比如说没有恶性撞击，就撞到马路牙子，它就会脱离出来了。那时候老说我们其实断轴，那时候有这么一个案例。对对对，我这个词我听过，当时是。然后我们就自己拿出来车，就一个自动去反复测试，然后来最后确定下来的那个那个钢度的力，那个球头的钢度。所以我们就把早期一批车我们就承认错误，并把这些球头换了，以后这个问题就彻底解决了。这个是唯一的事故吗？是，是最大的一件事。小毛病其实早期很多的，对，因为它比手机复杂太多了，对，还是很多的。我们第一次做完手机，真是三个月以上的噩梦，每天都是噩梦。是对，我还跑到——我也不懂工程的事——也跑到那个富士康备复工厂，在那门口的小旅馆，我们十几个人然后在那顶了好几个月。整个过程就一辈子不想再进了一次了。对，包括我们早期还有天窗漏水，对，然后是因为什么的？因为我们打天窗胶的那个位置有点偏低了，就在那很吃力，你知道R系列的时候。然后天窗整个安装，天窗打胶都是机器了，就不再用人了。还有就是创业公司刚开始做硬件的时候，果然有经验问题。但是还有一个是你那些大厂做的所有的那些测试，你不可能全部做一遍。我们全部做了，你们全做了吗？全做了。安全，我想象肯定是全做了，但其他也全做了？全做了。那为什么还会出那么多细节？因为我们做了很多大厂现在没做过的东西。你有创新，他们是保守，就做没出过事的，永远做没出过事。对我们做的，他们从来没做过的东西。对，对，对。这个好理解。当时我买了，因为太喜欢了，然后再加上我这个浮夸的，这个言语风格，我就在那儿说“理想L9是500万以内最好的家庭用车”，结果被网友骂得狗血喷头。但是我为什么会这么讲呢？其实那个事是有背景的。背景就是，我当时在南方的时候，一大堆做制造业的朋友，我们因为别的事，密集的有一段时间在一起吃饭。所以，他们，你知道那种，就是比我们还大，我70后嘛，然后他们有一些比我大十岁的那帮，那个制造业的那些老企业家，他们有一个特点，就是他也是环境造成的——就是大家都得开豪车，要不然打不到一块去打球。如果你开了300万的，我开了500万的，他开了一辆比如说100万的宝马，也是豪车，但咱们都是300、500万的，他这样的话，大家背后就说那个王老板，说一件是不是资金不太良，怎么回事？换了一辆这么便宜的车。所以他可能做生意的时候，影响不光是面子问题。所以使得这个群体大量的开那种300到500万，甚至上千万的豪车。然后我因为跟他们有一段密集的商量事，然后还在一块吃饭喝酒什么的，我就把这些所谓的传奇豪车全坐了一遍，结果发现都很差。这也是我，只能说，你不能说这些，要又又又被骂。我当时感受就是，我说为什么会500万甚至上千万的车做这么差呢？然后后来我自己甚至上网动手找答案，看了一些东西，然后大概意思是说，就一个车很不正常的卖到几百万以后，他解决的根本不是交通工具问题，他是解决其他的功能问题。比如说一个富二代，他开一个500万的跑车在酒吧门口一招手，可能就那样一个姑娘上车；但你开一个50万的车在酒吧门口一招手，人家就给你个大白眼。所以他是有这个需求的。还有一个就是我说的那些企业家，他们那个圈子有那个旧式的风气，那你真不敢开50万、一百万的车去，你只能开500万的车去。那这个车有几个全世界知名的那个大logo，一看就是500万的车，那你在这个群体里就没有社交上的不必要的麻烦。我完全理解，就这类的都是其他功能，不是车本身的功能，而且这是他社交成本最低的一种方式。对，对，对。比如你开一辆豪车，要酒店门口，你可以停在酒店门口，是的；如果你开的不是豪车，你可以停到地下去。对，对，对，对，对，对，对。所以他不管是为了生意，还是生活上的虚荣心，还是什么任何目的，他都跟车本身没关系。这个是我意外做了一大堆朋友的豪车以后的这个结论。然后我跟这些老板们说，他们哈哈大笑，他说对，对，对，对，老李，他说我知道你不喜欢这些东西，但我们也没那么喜欢这个东西，我们是工作需要。而且呢，又切老一辈喜好，一个反差。其实在北京的互联网圈是没这个风气的，大家开的都挺不舒服的。对，都挺不舒服的。硅谷不也是吗？那时候大家都开普锐斯那种，就是有电混合的，是那个Leaf、Prius，他们都开很便宜。对，因为咱们也受硅谷的影响，比如说那个谁，那个布林、该辞，对，对，然后拉里·佩奇开的车都很普通嘛。其实后边互联网这一代，如果真开跟那种八、九百万、一千万的，大家背后都说他土鳖，是另一个群体的那个。第一就是，我知道互联网圈是，第一开最贵的车的人其实还是马斯克，那时候他买了一个迈凯伦F1。对，那个是他年轻时候刚爆发，对，就他买了公司以后，对，对，买了一辆。他肯定穷小子有过那个梦想，突然有了钱，那个车130万美金嘛。对，我估计你那会儿，刚刚之前不说买了一堆车，也买过好车吧？没什么，我买了三百多万的迈凯伦就是吧？买个车都有那个阶段，可以理解。当时做了一大堆车，有这个感受以后，过了没多久我买了理想L9，我就真的有那种感受，我就说了，说了，然后当时给骂的。而且那个车评圈好像我要跟他们抢饭碗似的，他们出来铺天盖地说老李懂个屁车，就一直在那骂我。然后我当时还嫌到无聊，还在那还击，就出过一阵丑吧，一堆心气，丑来丑去。然后还有一个是我最后讽刺他们，我说这些认为三五百万的车一定比一个30万的车好的，这帮笨蛋就是根本就没坐过三五百万的车怎么样，只是看它从马路呼啸而过，你根本没坐过。我讽刺他们，我说这帮笨蛋，保不齐人家里边有个游泳池，就在那儿对骂了一切。但是后来我就有一个好奇想问你，后来你们市场不就开始拿我这个话，在后边L系列的宣传里讲了，在L9。对，完了，我当时觉得特好奇，是因为你知道我性格就这德性吗？你们还是做风比较沉稳的，为啥当时用了那个？不怕记着黑着骂吗？怎么想的？这个我特别好奇，一直没机会问你。因为L9也确实是一个很厉害的，这个完全承认。但是我的意思是从市场策略上，你们这么说是特别容易招黑着骂的。你知道我是那种混蛋性格，我就对抗，你们一直都是挺稳的，为什么当时用了？我也是一直招黑着骂的。那你们，我举那几个例子，其实压的时候我知道你那些黑历史，但你们公关部在做策略、发布，为什么的约束不了你吗？他们不太管得了我？给我差不多，对，不太管得了我。但你没我那么糟糕。而且那句话挺重要的，就变成了很长期的时间，各个车企然后就定义方式的。其实真是这样，就是如果那些在网上不懂车、没摸过车、瞎骂的人，真的开一个月的L9，都不用一个月，就一天，L9再去开一个劳斯莱斯开个一天，其实你能承认的就是，它全是汽车以外的附加的那些东西，跟汽车无关。我觉得另外一方面，其实类似这种事我也不争了，因为我得其实压的时候忽然意识到一件事情特别重要，就是很多时候我们开车的时候，总之会说我们明天在右转，这个电动车为什么要停在那个位置，我们要过一个马路的时候，这老人孩子为什么这么穿，这么穿。对，其实如果他没开过车，包括我回想我当时没学开车的时候，对，我跟他们是一样的。对，对，对，对，对。比如说太阳刚刚下山，天没黑透，这个时候其实咱们后来开了车知道，其实两边是很难看清的，但是我当时不开车就过马路，来一辆车，我几乎就贴着他边上我也会听到，然后那个汽车往前走了点，他车贴着我过去。对，然后我当时也不觉得危险，自己开车才知道。对，只有你自己站在一个开车的视角下，你才知道速度和距离之间什么关系。所以我又想，不能怨他，因为他真没开过车。对，对，对，对，对。然后你应该理解这件事。我觉得是关于这件事情以后，我很多事情去理解了，因为你经历，你不能帮我怨他为什么没有经历。不过，对，对，对，对，对，对。所以他单纯从字面上看，一个几十万的车要跟几百万的车比，该还能赢，他第一反应就是你这人太浮夸了，或者你在打破我的、我过去的认知。对，对，对，对，对吧？是。那你都知道，你还在发布会上讲了？我跟什么你没关系，我跟我的潜在用户讲。你是跟社会讲？我没有公开讲，是吧？对，不是我。讲的目的是，我的对话是跟潜在用户讲，因为我们做一个初创企业，对吧？然后我们的从零到一的阶段，就得选出一拨人跟他对话，是不能像今天说，然后小米发布汽车啊或者华为发讲汽车的时候，他已经有个几千万的基盘，他讲话是不一样。是。然后你当时说了，你们那个市场在社交媒体上讲这个“500万的好车就是L9，打过那个500万好车”这个事，没有大规模招黑吗？最后没有大规模招黑？好，早期的炮火都被我扛过了。对，因为L9确实，听L9的上来订单就爆掉了。对，对，然后而且还在疫情的，在疫情的那个晚期的那个阶段，疫情最严重的那个阶段。对，对。所以其实因为L9成功，所以大家就认为这句话也很重要，所以那各个企业就开始学这句话，后边有他们也都在说嘛，但有的就往纯吹，我就是就改写一下“五十万以内最好的”，就开始这么来方式了，对吧？所以你们做理想ONE的时候，是吧？L9已经在规划，L系列已经在规划中了？我们是从2020年初开始来规划L9的，那个时候是理想ONE上市多久？它严格是上市了，我们收到了一些反馈，因为那时候就大厂给我们什么资源，我们就拿什么资源，因为没有办法按照自己的定制，每个人都选，就是因为他现成的供应体系的东西。但我们想一定得研发一个自己想要的那个。理想ONE整个生命周期卖了多少量？卖了二十万量。那创业公司来讲是很辉煌的，从前对，期卖也好，跟我们一百亿美金的时候。然后我想一想好，L系列我没买，我就一直开理想ONE开到了卖L8。对。其实你L9正式发布前，我去你们那个展厅看了吗？你那天有媒体招待会，我去看，我是觉得超级好，因为那个车我特别喜欢，因为他比理想ONE进步太大了，所以我是特喜欢的。但是当时其实很多，因为我那时候银行账户都冻结了，我自己也买不了任何东西，都是公司给我买的，他们也要给我换那个L9，然后有预了一下，我说就不要了吧，后边我再也不差了。然后你们Mega上了，然后我就特喜欢，然后第一时间就买了。但没想到Mega被黑成那样。咱们出说Mega吧，这是一个对你们来讲可能是从公关和市场上是被黑的最厉害的一次吧？其实在L9上的时候就被黑了，但有Mega那么严重吗？Mega那个，我们以前不知道车圈还能拿棺材做文章，所以当时我们是震惊的，说怎么这么黑，比手机圈黑十倍。然后在L9上市的时候，就是我每上一款全新的时候，都会遇到这么一个问题，密集的黑。理想ONE反而是没有，因为大家看你做好了吗，没拿你当对手。对，没拿我当对手。然后到L9的时候，当时就有一个什么状况呢，影响特别深，就是我们在湖州当时的时候，然后注册了一个子公司，所以我们当时在湖州注册的公司，然后后来又不在湖州做了，就把公司注销掉了。所以把公司注销掉了，然后有那么一个新闻是我们在把湖州的湖州理想汽车注销掉了，然后大家就说理想倒闭了，要不行了。对，然后还有当时的时候，然后我们总裁然后卖了一些股份，也那时候也上市了，说套现走人，对，公司倒闭，总裁套现，然后理想汽车就没戏了。所以当时到什么程度？到我们家小区的保安，然后他不知道我是理想，他说这个牌子不倒闭了吗？这么够了吗？对，连保安都知道了。所以那是最狠的一次。我们知道就一家企业操控的。我有一个很奇怪，你们好像每次出公关危机的时候，并不做，我不说还击啊，而且有一些是纯水军和张伙干的那种恶心的，你也不能用那种方式在打回去吗？我想说的是，你们澄清好像也不着急啊。就现在的这个公关理论不是有24小时内必须澄清那些吗？我看你们好像都是不仅不慢的。我觉得一个一个来吧，就是咱那次我们破产，理想汽车倒闭，然后那一次没有秒澄清吗？我们2022年的时候，我们是没有公关。这个这么自信吗？我出企业是因为商业上的无知，然后就没有公关团队，后来被黑的不行。但我比你一惹事多啊，我就我在网上胡来，然后当时一年多吧，就开始有了。你们当时都卖出那么大量了，都没有了？我们只有那种营销，然后没有公关团队。那为什么没有人劝过你们？那些合伙人也有很多都成熟企业来的。因为之前没事啊。啊，我知道了，你说第一代的时候没有被黑的很厉害。对，而且呢，这也跟什么有关系啊，就是跟我们跟我做其实还有关系，我就一直不喜欢公关团队来影响我们。在这个2022年的时候，那时候我们就真的没有公关团队，然后后来才开始建的公关团队。那你们公关团队来了，给你们高管做过培训吗？也做培训啊。对，我也上过那个培训课，课，我吓坏了。是啊，怎么说话，什么对，对，谁能发言，发言人谁。所以我发现你现在面对那个媒体下套的那个反应就非常惩罚了。我就还是因为我做过媒体嘛，怎么种种，我真的做过媒体，明白。所以你还是有一些经验的。我也是，包括你像我2006年，我就被央视啊，东方卫视啊，各大杂志，那时候创业那个《赢在中国》，你去录节目发表？那次我录节我没有发过表。不是有一次，你我第一个阶段的时候，其实就是录这种各种对话节目，包括像《对话》啊，《鲁豫有约》啊，然后还有各种呢，然后顶尖的杂志全上了，因为那时候鼓励创业嘛，鼓励全民创业。对，所以我们四个就变成了变成了榜样，所以呢无数的这种采访啊，所以那时候就没出过什么问题。然后呢，2013年是我三个，那个时候媒体圈也没有这么脏，没有今天这么脏，没有，然后20，而且那时候媒体生意很好的，媒体本身广告就赚到很多钱，对，不就找乐子吧，不用看涨火这么大。然后呢，2013年是，是2013年的时候就我上市的前几个月，去录了一个真人秀的节目，因为你讲这儿，真人秀节目是一天录一十几个小时，然后直曲，然后可能在那边他觉得最有戏剧性这几十分钟。那，那这是我才知道真人秀节目是完全可以断章取义的，特别缺德。但是在现场的时候，他又是一个比赛形式的，你又会很认真，就是赤裸裸的作弊。就是他会请来这样的，就是这个人来了就是说，我们都是一帮创业者，然后会有一个人，会有一个人来说，就过去上这个创业，说这个人一年收入十个亿，我说我，他收入十个亿我都不知道，那你讲二零一三年收入十个亿很溜不起的，非常厉害的。他的疑问，他需要十个亿收入，然后开始比赛的时候，参加所有的环节都是作弊，我就对那个人特别不满意，然后发表也是对那个人发的脾气，题，不讲是谁了，跟你对节目主持有什么勾挟MIC？你们不知道节目主的环节，穿上他们商业世界可以不择手段这样的，一样的，marriage该上祛祖导做节目。对，那我就也没什么办法，但是我当时就是情绪失控了。你没有情绪失控对吧？你就愤怒指责？对啊，但是被抓拍就是大事渲染。对啊，因为你们肯定知道这有节目效果。对，对，对，对，对，对，对。而且最好不要还原前后，还原前后就没有节目效果了。其实很大程度上就是我们长大的时候，都没有特别刻意的去迎合或者委屈自己来或者生存，所以一直到长大以后也是，就是比较直嘛。那种场合就是，他就是充分利用你这些性格特征。所以我去，我也很多这方面的恶心事，今天就不说了，就是真的就。关于原花事故这种呢，可能一辈子也学不会了——但是不学会也过得挺好的。我后来给我自己一个定义：我不会去说谎，我也不给他们一起去造假，那我可以不参加。对，还有面对工作也是，老话怎么说？假话全部说，真话不全说。也只能是这样，没办法，就是会考打的。所以后边也会聊到你这个例年被黑的那个清单，我还拉了一个网友做的，拿出来一会儿跟你对一下。然后我还有一个问题关于MACA：就是这个车我记得研究了三年——研发三年，是三年吗？是。然后它为什么从你们的整个布局上是排在I8的前面？因为MPV并不是一个很大的市场，然后为了这一款投入那么多年的研发，整体是什么一个考量？我们当时的时候想过做一个系列的MPV，所以它是系列MPV的第一辆。但MPV本身不是没有很大的一个市场吗？我还希望去改变一个市场。就跟其实你想在这个领域里造出一个东西，让大家——比如说你们核心是打家庭用车——看中国人能不能因为一个MPV做得很好、很酷，就接受家庭用MPV了。而且启动这辆车的时候，我已经有四个孩子了。对，这张车启动的时候我已经有四个孩子了，所以我基本上六个座位来自，我做不下去了，还有一个自己的需求。你这个好像是全世界唯一一个第三排那么宽敞的MPV吧？我不知道，我没开过全世界，对吧？对对，空间最好的。就是还是想做一个极致的产品，所以这是当时的时候开始规划好几款，其实就做了一款产品。然后这个车是你们创业过程中被黑得最狠、最惨的一次吗？是。那我知道你那些能扛，当时内部有没有一些恐慌或者是焦虑那种？就是团队内部，因为你看像那个研发团队三年呕心沥血做出来一个结果，上市被黑成观感特别差，所以你谈起来特别伤心是吧？设计谈得特别特别伤心。我跟能想象。对，然后我想象那个产品如果是我主导三年弄出来的，真的太难过了。而且很多人建议我们立刻改造型吗？都会有这样的一些建议。而且当时的时候其实赶上了一个特殊时间点，就是包含中产阶级和我们，然后在那个时间点就是被整个流量推起来了。原来流量里不能讲的都排掉以后，就得搞这个了。对，就更有流量了。而且呢很多人，你仔细看看今天，它也不是真的——你说十年前那些黑媒体，黑媒体是黑了你以后然后找你要钱；现在的方式，瞧账是现在是拿你的竞争对手的钱。不是，现在是拿你做流量，靠流量变现去了。因为那时候本身就可以变现了吗？所以它也不一定是很多都不是其他行业的，所以它也不一定是拿钱干坏事，不是哪些干坏事，它就纯坑你，但它有流量。但背后肯定是有一个公司在幕后操作的，规模化的操作——规模化的操作，就连人都被抓了吗？但当时有一个理论我觉得挺好玩的，我不知道你怎么看这个理论，我也不知道你看没看到这个说法：其中有一个理论是说，黑肯定是缺德的，不管什么原因，不管是针对还是你说的那种靠流量吃饭的。对，但是而且我因为那个事后来才知道，在传统车企业里面包车MPV也经常拿管载来说事，我以为在你这个上泼脏水是一个原创，后来发现是他们的传统章法。然后这里边有一个说法是说觉得车价定贵了，所以当有流氓出来黑的时候，嫌贵的那些人特别愿意配合转发和宣传。因为他们比如说我举个例子：他心里价位是50万以内，结果你当时是50几万来着？55万9？对对对，然后这个时候他就——比如说他可能预算就是40来万，然后一看超了他预期，他就心里挺生气的，买不成了。这时候有一堆人喝黑，他就特别乐于转发。你看我这个理论吗？我觉得这些理论其实也都成立，因为它映射个社会现象了。但你当时那个定价还是基于你们原来的那个毛利的那个区间定的吗？是的，还是定高了。就算那个区间他就是成本那么高。然后对，它比之前R系的车毛利还少？有电的车更贵吗？是。包括我们是第一个做5C电池的，那时候新东西都是更贵的。而且那个理论上的量也不会达到R系列吗？是的，R系的规模化更好吗？是。本身我就是最后那个也是公司给我买的。但当时大家就觉得，原来那个行头公司给我买的是100万的二法吗？嗯，然后当然也不是我一个人用，那几个合伙人也都用。然后我回到北京以后，当时心里唯一的考虑是：我估计哪哪都比二法强得多，但可能座椅会稍差一点，这是我当时的想法。因为我做了这么多年车，没有座椅能超过二法的。就我到了一看，那个座椅也比二法好，而且还带按摩。完了我当时就说，哎呀这个车被黑成这样，就是属于我们历史上产品有一些被黑的冤的，也有也有不冤的——因为我凭空没做好，大规模的黑我只能活该。但是这个车我真是觉得，就是我见过的产品上是被黑的最惨、且产品完全不应该被这样黑的一个，特别典型的一个。所以后来销量还是慢慢起来了。我看了那个评论下面就你们官方账号后下面，一堆关心理想的那些网友都在说“为什么不早说”，然后被黑了这么多天。我觉得被黑也是一个……也是一个其实刚才讲的社交流量算法机制又被我们撞上了。但是我觉得背后还是有一家公司在操纵的，有一个同行在操纵的。从最开始我们挨批开始，就一直被黑，后面黑我们创始人形象，黑这个，都是有操纵的。而且人家估计有专业干这事的，就请的专业团队，甚至合伙人专业都是做这个行业的。你这样被搞了这么多次，没有报复心理吗？我的意思是最好的报复，应该就是你在商战上打败了它。我也只能这样子一起这么做，但这个肯定是有快感的。但我觉得还是说明我们的产品或者策略不够好。对，就是我们得做到让别人没法黑、我们都没关系、完全没用的程度。我也觉得泼脏水毫无意义。我还有几个问题：后面有销量卖个销量还是出了问题了是吗？当时肯定是出了。我们第一个月交付了3000辆，后面就是都在1000辆以内，最惨的时候一个月只有500辆。但是用户满意度很高，就是买的用户满意度就口碑传播了吗？后来又涨到了其实将近1000辆。如果回到我们自己看的话，我们还是有个问题的。因为比如MACA直接搬了R系列的内饰，它除了大，并没有一个更好的成长，因为用户觉得我更贵了，还应该有些新的。我知道了这个批评我也看过，所以后来你们内饰没有诚意什么的。所以我们做了悬转座椅——其实它不是那个内饰，其实它是一种表达。我们还是这样的，内饰没有感觉，因为这内饰比较有家庭氛围。但是我们把座椅功能做进去了，悬转了，并把MPV功能比如老人上下车可以斜着上下车，然后我们也允许老用户花一些钱能升级后模？还是把产品真正去做好，就用户的一些问题我们去改进了，并且给老用户一次升级的机会。因为当时的时候我们是50万988，后来我们降到了50万988？并给老用户退了三万块钱？所以我们可以稍微升级新的，那三万我也领到了。是，然后也包含我们的充电网络当时建的很差。因为就像你说的，很多MPV用户还是家里有司机，你不能司机在家里用慢充的充，所以它要出去充电，它就不方便了。我们充电桩就从那时候只有两三百个站，到现在建到了超过三千个站。而且像北京就是三公里一个，就跟家有站没什么区别了。对，I8 34前好像电桩铺到了，你们已经有的车一辆就有一个电桩吧？我们16000多个桩了，而且都是快充的桩。所以我说这个其实我们还做了很多的工作，用户的不满意，然后去调。我当时比较印象深刻的是：你们没有回应那些泼脏水的，但是有一个内部复盘会吧还是什么，然后你对理想的员工写了一个反省的那么一个东西，那个我还印象很深。就说“已经不是最初的出行这样子，半成功算理，然后好几个事没做好，然后就上了，但是实际上应该回归出行，每一辆车都像自己做第一辆车那样去”那个写的特别真诚感人，然后我当时印象很深。但好啊，你们也没有大规模的去推这个。是，所以你们市场上就公关这件事上还是不是特别擅长？觉得自己打铁自身硬的话，还是不怕这个？也不是，因为有的是我们没招。因为今天这个世界是个算法机制。那为什么不能找一个行业里特别资深的、那种公关的那种大头呢？就他即便不干脏活，但他脏活路数都知道，有应对策略，没想过吗？我自觉对这个话题格外感兴趣，就是我当年都被黑出翔了，之前就是卖了事情，历史上也没人碰到过对。我再举个例子，比如我们一样看能不能让人家用中展闪？他是学新闻传播的，他当时也是非常好的媒体人，然后他的影响能力非常强，然后他也和这些大媒体也包括央视什么合作合作非常深。但是他出了问题之后，今天这种流量机制也解决不了——就是风气这样以后，大家乐于去传这些对。但是我们又看到另外一个问题，其实它都是有正反面的：就是你会发现如果你解决不了，但是它跟原来也不一样，它也不会让你致死。虽然你解决不了，但是伤害其实也有限。对你只要那些硬的东西挺得住，这些其实就是一阵风。对你挺不住，成名也真不行。对对对。然后有新的热点的时候，这些流量就去追新的热点去了。其实今天这个社会就是这样的，包括你看马斯克遇到问题的时候，他都掌握推特了，该怎么黑他怎么黑他。好那些想做空他的人怎么还是怎么黑。逻辑是这样，但你们黑的时候还是太……打不还手了，我有时候看着就特别……因为我是三辆理想的车主，我就每次那样黑的时候，而且我这个共情还来自于我当我当年做硬件的时候被黑的那些东西。所以我觉得我觉得这个问题其实他们怎么黑我们，包括背后的这些是哪一家公司在操作的，我们全都知道，我们全都知道。但是我们很恶心的事情对，但如果我变成这样的话，我觉得我这一辈子就完了。我不想变成这样，就哪怕哪怕的黑我对，就是我都不想变成这样。我觉得我如果变成这样的话，我这一辈子就完了，其实就没啥意思了，我这一生就没啥意思了。对我唯一能做的就是说，如果他们这么黑还能对我们产生影响，还是因为我们产品做得不够好，我们应该更多地把产品做得更好。我只能这么告诉自己。是对，就是我。我就是很多人都建议说你要你要也建立什么打黑办什么这样的，各种各样的这些策略都有。对，我不想变成这样。然后我用MACA的体验是：我就说我作为车主唯一的不满，我觉得车型有点太酷了、太现代了。这个带来一个什么问题呢？对别人不是问题，对我的问题是我社恐。然后到哪停车下车，如果是工厂和比如一个什么商业大楼下面，我就希望没人看我，就低头赶紧走了。结果刚用MACA的头几个月，因为那个他们叫“显眼包”，因为很酷，像那个科幻电影里未来的车，到哪一天我隔着玻璃就发现七八个人已经扭头在看车了。这时候我觉得带个口罩、扣个帽子，跟做贼似的下车赶紧跑掉，然后让那个司机找个地方去等我。这个是困扰了我头几个月的一个挺大的问题。可能我这个是特殊需求。比如说我老婆开那个Model X的时候，我也特烦她后座的那个鹰翼门，那个太张扬了。然后我们俩出门没事，我坐副驾驶她开，或者有时候我开了，反正都行。然后就俩人，但是有时候来一个朋友，然后就让朋友坐后面，然后到了饭馆一停车，那俩鹰翼门夸一开，我在前排下车的时候，就跟做贼似的，我就觉得这俩人看见还觉得这老头50岁了怎么突然像那个热血富二代的玩起这个来了？就有那个压力。我觉得这事挺有意思的：你这是一个在网上那么多说的人，你现在说给啥社恐啊？就人性格是很复杂的。你看你记得以前还在网上吵架多犀利，他见面是特别——比我我还放开了还能聊？只是我跟生人我会有社恐。他是一些比较熟的朋友在一块，他也是特别腼腆的人。见过他吗？我跟他很熟啊。对啊，就很腼腆吗？对啊，因为他理想买L9是买个都买了吗？他也是典型像理想车主。是的，他不就是吗？他他那个网上多犀利，但是现象你就面对面见的话，是一个很腼腆甚至有时候有点闷骚的那种性格。所以我也是差不多，我就是社控很严重。其实我并不内向，我小时候以为我内向，后来心理学书看多了，社恐和内向是两件事，我是很社恐的。当时设计麦克的时候，我对设计师提了一个最重要的要求：要很酷、要未来感。对，然后我说R系列大家是看到新款才知道是理想的车，我说MACA是大家一般以外看到的、看轮廓就知道是理想的车，要这样的辨识度。还有那个后边往下下去一点那个，是完全是为了空气动力学那个吧？对，是空气动力学是吧？对，为了续航时间更长。对对。反正我是买完了以后特别满意，就是刚开始的时候觉得有点太显眼包了。但是北京好像普及的很快，非常多。其实今天有一个路口的时候能看到3-4辆。对对对，路口3-4辆对。后来就慢慢没事了。到今年6月份的时候，北京卖到了什么程度？就说50万以上的MPV，大家把50万当成一个门槛，50万以上你能买的就是像奔驰的V-Class，然后丰田的这个埃尔法，然后还有这个雷克萨斯那个车，丰田的埃尔法，然后还有这个还有一个极客的009的一个特别版？它表现偏向功能性的。然后还有一个别克的一个高端版本的。已经到了什么程度？就是每卖100辆车，有70辆是MACA卖的。就卖的市占率也到了70%了，MPV对。它是仅限高端卖的，就是50万以上的高端的，就说都算，你来有车什么都算，把那些世界大盘全算。你对对对，刚才你说那些全是外国品牌吧？那个极客——极客的那个特别版，极客不到50万吧？极客有关灰吧？那个是在50万以上的是它的旗舰。对，是它的旗舰。其实都往下，你80万那个我没试过。但你前半说的那几个我都坐过。是对，就还是那句话，这个你不用说，我来说就是“洋品牌”这个感受特别特别强烈。尤其是到了那个咱们出差去美国，看不着国产车的时候，满大街跑着那些虽然以前我们理解是价廉物美，现在看就是洋品牌。我们又运了一辆MACA去美国让美国媒体体验了一下，他们都基本上是说这个来到美国我们每个人都会买。我看那个车展的时候，有些老外看中国那个前几百块的电车都看傻了对吧？去年那个车展特别明显，还被媒体抓到了很多欧洲的那些——我不知道是买家还是官员客，反正就在那看着咱们做的那种各种各样的牛的车，都都傻。我们每一款车然后海外的……在旗舟上，他们都会买走我们的车，然后去做研究——德国的、法国的，然后日本的也会大量购买。其实，搞研究原来都是我们买他们的车，现在反过来了。你们计划中的国际化是在哪一年？是不是明年？明年就开始了。明年先做哪些国家？主要还是做亚洲和欧洲市场。亚洲市场……北美不让进吧？对对，只要是连网汽车都不允许进北美。我们的车还是偏贵一些，属于高端车，所以对南美和其他非车市场来说，还是太贵了。需要后续产品线更全再说。我希望尽早看到全世界都跑着中国的智能车。但去到国外，其实还有很多不一样的地方。还是得……我我我我问一下，就是你们那个MACA有没有计划出增程版？没有，没有。现在很多人问吗？开始是很多人问，对吧？因为充电体验太好了——充电体验比加油还好。你们现在的快充铺得很全面吗？非常全面。高速上，你从北京到三亚都没问题；从北京去杭州，整个路上全部能充，全部靠我们自己铺设。铺得这么厉害？对，我们是为后边的全电车提前铺的这些基础设施。所以当iBA这个系列上的时候，充电就完全不是问题了。我们已经是中国最大的超充网络。我再问一个重点——还有一个挺重要的一点：我们为什么做这些东西呢？还是因为我比较相信，未来人工智能R4、R4以后，就都会自动化充电了，你都不用管了。所以能不能先实现自动化充电，也取决于你自己有没有充电桩。还有，你们一直以来把MACA当成家庭用车来宣传，但我看官方数据说30%的用户是单身。这是你们采访过的吗？单身为什么买一台七座车？他们表达的方式挺有意思。他说：“其实我不需要那么多座椅，但我需要一个自己的私有空间。”而且还是有钱的年轻人，他们会这么来选择，而且都非常年轻。我觉得至少有一点你们是成功的：在国外发达国家，七座MPV很多时候是典型的家庭用车，但在中国早期全是商用车，所以大家有个偏见，觉得开MPV就像个司机，可能在那等老板。所以中国家庭用车更好的选择是SUV。如果有这么多单身用户买，说明至少从观念上——通过车型、性能也好，品牌宣传也好——让大家接受了开这个车不会被当成司机，而且他觉得自己是个时尚先锋。对，一方面觉得是时尚先锋，还有就是……刚才你说“显眼包”，我们用户里买MACA HOME排第一重要的是外形设计。我知道，因为我也是小众需求，我知道大部分我要年轻，也没有谁认得我，我肯定是百分之百喜欢“酷炫”的，不一定要那种土豪张扬、披金戴银的，但我肯定希望是很酷和未来的设计。而且买MACA的很多用户非常有意思，他们都开过非常好的车，可能另外一辆是法拉利、保时捷、劳斯莱斯库里南，非常不便宜。还有一个我特别想讲的，其实也是我们没想到的一点，我特别开心：我们有很多车主，其实是有MACA，也有阿尔法，甚至还有奔驰的V-Class。一个家里其实除了正常轿车，还好几台MPV。他们会跟我讲一件事情，让我们更坚定地把MACA做成家用，包括其名叫MACA HOME，都受他们的影响。是什么呢？他说：“我家里这几辆车，威克拉斯的接一般客户，去别处对接高级客户，而最顶级的客户，我会拿MACA接，甚至会把MACA给他让他在这个城市里用。”我说为什么这么想？他说：“就是一种家宴的感觉——你请一般朋友去餐馆吃，请好点儿的朋友去会所吃，请你最铁的朋友，回家吃。”我这台二锅头五粮液茅台也是类似的。他一说，我说我们更坚定这么来做了，不用担心丢失这方面的用户。明白了，那我们休息一下，去个洗手间，然后来点冰镇的我们TTC？好，不是个俯卧撑50个？那上台还有电儿吗？你平时一直健身吗？我天，真能做50？应该拍一下，来，太猛了，太强了。一周锻炼几次？一周锻炼三次。那俯卧撑每天都做？每天做。你健身能保证一周三次？能保证，太牛了。俯卧撑是一天做150个，每天：早上一组，中午吃完饭一组，晚上一组，50、50、50。原来做得更多，有时候一天做四五百个，那时候把腰伤上了，后来就不这么做了。你今年44？24？好日子还长着呢。我发现你也是天生适合讲话，聊那么长时间都没喝一口，所以我一直在喝。可以，来吧，继续。我有一个问题：你们在做纯电车的这一波，MACA也好，iBA也好，有没有担心过？因为在增程式领域里，你们是牢牢站住了第一的位置。有没有可能，早期那些贴标签的中产理想用户，会把“增程式”这件事做成一个强认知标签？我们内部有大量这方面的讨论。我觉得是这么着的：如果从品牌的认知角度，就是我们第一个阶段——我觉得我们基本上现在第一个十年，因为第一个阶段用那个方式，就是我们的品牌等于我们的用户定位，跟今天大家看到苹果什么还不太一样。因为今天苹果的阶段已经相当有自己的价值主张了，基本上从乔布斯回归以后、从iMac重新定义开始，是有价值主张的。我们比较像早期的苹果——Apple II、Lisa、Macintosh的阶段。那个阶段的时候，苹果的用户就等于它的用户群，是极客群体。我们的其实就是——我们品牌等于我们的家庭用户。我觉得这个其实是我们最重要的用户心理认知，而不是“增程”。而且我们认为，这时候看这个世界，是看像上半场、下半场：上半场是电动化，增程、纯电都属于电动化。电动化就意味着其实是硬件的竞争，我认为纯硬件的竞争，大家之间的差异没那么大。好一点、坏一点，你今天做了，12个月后我就学会了，也就追上了。所以我觉得其实比较大的挑战是在下半场，而下半场是智能化，是人工智能。因为我觉得汽车是物理世界里边最重要的人工智能终端。但人工智能的话，那时候你就想想你的预训练、你的模型、你背后的芯片、你的操作系统，这一个整体，它就是一个组合的大型软件能力的竞争。所以我觉得其实不用太在意纯电、增程这样的，因为我们做纯电还是看到用户的需求。从用户的需求角度而言，其实增程最终最容易转化的，是现有的燃油车用户。纯电的话，其实是给现有的新购车用户做一个升级，但同时，也会有很多忽然想明白的燃油车用户，以后直接往纯电来升级。所以我这两个都有需求。如果做全球也是一样的，可能我们打很多国家，增程是最好的选择，因为它整个电力设施还没那么强。其实大家都在谈一个问题：一个企业能走多远，其实就是看创始人的学习能力和进化能力。你这些年，在国内明星企业家里是以学习能力、不断突破、不断升级著称的。我想知道你在这个整个过程里，学习最主要的是靠什么？你现在一年能读多少本书？我读书比较慢，但我读得比较认真，一年大概读二三十本书。二三十本，那就一个月能看两本书差不多。但我确实读得比较慢一些。但你同时时间管理也是出了名的。我们知道创业公司老板绝大部分都要没日没夜加班，我一直听你们同事说，你可以保证类似“朝九晚六”这样的一个作息。车上四小时应该做不到吧？可不可以开发部会的人都做不到的。那一年12个月，你还能多长时间是一个比较健康的作息？我觉得是用的还是——这是我高中的时候一个特点。因为高中课外上课，所以我在高中的时候，每天有一个习惯：我只写今天的事，有点像乔布斯那样——我就写这事，打出来排序，然后我把前三个事留下，后边的事全删掉，只做绝对重要的事情。这是我从高中时候就开始养成的一个习惯。这个习惯是你不是看了什么书受到的影响？就自己培养出来的？当时就是因为时间不够，忙不过来。因为我还要上课，忙不过来，这个习惯就一直延续到今天。所以你也没看过什么GTD理论之类的？那些就是自己自己是吗？对。所以后来的话，我看了——后来包括我看那一本书，对我影响很大，来书就是把我那个东西系统化了，叫《高效能人士的七个习惯》：主动积极、以终为始、要事第一。跟我原来做法一模一样。这什么出书只是让你那个东西能够逻辑化、系统化了，其实很早就这么摸索出来了。然后因为我觉得，如果不是重要的事情，它就会影响重要的事情；而且做了不重要的事情，如果结果不好，你还要为它来擦屁股。所以我说，其实我发现，每个人只要每天把最重要的三件事做好，这个人就非常非常厉害了。但如果这个人天天要做十件重要的事，很多时候它是一个勤奋的天才。我觉得很多时候，反而时间有限，可能做得都不这么好。都是勤奋的天才，我觉得雷军肯定是一个。他是出了名的，我没法跟他比。感觉他一天四五个小时就够了吗？我都周六周日找他，他还都在工作。而且跟我聊完以后，还在跟后边的别人去交流。有一次约我露天聊一些事，在盘古大观后边那个露天场，坐到晚上很久点多来的，我们俩就聊得很热闹，因为聊产品为主。聊着聊着突然就天亮了，因为我们在户外，也没人赶我们，那个服务员打个招呼去下班了，他也认识。然后我就说，回去睡觉？他就说，回去上班。我就说，什么意思？不休息吗？他说上午有一个会，他说回去沙发上睡三个小时够了。完了我跟他公司的人说，他们说就这样，所以他们特别痛苦，因为你怎么拼都没有老板拼，然后就是压力特别大，能力又强又勤奋。我说还是回到你刚才说那个话题，就是学习这件事情。学习这件事情并不是真相，那真相是——其实我能见了，我能见那么多的，后来以后就能见到各种各样的大佬，没有见不着的，现在也都能深入地去聊，你现在也是，包括海外的那些大佬，海外的也都是一样的。但我能够在他们身上找到一些关键的共性，这些共性里边其实我能总结出来三条，但是第三条是反共识的。低调什么呢？我觉得第一条，每个人都会跟你讲，其实他怎么做选择、他怎么去收集信息、他怎么做一些判断。所以我说第一条是说，这些人一定都具有一个特点，就是选得准，对吧？要不然也不会从来整个大的趋势要选得准，就是做电商、做外卖，每个都还能选得准。然后我觉得第二个还有特点什么呢？我觉得这个其实已经开始有点小的反人性了，但是呢，成功学里都会这么讲，因为他们选得长，他接受这件事情很长才能有结果。因为越短有结果，其实越有问题。今天你觉得很有名的企业，其实都是25年、20年了。所以第二点其实要选得长。长不是坏事，有的时候你一两年就能结束的东西，其实反而是个所有人都会的，随时有人杀入。所以我说第二个其实是选得准、选得长。这两个其实大家都能讲，选择比努力重要啊，跟时间做朋友啊，都会这么来讲，什么做正确的事啊，都是在这两个问题。都是这两个。但是呢，这两个组合在一起以后，其实第三个才是最关键的。这两个当然可能已经是百里挑一，但第三个才是最关键。第三个是——我认识的所有的关于第三个都是非常一致的，所有的最终的企业，全世界，包括像黄仁勋啊、像王兴啊，包括你能看到张一鸣啊，什么都是非常类似的。就是因为大家觉得选得准、选得长，就可以慢慢做了？错，他们本人做了个完全反人性的：在选了一个长成功的赛道里，极高频率地迭代。明白？极高频率地做迭代。我这个其实太离谱了。比如说反正正确、长周期的，但你还要还要比别人更快的迭代速度。就是你一般选的前两个，就说我要追求完美啊，或者说我要更有耐心啊，但其实不是。你看包括黄仁勋，因为我这个应该是觉得做事人做不到，完全做不到。我做显卡的时候就很明显，就是他一年一代产品，别人三年一代产品，所以他把3dfx啊什么都干掉。最后就是两个华人卷，一个黄仁勋，一个何国源，因为ATI一天。他做CUDA的时候也是迭代十几个版本才获得成功。而且这个迭代什么？是要面向市场的迭代，不是自己内部在迭代——就是你认可，我推出；或者你不认可，我也推出，以后你的反馈。包括美团在极高频率地调运营的策略，又在优化运营，非常高的频率在调，就是外边不知道。包括大家也都知道字节自己在做产品的时候，是几十个、几十个版本同时在迭代在做，这个并行。我觉得这特别像什么？如果讲到今天AI，就特别像强化训练。因为今天到了AI Agent的阶段、到了智能体阶段的时候，其实强化训练变成一个关键。如果我们拿人来举例，就是基因模型比较像我们读书上课，后训练比较像有经验的师傅在带，但是其实最后我们人类的成长是来自于强化训练，就真实的市场反馈获得对这个训练。我觉得这个其实是一个根本的差别。前两个都对了之后，剩下第三个，其实往往是最难的。强化训练的频次，其实是严重违反直觉的。所以我这如果讲学习的话，学习可能会涉及到是预训练，也可能是个后训练，就挺重要。所以如果看完这件事情以后，我为什么会读些书呢？因为你光来自于强化训练也不行，所以你还得提升自己的预训练；然后你还得跟别人聊一聊，别人聊一聊相当于后训练，有经验能跟你讲一些东西；那最后你必须得去真正地去实践，然后不用担心，不要追求完美。今天没有办法追求完美，这个是所有优秀企业的共性吗？我就是卓越，优秀可能是卓越最大的敌人。这个说法有意思。企业级的那种NVD也一直……都是一年一点的。是啊，今天我们买的这些训练线，都一年一点的，跟显卡是一样的。他并不是说因为——因为一般三年一点的，我也对的，我印象了，硬盘那些就是企业级的那些都是好几年一点的，他还是一年一点的，明白？去年你能够接受的，对，去年几笔200，进一年就几笔300。还有就是，我听到一个让人既赌的传闻，是说你一直以来睡眠都没有问题，没有问题？从来没有吗？没有。像你说那个，当时不考虑生病一说的话，像那个融资资金端压力，手也都能睡着？这个是中间练出来的，还是你就本来一直都能睡着？本来就这样？这也挺理谱的。是不是因为早年还都是顺利啊？你那个汽车资家后期不是有很多纠纷吗？那个时候也都能每天睡着吗？我遇到一个巨大痛苦的事，可能痛苦到别人快活不下去的事，我基本上三天就过去。三天就过去，就第一天痛不欲生，然后第二天慢慢消化，该怎么过怎么过，就去解决问题去了。一直都这样。基本到第三天，我就——我是经历过，就做垂直科技的时候，经历过长达一年以上，每天都必须靠吃药来睡着，这么一个时期。但那个过去后，好像没什么事了。就别说每天上班跟管理层对说，明天可能就资金断裂了，然后大家做了一切最坏的准备以后，晚上回去还能——输出服服服服服服，弹不上，还能很踏实的睡八个小时。这个是一年以上的魔鬼训练以后才做到了。你是从来没有过这个时期？我觉得有一些可能是天赋异禀的。我又不是天赋异禀，是因为我从来没给别人工作过，然后所以我就只能——我也是自己来，自己来摸索。我创业的时候就一定知道一件事情，我压根没有退路。我也知道没有退路啊，照样睡不着啊。当你这样没有退路的时候，也就不用担心这事了。我觉得这真的是训练成的。就当我知道自己没有退路的时候，我反而就不担心了。那你可能还是特别不内耗的一个人。这个某种程度上也是天生。我真的我不会往负面的方向胡思乱想，就是压力大的时候，我在里边找机会，我找正面的机会，我只能这么干。但是比如说，你有时候真正难的时候，想到明天就要破产清算了，那还是挺难的嘛。那核心有没有？因为没有退路啊，但你也没有机会胡思乱想，也没有啥回应，所以你就完全不内耗？其实不内耗。当时那个我买了那个理想万之后，我在公司里就是——我是那样，我用了一个什么好东西，性格上是特别愿意热情地推荐给朋友啊同事啊。就推荐，当然是反那个程度，我是这种性格。所以我当年做手机的时候，我们有一些垂直买了，就恨不得一个人推荐给五六十个人。这个我是当然我是为了卖手机，我特别喜欢这种，但是我骨子里也是这种性格。我原来的时候做个人网站也是这样的。其实我觉得这是一种，一件领袖的潜在机，满足感，想要帮助别人，想要影响别人嘛，对对对。然后他们买回去满意了，再给回饰的时候，你就特别高兴。你这么想要高兴，对对对，你也有这个，对吧？当时的时候就因为这么做才做起来了个人网站。然后我在网上看了一个，因为你那个性格比较直嘛，在网上公开说一些至少肯定是没跟公关部商量过的话，然后说出去以后，又给企业了一堆那个舆论麻烦，什么这类的事儿的一个清单，你自己看过吗？我都不敢看。然后你觉得做企业这些年，这方面有改进吗？之前的时候确实，我说没有真正的公关部，我们只有这个做内容营销的，也没人其实来管我这些。而且本身在在做企业的时候也是这个个性，然后也被别人攻击过，但是也没什么太大影响。你没发现，你那时候不卖产品，其实他们也不能把你怎么着。但你卖产品的话，我不知道你有没有这感觉，我自己有感觉，是我做那个手机的过程中，哪怕某一代产品我做的特别满意特别有信心，似乎也被证明卖得很好，那这样的产品我推出的那一瞬间，我也感觉是——就不管产品多大信心，我的感觉也是就觉得，我在卖那个产品和他投一周或一个月的那个宣传期，是我最敏感甚至是最脆弱的时候。就比如说，我送了一个朋友，然后他说了几句好话，我就有种感激；如果他什么都没说，我就很慌，我就给他打电话问是不是不满意，有什么不满意你不公开说，很感谢你可以私下跟我说说的，就特别特别敏感这个事。你是发产品的时候完全没有这些心理？当然有了，也有，对吧？我就发产品跟你说的一样，第一周特别在乎这些预定用户的声音。对，其实会这边也有是吧？会特别人人的听。那那就好理解，而且包含对下半个我们的世界小兽，各个环节会关注的特别在意。因为这时候我就反复是非常重要，因为这些都是真金白银的用户，是来给你反馈你一年甚至你们车延发周期更长两三年的心血的全情投入到那个点，接受市场检验和回馈的时候，是那个那个真是战争经济的非常在意。是，那你那个时候为什么不会自己想着要再发言再谨慎一点？那像微博这种公众平台，还是有一些本性很难改的东西吧。因为有的时候我也会思考一个问题，就是更像自己是好事对吧？还是变得更圆滑是个好事？不用圆滑呀。你就是像你们公关很多时候不就也懒得解，什么被泼脏水的时候，但是你自己发表，我理解是这样的：公关部做什么决策，他都有一堆人群体商量，保证大家都冷静；但是个人发一个微博这件事，除非也在内部走一个流程，否则的话，很多时候情绪上来了就只说了。这是一个很大的原因，是我们严重的时候，他们都没收了我的密码，然后问我要发什么，就给那个市场部的那个同事发一条，他替我发出去。有些企业家性格本来就特别稳，不容易被激怒，或者是不容易生气了就直说。嗯，这种的话，他们的公关部肯定容易很多嘛。我是觉得真的，那个性格里那些锐气那些东西还是要保留，但是这个确实可能还需要做更多的那个——我讨厌那种传统的说法，说这个要修炼啊，最后你变成完全不会被激怒的人，这个我也挺讨厌的这个说法。但确实，企业做企业这个事特别锻炼人，我每个人都会反思一下，也会跟团队讨论一下，就是把我的很多棱角打磨掉了，对到底是个好事还是个坏事？肯定是坏事。所以我也经常讨论这个问题，是要调整，但肯定不能把棱角打磨了，是对。还有就是我觉得不是中国的问题，整个亚洲社会还是传统上文化上有那种审美上的一个偏向，就是总是不管对错、不管是非、不管逻辑，他还是认为一个沉稳的、表现出所谓风度和那种态度的，是一个更可取的选择，就是儒雅文化，对对对。所以这个带来的问题是，我是感觉在这么一个文化环境里，包括日本韩国什么的，就是企业家如果面对公众的时候太直了的话，其实得到的那种反馈、那种负面的回击那些东西，远比那个张扬个性的欧美的那些文化的国家里要承受更多的东西。我有时候会想，马斯克这种性格在中国可能早被弄死了是吧？但是我过来看他的那个传记，其实他也被黑得够惨啊，当时还有一知名的那个数字媒体给他倒计时吗，说特斯拉几天倒闭。我觉得还有还有一件事情，就是大家总觉得中国的媒体上这种黑啊水军啊多呀，对，其实你真的去国外的社交平台看，其实更多，也挺黑的，也挺黑的，也挺黑的……然后我们也去那个国外做一些前期调研什么的，跟他们那个公关公司聊，他们说我们这绝对不能给钱写稿，然后一年保证发多少稿发稿量这些都没有。然后我说那你们能保证的服务是什么呢？他说我们不能数字上保证帮你发多少个贴，但是因为我们跟这些媒体关系都很好，然后我们打包某种系统的提一个一年的技术成绩表现的话，是可以有一个承诺的。然后等他们走了，我就跟在那边待着久的华人也是做市场的，我说这个是什么区别呢？他说你可以这么理解了，他说就是——就是咱们那呢简单粗暴，给钱就发稿；这边呢把这个行为一样做下来了，只是用虚伪的文明的东西把它给做的绕了一点。就比如说你看他为什么不能给你承诺呢？是因为那边媒体要对外表示就说我不能拿钱写稿，这个是传统继续丑闻，但实际上他这个公关公司跟他合作密切的媒体是靠变相的方式产生利益，比如说经常请他吃饭送些礼物，常年维系关系，你帮我个忙我帮你个忙。他就是把赤裸裸的这种钱换来的软文，这个用偏虚伪文明一点东西，就说白了，现代的屠宰场你是见不到的。我们小时候在菜市场当着里面杀鸡杀猪嘛，但现在这些都搬到城市边缘的屠宰场里，我们看不见了，于是我们吃猪肉吃鸡肉的时候，没有那种那种同情心天然的同情心带来的那种良心负担啊，但其实还是每天在杀戮。因为我就是社交流量和算法是三种才一起，这件事情在全世界都会发生，一定会指向这边一个各类的结果，他一定是这样的，因为他会把一些人性的东西放大。再还挺有意思的，这个话题可以专门讨论一晚上。有一些企业家会把个人品牌跟企业品牌强绑定，然后有一些企业家那会躲在后边，让企业或产品的品牌走在前边，以至于这个产品特别成功，全世界都在用，但没人知道他老板是谁。这两种做法其实没有对错，都有各自的合理性，各有各自的优劣。所以你有没有系统性的思考过这个问题，就是你希望理想这个品牌是强绑定，还是现在这个程度就好？还是你后边灰度往后躲，还是怎样？这个问题你系统性的想过吗？没有那么系统的想过，说实话，但是呢，我肯定也会思考这个问题。我自己的本身的出现是希望其实是分开的，但是呢躲到后面去——但是两个字，没有办法分开。对，所以那这也其实是一个挺挺挑战的，但是也确实，然后当你规模变大以后，很多人买了这个车并不知道背后老板他也叫理想，我这件事情也在发生。早期的用户都知道这个车背后的创始人是理想，但是后边的话有越来越多用户买了以后，他不知道创始人是谁。我之所以问你这个问题，我就觉得你在这件事上不管是有意的还是无意的，刚好卡在这么一个中间状态。你没有像什么乔布斯啊，或者是伊隆·马斯克或者是雷军这样跟品牌非常强的绑定——刘强东也算，就是非常强的绑定，没有做这个事；但也没有像我们熟悉的一些企业家那样完全躲到幕后，以至于大家都不知道品牌创始人是谁。你在这个中间状态，但这个不是有意处理成这样的，是是想躲躲不了，出现了这么一个状态。所以当企业有需要的时候，就得走在前边，是因为你年少就成名了嘛，所以其实这个对你做企业还是有价值的，所以你就维持在这个状态，但没有系统性的调整？没有。那我现在就问你，你后边希望一直是现在这个状态吗？还是会更往前走啊？你说你本性上是希望更——我本性是下注的这个我理解，但是你从企业的需求上，你觉得后边应该就长期的经营这个品牌，应该更往前还更往后？因为这件事情其实每个人在做这种选择的时候，其实都是第一次，对吧？就是你做互联网、做汽车公司，其实都是第一次。就跟很多时候我第一次当父母是那我觉得这里边只能来自两个：一个你看各种的最佳实践，包括你所在的环境；还有一个你真实的体验嘛。那就是你又可以讲马斯克什么很成功，你今天又可以讲张一鸣啊包括黄峥啊，又格里的很成功，对对我就是这是不一样的。所以我觉得没有什么正确答案。但是从我骨子里而言，我是希望其实然后分割开的，我相信大部分企业家还是这样的，除了有一些有表演狂的那种暴露狂。就我并不享受连在一起的状态，然后我希望大家然后是我们好事因为我们的产品好，而不是说因为然后理想我喜欢你，所以买了你的产品。我就觉得我就坦率地讲，这么多年下来，我就觉得我学习进步的能力还没有超过就是做企业所需要的那些能力的增长和进步，还没有超过我经营个人品牌的能力，所以就很尴尬的处在有的时候想往后退，发现中和的力量加起来还是要往前走一点可能效果更好，所以就一直维持在这个状态。我特别希望我彻底退休前能够进步到那些能力略微超过我个人影响力这件事，我就可以尽可能往后躲了。我觉得还是每个人做最好的自己，然后你很早就成名是一个明星企业家，然后也以性格直率和作风强硬著称，那你做这个现在这个企业的从第一开始，有没有用一些有意设计的方式，比如说制度流程，或者是跟合伙人协商了某种方式，来平衡这个，避免就是完全靠你一个人的决策导致可能的重大错误？有这样的制度安排什么这些有吗？我觉得我觉得还是主要是因为在汽车之家然后有了经验以后，这个我们建立了一个相对而言比较科学的管理方式。就是那个是你第一次找到一个足够重量级的合伙人，以至于充分尊重和互相信任。反正其实也很重要，反正是什么特点呢？反正其实不怎么说话，但他每次说话的时候都特别准，就是我干蠢事的时候，他是能拉我一把的。但是你决定要去做了，然后我也他也会在后边，你不用担心摔下来，我在后边帮你成长。我觉得他是这么一个人，就是特别好的合伙。你很早就找到了这样的合伙人，所以你这方面还是挺幸运的啊，很早就找到了这种合伙伙伴。对，然后而且有了经验以后有特别好，这样就是我们所有人都会吵架，特别有意思，就是很多人刚加入汽车之家的时候说你们为什么每次开会你几个人是不合呀？但我们就正常的吵，吵完以后然后就决定，完全对事嘛对，完全大家相互信任。对。那后来呢我就发现其实这种吵架的方式呢，其实会把每个认知都烤出来，就大家不用藏着掖着，其实不是坏事。而且呢很多时候我们之所以大家做不同的选择，是因为认知不同，他把每个认知都跑出来的时候，你发现是很容易做相当选择的。我觉得就大概就是你的你的计算模型他计算不一样，但如果你们最后合并的一个大计算模型，你发现推理出来的结果自然就一样了，推理结果就一样了，而且这时候确定的结果所有人都坚定的支持，不用考虑什么资源啊效率的问题，都一定能做到底。那你做汽车之家不汽车之家就是做了一次车以后，也找到了一批这样的合作伙伴，所以跟马农会什么的也都是，我们都会正常吵架，吵架然后疯狂讨论，然后做产品的时候也是吵架。产品最难受的有当时不吵架的，是我们产品最差的时候。我们有一段时间是把一些做产品最好的人去做流程去了，因为他，我们熟悉这个一样，他把最佳时间变成然后变成流程，所以呢，就掉了一些他们下一集的人上来，跟我一起来做产品。那这时候就变成他们都听我的，明白吗？特别难受，是特别特别痛苦的，需要足够强的一堆人碰撞才行。对，一定是碰撞，明白明白。大家总说，要成就一个特别伟大的企业家，这个人要承受难以想象的痛苦还有委屈。这些以前马老师被说，企业家的那个胸怀，内心都是被委屈撑大了。你对这种看法是否认同？和是否有这方面的很多体会？我肯定认同的是吧，因为我们创作也都知道有多难嘛，整个过程肯定是认同的。尤其是对比一些我投资的企业，就是我投资很多那种初创企业，就他很多的问题的时候，就一点点委屈他就受不了了，我觉得这个就能看出来差异了。这种真的到退休以后，如果还有兴趣聊的话，弄一个雪泪史一样的，还挺好。而且那时候一定是笑着云淡风轻地讲，但是回过头来很多时候再想想，你可能真的就是，真的有可能性格决定你说承受这些东西啊。对，或者说其实是他，比如说并不是他后边训练的，可能是他后边训练还是我说对着，他首先他有一个非常好的基础模型，那个决定了他的性格，这样的后边的话，你有后训练啊，然后有强化训练啊，然后去调整。但如果你的基础模型就是个垃圾，其实你后边的然后不可能有好的推理结果，然后承受这一切就没有意义了。后来也看到很多有意思东西，比如说我们在小的时候，那些年其实就是通过父母和亲人来认知自己，然后又过一段时间，是我们通过同学和老师来认知自己，然后后边是靠社会，靠社会认知自己。好像真的是这样子的。那我们说点沉重的吧，我们聊到这个理想理想汽车的创业，现在十年了。回顾的话，或者说你整个创业生涯吧，回顾的话，就是你最难挺、最戏剧性的、或最悲壮的、或者最自然时刻的，这个能跟我们分享几个嘛？就是最最，我就有四个。第四个刚才也讲了，就是2019年融资，身体都不行了，还那样。然后其实还有另外的前三个。我第一个已经是，然后在做泡行的时候，当时这公司的时候应该有大概三四十人，我听一下没那么深了，因为我对特别痛苦的东西记忆没那么深量化的。但是那个场景我回到那个场景里面，不是就是立利立利在目的，因为那时候不会做管理嘛，所以完全不关注人。我们真的出现一个状况，就是前一天大家好好的，第二天90%人辞职了，公司就只剩下五六个人，人全没了，都在上班了。你干了什么过分的事，能一下走这么多人？我觉得基本上那时候就是一个独裁的暴君吧，完全没有人情味那些，就是完全是就只关注事，完全不关注人，然后也不懂管理。你说多少人同一天辞职？我们那时候三四十人，就今天90%的人一天辞职了，基本都走了。他们都商量好的一天辞职了，而且都找好了下家了，有的其实去了别的公司，然后有的出去创业了。就那么有状况，然后那时候就一个电话一个电话往回往回找嘛，就没有人回来。然后那个时候你已经有那两个合伙人了对吧？没有，只有一个，只有反正还是反正在十二中，我已经想到是远程的。所以那时候就我们就开始立刻招人。那你回头想的话，你看我们在网上看到很多那个乔布斯特别暴君式的那种，当时你听说过那个吧？就那个是被他们老员工证实，真的就是原来在那个老园区，大家上下那个电梯，其实楼层并不是很高，他原来那个老地址的那个苹果园区，员工说是很多员工不敢坐电梯，是因为坐电梯有可能碰到乔布斯，乔布斯呢看你一眼就问你个问题，然后你说错话，他出门而人力就通知你被解雇了。所以大家宁可走楼梯上到六楼或者到五楼，避免碰到乔布斯。有他年轻的时候吗？对对对，早期的时候，后来完全不这样了是是是。所以我的意思是，听起来你能干出类似的事吧？干不出来，也没那么过分，其实就是完全不听大家的想法，也不关心大家的感受，你也没有那么粗暴，只是说你完全无视他们的意见。对，那个时候怎么解决？一方面招人，一方面我真的去读管理书了。然后我就上网查什么关系书重要，那时候这创业第一个最大冲击的事，对，就是这公司有崩了就崩塌了。对，然后我那时候去读管理书怎么稳住的呢？因为你业务还跑着呢，就继续招人啊，因为自己会做业务，就手忙脚乱全顶上去，自己会做业务明白。然后那所以不自愚之命，不自愚之命，技术那边还有凡程盯着，这个内容这边有我盯着，然后销售那边少人还在，他也能盯着，然后没人没夜招聘，所以就去招人去了吗？从那时候才开始有了招人这么件事。然后另外一方面其实开始读书，读得读读的书就很认真地读，看懂看不懂其实就就去读。然后还有讲什么要怎么做一个观察者啊，怎么去沟通啊，那时候就开始说要沟通。那时候不会做沟通怎么办呢？大家一一一一一起吃饭，就学了这么一招，就是晚上的时候也叫着的人一起吃饭，那时候在中关村吃的盖饭，就是大家吃盖饭的时候或者吃米线的时候，大家也要在一起吃饭，因为这么着他们就能跟你讲讲话了。所以你觉得你本性是低情商的吗？还是在这件事上那块完全没想过导致的？我就是没有社会经验，其实你跟朋友家人什么情商是正常的，也不是也不是也不是，就是叫少是考这些，那时候自己很自私，那时候就认为自己什么都对的，都是别人的错，包括那时候找女朋友也是，就觉得都是她的错，自己太自私了。但都有这个阶段呢，小伙子都有这个阶段，小伙子都有这个阶段，所以男孩本身也傻嘛。那是冰鸟那是你二总是对对对是是，还是不够感性吗？我觉得第二段其实是2008年，就我们出现经济危机，那个经济危机那一块就资金出现困难的时候。然后我那一块我就是，我看过什么香港大片都觉得都没有我们那段很。那一段的话其实是我们的三个小股东，其实有一个还是合伙人，然后他们的股份也都是我让他们加入的时候送的，因为我也没有什么条件，那时候就是一个高中毕业生，所以我是靠给大家分一些股份吸收他们，然后工资也低，给一些股份加入加入公司的。然后那时候我们还有一个天使投资人，那天使投资人其实他当时并没有把钱给了公司，他是买了小股东的一些股份，小股东说想买房子卖一些股份，所以他就买就是买了一些老股。那那时候就出现了一个状况，就是情质也加入了，然后这个谁这个反正也来也来北京了。然后那时候我就不停地去融资，就是赶上2008年怎么都终不到，但是我每次都跟他说我一定能终到，要钱快到了，这个钱要签这个要签这个协议了，那最后就是没终到。所以呢在4月份，听得都特别耳熟，应该是在4月份的时候，我们那三个小股东就说要开一个股东会，所以就点中关村找了一个茶馆，大概这么一张桌子，对面是三个人，那这边是我们的产品负责人叫刘清华，然后他是个中立的对。然后呢那边是我们那个天使投资人，然后岁数挺大的，然后这边是我和凡正所在另外一次，那时候我27岁嘛，还不到27岁，26岁那年。然后他们就一上来了的话，然后找了他们三个人里面最能说的，我们管内容的负责人，然后举了一些例子说，然后你看理想，你引入了李铁和第一个举政是你引入了李铁和情质以后，公司的现金流变得越来越差，所以证明你引人不利，然后平常经营状况恶化。然后第二个，你在外边去融资，我们那么好的业务然后融资融不到，证明你融资不利对，一直让公司进入了那么困难的一个场景，那时候就现金流的一块断掉了。然后所以呢，我们一个结论就是，你和凡正已经不适合在管理的公司，所以呢给你们那时候我和凡正收70%的股份，我们俩加起来给你们保留10%的股份，然后你们俩必须离开公司。那他凭什么呢？他们是小股东，没有什么程序，这是他们的一套逻辑吗？就蛮干就把这个逻辑表达出来了。我和凡正就惊了，因为你要知道，就是我跟那几个人甚至在一起睡过觉，就是我们白天工作晚上一张床上睡觉去当时的时候，完全不知道怎么处理，我就懵了，我就懵了，凡正也懵了，他也没有见过这个这个这个阵势。但是首先这个叫板听起来就挺荒唐的呀，因为当时公司确实陷入了危机呀，然后不是不是那么简单。而且在讨论这件事情之前的时候，我的银行卡里有105万个人卡，个人卡里然后他们三个人其中一个人找我借了100万买了房子，他是把房子买完了以后才开在这个会的，我的卡里只有5万，我整个银行卡里总共只有5万块钱。然后为什么印象那么深，是刚买完房子然后就翻了，就就开始启动这件事对，再挺了一步的。然后你自己感觉跟他是兄弟的对啊，然后那我就懵往下什么的，我就后来一会再讲后边的好。那后来我还是想为什么印象那么深呢？因为那时候我们公司真的没钱了，5月12大地震的时候我没有钱捐，所有人都骂我们，我们真没有钱捐，那时候我把卡里钱捐完公司账上就剩下12万块钱，公司还得活下去。今天你看理想其这只要国家有任何的灾难有任何的这种，我们立刻有捐钱，我们当时没有捐钱我印象特别深，所以后边的话其实你能看到我们现在就是永远都捐钱对。然后因为那时候我们也觉得不对，但是我们活不下去了，所以当时印象特别深。那当时现场怎么着呢？现场其实我们完全没想到，我俩就傻在那了，然后刘兴华在旁边也不知道怎么也不知道怎么办了。然后是我们刘兴华是那个中立派的中立派的，然后是我们天使投资人啪一拍桌子，那拍电影就会非常非常有意思，然后啪一拍桌子说，你们三个小股东的，你们三个是谁出的这个主意？如果放在古代，你们三个要被满门抄斩，如果放在现在也没有任何小股东造反是成功的，你们三个小股东的谁出的主意？三个人立刻慌了，然后开始互相互相说我不是我出的主意，我觉得公司对我还挺好的，然后三个立刻当时就崩掉了。怎么感觉像一群小孩干的事啊？他们当时也都也都没都都比我大，其实这个主谋是帮着我们的，其实就是我的成长过程中的恩人，然后包括他把我们引入到北京。后来我知道其实还是我的问题，包括通过澳电进入啊这些人，那股份也都能套现了，就是这些后边各种事都处理了吗？我就是我和秦智的时候继续反正就去把这公司往下去管理了嘛，其实澳洲那些进的时候也是为了化解这个问题，他们几个拿了钱就退出了吗？退出了退出了，包括还给他们留了一些，有几个人还留了一个股份一直到IPO然后才退出的，还挣了不少钱，大家以后来也都没什么问题。我跟那个主要的人然后后来聊了一下，我说为什么呀，我也挺难受的，大家都这样了。他讲了一个特别重要的一件事情，他讲其实他讲的是真话，我完全相信而且这对我帮助，他说你倒一个人死扛，然后在你死扛的时候，我们最大感觉是你觉得我们不重要了，我们跟你一起拼过来的，就是你没有试图跟他们一起沟通怎么的，你遇到任何困难都不跟我们商量了，原来你都跟我们商量，然后你对了最难的时候你一个人死扛，我们想帮你帮不了，然后我们就觉得自己在这家公司不重要了。所以我当时想是真的事是真的事，所以这件事以后我发生了巨大的一个变化，我发生了特别大的变化。而且那时候那时候最难的时候，我是一天工作十三四个小时的，就是是个拼命三郎，我也从来不休假在那时候，因为汽车网战精神激烈。所以我原来那时候开始的时候我是，我得先对自己好，一个从来不至长的人是不可能给别人填头的，所以我这是我做的一个一个很扎的变化。你想他们那时候真的有非常有，他们买的都是宝马奔驰，我开的是Polo，对他们买的都是70多万的车，我开十几万的车对，然后他们买大房子，我住的是很小的房子对，然后所以我说你一个人对自己好，然后包括后边很多员工也是说，当我买了好车以后，我们买了宝马以后，他说挺好的，他说你到开一个Polo，你让我们开什么车呀？这就是我的问题对，对自己太苛刻了对。然后我第二个是，我遇到任何困难的是我都跟团队一起讲，越大的困难跟团队讲对。那你在那个时期不跟他们讲的心理是什么呢？是就有机中可能吗？一种时就自尊心，我就自己扛了，然后还一种时你觉得跟他们讲了也没用？不是，我就是越难的时候我也觉得应该自己思考，我觉得后来发现这事完全错了，其实不对完全不对的，是越难的时候然后而且你跟团队讲的时候，团队觉得自己最有价值，因为每个人都希望在你这个团队还是核心管理层吗？就没必要跟下边是的是的是的，我都会跟一五一十的跟核心管理层讲，包括跟投资人去讲，而且不要到最后快死的时候再去再去做，当你越到困难就跟他们讲，我就每个人都希望在你身边贡献他的价值，大家都希望自己是被需要的，而不是不被需要。好的，所以我说这是第2个，然后这些这些困难，然后我就第3个然后我也挺重要的，就是我开始会处理关系了，我会站在对方的角度去思考，然后两个人之间产生的关系了，原来比如说女朋友都闹得都是他的问题，后来想想其实我说70%都是我的问题。所以也是那一年我认识了我老婆，然后后来的话这十几那时候是27岁，认识的我认识了我老婆，所以后来的话然后这些东西就处理就开始越来越好了，而且呢其实团队有非常稳定，然后理想汽车团队也开始非常稳定了。那你第3个是什么？中大挫折的感情第3个？第3个也是还没讲到呢对吧？这第2个问题嘛，所以我觉得第2个问题可能是我人生最大的转变对我认为就是说是我人生最大最大转变，这种事儿没有必要自己死扛，没有必要死扛，而且呢其实讲了以后大家信任是更好的，因为所有人都希望自己被需要，哪怕他听你的了，他也觉得其实自己人生听你的也觉得自己是是重要的价值明白。然后我觉得这是第2个，第3个什么呢？第3个也是基本上大家看的香港的大片里的都会出现的，就是我们2013年上市，因为我们业绩已经很好了，2013年其实整个资本上回来了，然后我们也找了非常好的投行，然后是在9月底已经确定了我们10月初就去就去那个纽交所上市，我们当时报的纽交所，然后投行啊包括认购这。这些东西其实都做得差不多了，然后国家前两天，我们跟团队宣布了这事。然后，一些杠杠团队就大家去办护照，准备这些东西啊，一起去美国，一起去美国去乔中去了。然后，仅仅是第二天，出现了一个问题。因为当时我们都是小股东，然后澳洲电信买了我们股份以后，我们是个小股东，我当时只有6%的股份了。所以，当时我们为了保护自己，设计了这个条款，就是想要上市，必须超过95%的股东同意，这主要是为了保护我的权利。但是，在这个过程中，澳洲电信还把另外买了一个公司，共和兵在一起，所以另外一个公司的股东也差不多有这么多的股份。因此，有了这么一个条款。当时的时候，是一个什么状况呢？而且他们的团队都交给我们管了，他们都退休了，就不在公司工作了。然后，他们所有的团队都交给我们来管，然后他们有那个投票权吗？没有，他们就只剩股东了，没有投票权。但是，我们确实需要90%的股东同意才能去上市。然后，当时出现什么事呢？就是我们最大的金融对手买了他们的股票。我们当时的是，物资的价格是三块钱，当时我们的金融对手开出了19万一股，然后买他的股份。所以，他就直接通知我们说，我们就对吧，准备了那么长时间。我们其实准备在三年，二零一一年就开始准备，然后IPO必须停止，至少十月初你肯定去不了了。然后，不就买走了吗？还没买走，我们先自谈谈，买走了，你们为什么不谈判呢？我在接着讲。所以，我们当时先跟团队讲了一个说，我们肯定要推迟上市了，这肯定现在上不了了，因为有这么一件事情，因为股东发生你的股份结果发生变化。中国需要一年以上的时间，但美国也需要重新过这个，重新来一遍，对，来一遍备案。所以呢，我印象特别深，因为他们他们的团队很多人加入我们，我们给了他非常多的期权，而且还要有差别。就是说，其实我们然后当时，然后被澳洲电信买了股份以后，我们给团队分了很多钱，然后因为他们在一起比的时候，发现我们然后分的钱比他们分的多，我们给我们的团队分的钱比他们多。所以，当时的时候，一个现场的一个，我们把这状况跟大家跟高管们讲了一下，二三是个刚刚讲了一下。然后，我们的团队人都没什么事，然后转身走了；他们团队人大部分都哭了，原来他们的人跟着我们干的人都哭了。跟着他们的时候就没转到多少钱，本来有一丝上市的机会了，他给交黄了，给交黄了。但我们怎么做呢？我们其实就是然后赶快跟我们的投行，然后包括跟澳洲电信商量，然后我们兴趣又先回顾全，哪怕是就还能价格，我们必须给他买过来。所以呢，我们仅接着就最后这些股东通过一种接待的方式，然后就是内部时间的又先回复全，然后其实就把他的那百分之六分买了，从而避免了然后阻止我们上市。因为那是如果上了市，这基本上就是很难受的，这白忙碰了，而且大家过去三年吧，而且员工是有着气氧值了，大家那么努力去做业绩，然后业务发展你特别好，特别就很难恢复状态。所以呢，十月初没有上市，然后我们就很深圳的大家在做，而且团队特别团结，我把问题告诉团队，不能藏着一夜着。然后，我印象特别深，二零一三年的十二月一日，一三一二一，然后我们去去扭腰子上的市，那天下了大雪，然后去上的市。那拖了一年多没有啊，是从二零一三年十月份啊，因为我说一年准备一年，当时遇到一本题没上了吗，然后一三年上的特别开心。而且呢，我们还是十三块钱发行价，当天涨到了三十的坏钱。这个机械就是完全没经验，被那个什么了，没有，我们我们努力再干活，再帮他赚钱，然后来发现就没事。但是你原来跟他们接洽，然后他成为你大股东这个过程里，或者在之前有大股东没有？就说因为他是大股东，合并了另外一家企业，他在里面占一部分。但是我的意思，你那时候团队有负责投融资啊什么这样的角色吗？有啊，都是很专业的。但是怎么都没有想到，我们要上市了，我们一个股东会选择这样的一个方式，因为他也是受益者呀，他也是他也是军大的受益者。所以你看那什么TVB拍的很多什么股票来接上市，恶意收购什么的，我们都经历过，感觉好像很需求化，其实是对，经常发生的，是的。所以，我们前半聊的时候讲，你青少年次来成长，好像一切都顺，其实你股头都是创业以后吃的，对吧？是，如果你是一个小富机安的性格的话，可能你一生就没什么股头可吃。你看你18岁就能比父母多在十倍的钱，如果你性格上是不是创业加精神是一个小富机安的人，可能就一辈子轻松就过了。对，因为我们可能的时候往往是我最是我更兴奋的时候，是吧？你最艰难的时候有因为这些压力或者是这种事故，就有甚至哭出来的时候吗？当然有，有啊，无数次，无数次，无数次。我因为看马斯克专辑的时候，我认真回响了我也没有哭的时候，我是太有几次。就一次是我们在那个深圳开手机发布会，我故意设计了个翻转。因为那时候大家全都超爱风一模一样，全中国手机都是超爱风，就员过龙龙的那个，我甚至觉得那很丑，特别是他在那个金属的那个二次住宿的那个公益里边，在后边巨大的说料条，就是F5开始吧，对，就特别丑了。结果全中国都超那个那么丑的方案，然后我们就说我们自己要不要跟我说，那我就我觉得不能接受这个。然后我们就做了一个甚至是密子来，就是我们本来可以做的比较瑞丽的那样一个边缘，甚至做了更瑞丽的一个效果，就是完全是一个但这不是单纯堵气，因为他他这样的线条越柔和呢越有亲合力，但高级感就会弱；你线条越瑞丽呢，他就有高级感，但亲合力就会弱。所以一直要平衡那个。那个时候我们就说，你看那个保试节设计，其实他跟保试节汽车没关系，不是有个保试节设计的单独的，对，对，他们做的那些东西就是一直是特别硬了和瑞丽的那种风格。所以我们说我们查试一个这样的风格，然后做了一个那个其实是我们历史上卖的最多的单款手机。然后那个风格设计完了一个PRO1，也是前半一路亏水，那个是第一个赚钱的，后来第二个要坚果了吧，对吧，坚果坚果PRO1。对，我们是买了这个牌子，然后我们那个瑞丽的那个手机出来以后，我我做就是那个发布会的时候，越想越生气，我这么大国家这么成功地起来，这么都去超一个你超一个好看的我的能理解，超那么丑落的东西。然后我就故意把我的手机设计成跟那个iPhone一模一样，然后跟发布会上就给大家人们狗样的就讲说，你看我们这手机现在呢，我们经过市场的锻炼和垂打之后，也就是从大众的角度做了一个比较容易被接受的这么一个外形。我就需请假意的就是把那个我们手机发布上完全是造造iPhone造造的那个讲，就下面观众就特别失望，就是我能看清前排的人脸嘛，完了以后有的人还说什么假的吧，就那样喊出来了。然后我就一直人们狗样的讲了一个小时，全是拿着假的手机造型讲了配置讲了什么讲了什么，就全部讲完了。然后到后边的时候，我就说我就起来一句话，其实就是我想象那个垂有的心声，就你把手机超成这个德性，做这么难看，你对得起我们吗？那时候我们虽然手机不成功，还是有一个百万两级吧，一两百万两级的一个非常忠诚的用户群体。所以我就想象他们真的看到我有一天多骆去超那个，他肯定会说你这样对得起我们嘛，就是一直支持嘛，前面那么艰难。结果下面反应特别疯狂，就是比我想象的我亮出真机的时候，他那个疯狂程度超出我想象的3到5倍吧，一点不快的啊，就有的人一边喊一边哭。然后我瞬间就不行了，我其实特别休于在工作面前表达情感那个东西，完了完全控制不了，鼻子从这到这就算透了。然后就说了一个公司是有绝对不该说的话，我说因为那时候主流不是都跟着超iPhone一个丑路的毛说都满球新卖球了啊，不是不是，我说我我我这个手机如果有一天卖出上千万不几千万不卖疯了，我说到时候所有的都买我们的手机的时候，这CEO绝对不该讲的话，我说所有的手机都来买我们手机的时候，你没有记得这是给你们做的。然后我们就台上台下就都不行了，就那一次我是公开流露了这个这个这个东西。我其实情感上是就是性格上是特别休于表达那个感性的那个东西。我们我们公司，然后用那款手机的人是最多的，对，就是那个我们刚开始创业的时候是里养其中创业的时候，对，那个其实是我卖的最多的单款，然后内部开始赢力了，下一步也赢力了，再后边也不行。然后我想想我创业过程中好像有那么一两次是回家跟老婆苦过，在公司没苦过，我苦的最多也是对我老婆。我还问一个具体问题是，i8现在是叫什么wear a，因为我之前看过你们拍的那个短片，对你和那个那个朋友是做机器人的是吧，对对，但是我们原来的自动价值的前面经理后来自己出去然后创业的机器人。我想问的是，你们在马路上开可能从郊规或者说公众语论上没有放开那个方向盘，实际上当然我们不能讲存的而是自动价值这个现在还不能谈，但是实际过程里其实是没问题的，对吧？也不能完全什么说了。我觉得可以从另外一个角度来看，就是我们讲wear a c大模型，其实本质上我觉得就是到了智能体阶段，因为他已经是个智能体阶段了。智能体就是我们在创造一个人，我们在创造一个司机或者创造一个职业司机一个，然后因为他在一个千面万化的物理环境里，但是其实他的本质然后我认为其实就五项，就只有五个东西是他的本质。然后第一个本质是，然后这个司机能不能就是我们评价一个职业司机他有没有选对路，然后第二个然后是他有没有控制好速度，第三个他开的是否平顺是否输势，第四个他是否安全，然后第五个他是否沟通容易。然后其实我认为后边的话，我们在做AI啊包括游戏在做智能体的阶段的时候，其实就应该拿着人的指摁来衡量，就是如果一个职业司机的选入能力是一百分，然后你用wear a还是用原来得闹端，你到底你的机械能做到多少分，然后已经你的成长然后怎么接界。所以我是这是我们我觉得我们自己创造出来一套新的一个研发体系，和我们对AI的理解。我还跟我刚才讲的就是遇训练什么遇训练，就是我们读书对我们上课后训练，其实就是找有机案的人去聊天去获取个经验，强化训练就我们在现实中然后不停地去断练，然后获得真实的反馈。其实今天还就是这么做的，但只是遇训练的方式和后训的方式和强化训练的方式技术是不一样的。也可能其实你训练一个司机和你训练一个销售和你训练一个工厂制造机器人训练方式不一样的，这里边要为的语料然后这些东西是不一样的，但它原理是完全一样的。wear a的时候，我我有很多我觉得好玩想问你的一些事情，比如说你们强调这个系统的特征是安全性，表现在它不会乱开，比如说以前用那些老司机训练出来的其实它会操车或者怎么样，是对吧？所以它会开的跟规矩跟安全，是更没有隐患。是，但是如果假设在一个开车充分不文明的地区，大家都假设都那么乱开，它会不会因为开到过于老司导致一个口后边一堆都靠不规矩的方式过了，它还在那儿排着有请你知道有些失路口等那个灯的时候。我觉得核心的所以我们在讲着到了wear a 是强化训练，所以你只要生成相同的强化训练数据，它就能训练出来，它跟人是一样的。就是你这个司机，你只要在这个城市里开段时间，你就自然学会了这个环境，比如说很多人在美国开开很老师，来中国一上来不会开，那你放心，三个月以后它跟所有的人都是一样的了。所以你就说它最终还是会模拟人的行为去做，它是用强化训练的那个方式。那你对这个车就是发售的时候就交付的时候，配套里边的这个第一代的这个版本wear a 有多大的信心会实现比同行的这些有明显的优势？我觉得上两个话就比原来的灯道端是要大概好个20%，但是呢，如果这20%是容易被感知的吗？有一些还是很容易被感知的，比如说其实然后价值的数据性对，然后再比如说其实选路的能力，然后还有这种安全保护，对原来你灯道端是没有安全保护，它不能理解这个丁子路口，它就直接冲进去了，对啊，然后它只要按照岛上右转，但你看到今天看到是一个这个丁子路口没有红绿灯，它只要先到路口停下来观察完再右转，它跟人是非常类似的了我这个特别特别期待。因为这类的东西我们做过很多产品和研发都知道，就是有一些东西你做的你实实在在知道它改善了哪些，但是从消费者角度不容易被感知，那就很大程度上就是它的收益其实是很小，你做了很多努力和付出了很多新学，但收益很小。但你这个如果有一些明显被容易被感知的东西，我觉得那个上的时候真的要实际强化这块的宣传。我还有一个疑问，就是你跟那个机器人公司那个是有你们俩一起拍的那个短片里，你们跟那个理想同学聊的时候有一些说的还挺复杂挺啰嗦的，他也都瞬间就正确执行了是。所以我想问一件事是，你们现在测机里的理想同学是已经接AI了吗？还是传统的RP？就是AI已经完全接A我从你们公开的资料里有一个没看懂的是说，为了训练这个Wareway，你要自己购建一个虚拟的世界虚拟的城市对，然后在这个里边把所有可能的就让他像一个人一样去学习这个世界是。但是你这个虚拟出来的怎么会比就是我们这次世界里在这次世界里跑这些车采集到的那些这些数据更完善呢？我们就是拿这些数据进行重建加生成，因为你只生成是不对的，所以我先做重建然后再做生成，就跟物理世界一模一样的。所以后边的话，强化虚拟需要两个要素，你是拿着真实的数据然后去购建这个虚拟世界，然后再用AI辅助生成原来没有被重据到的是的。所以这里边有两个技术，一个是重建技术，重建技术本身有一个缺陷就是它不够丰富对它一个生成技术，但生成技术没法还原物理世界，所以我们是先做的重建再做的生成。所以呢，我们购建这个技术的关键人才就是我们当时招了几个人要他们本身就过去的时候在做Cosmos这套体系的，所以我们跟沟通这方面也挺多的。然后因为做强化虚拟尤…其实，物理世界强化虚拟AI的话，其实需要两个要素：一个是环境，要是真实的环境；然后第二，要生成数据。所以我们在这里边，既构建了环境，又生成了数据，从而在里面去做强化训练。所以，比以前的方式——那个方式里边不能被穷举的——在你这也能被合理生成，而且完全还原，跟物理世界没有任何区别。听起来还挺兴奋的，但巨烧钱，都是堆显卡，上万卡。上万卡的家，就是一万卡、一万卡地堆显卡。你们现在用了多少卡？我们现在等效的卡应该有五万卡了吧？五万卡了。所以你是把正的利润什么都砸进去做研发了？哎呀，真的一年投六十多亿，今年也投六十多亿。但这个其实前景是特别令人兴奋的。我还是说，我特别相信乔布斯说的一句话：硬件的壁垒只有六个月，然后软件和系统的壁垒可以拉长到一年、三年以上。iPhone 第一代发布的时候，他说他最核心的就是，“我是领先业界五年”。我们那时候都是果粉，还是觉得“领先五年”是不是吹牛？因为科技企业巨头和巨头之间，能领先一年就超级牛了。他说领先五年，但后来我们看安卓的进化过程，一路超和追赶，还是真的用了四五年才真正逼近它的水准。这一点，是真的一点都没吹牛。包括你看 AI，我特期待……我再补充一下，包括咱们看预训练这个领域里，大家看，因为大家都鼓吹大体系，大家都说要超过 GPT 体系。然后从三年前说到今天，没有一个跟它接近一点。是是。其实你再想想，其实两年、二三年的时候，OPEN AI 推出 ChatGPT 3.5 的时候，也是说很快人工智能就能解决所有的问题了。然后呢，甚至刚才讲的说，而认为人工智能以后不需要这些工具、不需要这些应用，它都能做了。对。今天其实大家做的最多的是 Combinatorial Use，做的是 Agent，是 To Agent，对，做的是怎么去调用工具。我觉得大家还是都发生了认知上的变化。有一些是过于乐观了，但也有一些进步真的比想象的快。比如说近期——不是近期，大概有半年了——就是看那个很多自媒体、科技媒体做的那个叫“本周 AI 大事”，有时候看得就晕晕的，信息都看不完。然后去试的话，当然他们有一些标题党，把一个做得一般的吹得很炫，但也有很多你没太在意，试一下发现真的特别厉害。是，就这种。所以 AI 真是特别兴奋，没想到还能赶上这么一个时代。所以我觉得 OPEN AI 最开始真是聚集了一帮全行业最顶尖的人才。而且呢，我觉得 OPEN AI 我挺佩服的，它当时建立并定义了一个 AGI 的五阶段标准。我今天一看，一准，是比当年的而自动价值建立了 RER34 呢，要比那个定义多。它当时定义的第一个阶段是 ChatBot，聊天机器人；然后第二阶段是 Reasoner，是推理者；然后第三个阶段是 Agent，智能体；第四个阶段是 Innovator，创新者；第五阶段是 Organizer，组织者。我们发现其实今天就是在往智能体上走，预判全是对的，判的都是对的。但是有很多东西，想着不想。它认为智能体能干所有事，但今天智能体还要去调用工具，跟人一样要去使用工具。而且从逻辑上，也是一个通用的跟一个专项的、针对垂直的去专门干这件事。我不知道，因为我们未来有可能人工智能远超人类的水平的时候，我们也判断不了——是我们成低级生物了。在那天到来之前，你去想，一个通用的怎么都不可能在一个具体做实事的领域里干过一个垂直的吗？是，就同样投入的情况下。但是我觉得它有可能到了第五阶段，就它讲的组织者的时候，它又具备这能力了，它可以就不用人、不用人意的去调用智能体就可以了。对，就是因为今天是我们人类为其选不同的智能体，还要跟智能体互动得很好。但如果到时候真的有一个它说的组织者出现了，那其实是……到时候如果没有这个应用或工具，它自己就写出来了。现在其实某种程度上也有这两种能力。我的意思，将来它可以完整的自己完成这件事，是因为到了第五阶段的时候，各种的工具已经非常齐备了，各种的智能体已经非常专业，各专业领域都很强。但有没有一种方式，把所有的这些专业智能体组织成一个？不敢想。你现在对 AI 给人类带来的长期命运是偏乐观还是偏悲观的？我觉得是乐观中带着谨慎吧。对，跟我讲的真实一样。我自己看到三个阶段，因为我觉得它讲的第二阶段和第四阶段其实是一个能力，不是一个产品。我觉得 ChatBot 是个明显的产品，ChatBot 背后其实就是那个大模型。那大模型跟我们增强了一些能力，我觉得这是一个表现，增加了我们一些知识、一些能力，但它并不能帮我去做事，因为它没有 Agent 能力。所以到了智能体，我没说错，就是它会变成我的同事，但它跟同事一样是专业的，就只有销售，然后包括我们创造一个司机，是我们同事，只是它是服务 To C 的，把它分配到了消费者的车上去工作。所以我觉得这个阶段，只有到智能体阶段才会产生 iPhone 时刻。因为我认为 ChatGPT 3.5 不是 iPhone 时刻，更像是互联网早期的时候，聊天室阶段，而不是 Google 出现的时候；如果是手机的时候，它可能更像黑莓，而不是 iPhone。然后我觉得智能体，就是我的同事，它要么跟我一起工作，要么其实它还承担一个角色，即服务我们的消费者。我觉得这是一个阶段。然后第三个阶段，创新者，其实很难描述，因为它是工作的一个状况。然后如果是第五个阶段，我就知道它会成为我的家人，它会连接我的所有的一切。而且我说我的所有的经验、我的认知、我的记忆都会被他延续。我觉得它讲的“组织者”特别像是它当初院组织者形象的时候，我脑子第一个蹦出来的是 J.A.R.V.I.S.，是最终阶段的 J.A.R.V.I.S.。J.A.R.V.I.S. 很重要的一点是，它把 Tony Stark 的能力其实都给延续了，然后在 Tony Stark 在复仇者联盟中去世以后，它继续帮着管理 Stark 公司，跟那个跟那个他的朋友处理，然后它还在帮着照顾小辣椒和他的孩子，还在帮着蜘蛛侠——他的好兄弟——去造战衣。我觉得我自己认为，在我们的有生之年，这件事是可以实现的。但是后面呢？因为如果它比人强个一万倍、十万倍、百万倍以后，我们怎么能保证它为我们服务？这是另外一个问题。我觉得其实人类有知识、有能力，还有智慧。地球的这个文明的发展是这些原因，人也不是跑得最快的，我们也遇到很多很多对。但它智慧可能原来也超过我们，因为现在没有证明它智慧怎么样，对吧？因为人类的智慧也很长很长时间没有发展了。今天我们讲智慧的时候，其实西方还是溯源到苏格拉底、柏拉图，中国今天大家还在讲孔子、老子，对吧？自上古跟那个时候比，生物特性上应该没有太多进化。对，然后比较近的一点的话，大家还在讲王阳明。我们看的科幻片也都是一样的，就是它已经能够星际穿越了，已经有人工智能了，已经跟记忆人在一起生活了，但是你会发现这些星球上的领袖，这些智慧好像跟今天也没什么进步。所以我再思考一个问题：其实我们可能会有一个机会，包括我们今天的学校也不培养任何的智慧。以后知识不是问题了，为什么不培养智慧？所以我在想一个问题，人类会不会因为 AI 的倒逼，获得一次智慧的跃迁？这也是人类的一个可能为数不多的机会。但我们事实上作为生物的进化速度是很慢的，还是要借助比如说变成半人半机器这样的方式才有可能，我都有可能。所以我说，如果我们智慧有一个跃迁，我觉得可能人类还是至少这个地球文明的统治者；如果我们智慧没有跃迁，那没有办法，就肯定被淘汰了，就肯定被淘汰了。我其实这个还是挺悲观的，但是又觉得我本来性格是很乐观的，但这个事听起来无解。就是说，如果它比我们聪明，并且聪明很多很多倍，你作为一个低端的生物和智慧，你其实是不可能保证什么或控制什么的，什么都不现实。所以我唯一看来，就是会不会倒逼人类智慧有一次显著的跃迁？那你从这个角度怎么看伊隆·马斯克做脑机接口？很大程度上也是为了解决人和机器、人和 AI 的带宽问题。你觉得这个事有可能改变什么？或者你想到过别的方案吗？这相当于把它摆 AI 的能力跟人直接结合在一起吗？对，对，我觉得它肯定是一个好的选择。你研究过这块吗？没有，没有。对，理想的十年，哪些目标完成了？我自己觉得我们做的几个挺牛的产品：对，理想 ONE 是一个，然后 L9 是一个，然后 Mega 是一个，新的 L8、L9 是一个。因为我们在十年做的每一个都是非常非常非常好的产品。对，这个我是完全认同的。这个产品是我当时创办的时候想象不到自己能把产品做得这种水准，没想到把硬件能做这么好，也包括软件。但软件对你本来就不是问题？我觉得软件还没有真正……软件我们做得非常不错，但是我觉得软件真正的证明是在人工智能。我知道，但我就说人工智能还没有达到我们预期之前，你们那个因为我自己做软件产品，已经我会对这个特别挑剔，然后买了你那个，我就觉得基本上所有都是对的。我觉得苹果对我们的影响挺大的，包括你看我们苹果上的原设计，对，然后包括图标设计，包括一些交互的一些方式。其实我们有时候也经常会问一个问题：如果是乔布斯设计，会怎么设计？但是大家会延续苹果的东西。包括我们在做工业设计的时候，也经常问一个问题，比如说这块装一个镀铬条，有的团队说因为传统车上还做的会很好玩，我们内部也会问一个问题：如果是乔布斯设计的话，它会装这个吗？那说不会，那我们就把它摘掉。我也觉得不会。对，我觉得这些对我们内部影响其实还是苹果对我们的影响烙印还是挺大的。当然，因为全世界做产品的人，苹果就是绕不过去的一座大山吗？是。他们在讲很多东西的时候，就是到今天为止，当然现在大家开始开始怀疑了，比如说那个灵动岛的方式，我们其实就没学，所以我们觉得那个有点多余了。对，完全对了，变而变我也觉得，然后甚至连可靠性都没有想清楚，在这么大的公司里居然能通过来上市？对，这也挺离谱的，有点点问题。你几次创业都有“家”的概念，比如说“车和家”，汽车之家，这家公司，这家，对，然后现在把一个传统上被公众几乎认为就是商务车的也给做成了家用，后面就卖个后面对。所以我想知道就是你自己一个人对家庭这个东西有比一般人更强的某种情感，还是执念，还是什么？有这些东西，除了商业上的需求之外或定位之外。其实它是不同的阶段。我觉得最开始做显卡之家的时候，其实没有大家想现在那么复杂，对，其实我们当时学的电脑之家，因为当时有叫 PC Home，明白明白，上海的一个非常好的网站，对，就是因为这个名字很好听，对，然后也不用重新教育用户，没想那么多。而且那时候你也不太可能，一个小伙子吗？对。然后其实“家”也是这样的，也是，也没成立家庭这样子的。然后在做理想汽车的时候定位家庭用户，因为那时候我已经有，对，2015年的我，今天有两个孩子，后来我又多了几个孩子，对，所以对这个整个的认知也会越来越不同。然后我另外一方面也可能真的跟什么有关，就是我小的时候跟父母在一起时间很短，到小学的时候都是跟着我老姥爷长大的，然后我到上初中开始，为了上学、为了上特别好的初中，然后其实我又一直长期住在我奶奶家，所以跟父母住在一起的时间其实并不多。18岁开始创业，然后很快就来到北京，很多时候是跟我爱人。然后结了婚以后才发现，其实家庭这东西，停止……原来我也不觉得自己缺什么东西，但是发现家是个非常非常宝贵的东西。你是一婚？就是现在这个太太，然后一直到今天？是的，感情一直很好。是我们2008年然后领的证，2009年结的婚，一直很稳定。是，而且这感谢那一次那些低谷的变化，因为原来我老认为我问题都是另外一半的，现在就是我觉得能打开，通过那个反省，一直反省到家里去了。我觉得我跟我老婆的关系有一个非常有意思的事情，还是受益刚才我说那件事情，就是我跟我老婆在一起以后，我就表达了一个很明确的观点：我需要她，远超过她需要我。而且是事实也是这样，我真心这么想的，也会直接告诉她。对，我觉得这个其实是我们关系的一个很重要一点。而且呢，我也……我老婆因为她也希望其实她对我是重要的，她其实能帮助到我。而且呢，她挺有意思的，就是比如我做这个汽车行业，她每天在管家里，但是她对其他行业非常了解，她看各种各样的行业，她看每个公司的财报，甚至很多别的汽车公司出现的事情，就是她因为我忙工作，我很多时候我没有那么关注别的公司，但是她给我讲，讲很多信息，是她对别的品牌发生了什么事，然后那个公司财报怎么回事，我觉得这个特别有意思。她还会塞一些有用的跟你说？对，是这样的。然后你感觉一些有压力的时候，她知道，她不跟你说我那些，就是我的老的那些什么脆弱什么的，他们老以为我就是找了一个我的女粉丝，但实际上我在家里基本上出来的事她也不该设，家里事其实我百分之百都听她了。所以就形成有的时候她会恶心我说，你出去就假装我是你的粉丝，自然根本不是这个关系。所以我觉得这个还挺幸运的，就是说刚才咱们聊过，就很多创业家这个家庭这块不好的话，真的，她就没有最后一个我们说的熟悉一点叫港湾也好、叫什么也好，就没这个东西，其实真的特别苦的一个事。因为在家里的话，也都是在家里说的事都是我老婆做的事，然后我挣的钱然后也都交给我老婆，这个感觉特别好。我就看到的是咱们那个移动互联网十年，就很多小伙子、年轻姑娘什么的，就赶双时代机遇做得也好，然后不就发财了吗？其实离婚率也很高，你看过吧？离婚率特别高，反正媒体有时候会挖这些。我没有，反正很多的。其实其实是这样。对，因为你是非常成功的企业家，然后生出这么多孩子……在我还年轻的时候，没想过将来可能会出现所谓的“豪门恩怨”之类的事情。因为我们看到很多成功的企业家，到了晚年，子女为争夺遗产闹得不可开交——这种事情近期不也有发生吗？你对这个想过吗？倒不是说很认真地去思考，但我把这事情交给我妻子了。我老婆从小就教育我们的孩子：兄弟姐妹之间不允许做任何斗争，必须维护整个家庭的利益。从小就让他们关注这些。你对你自己的孩子在这方面非常有信心，是吧？这些钱财一类的东西，其实影响力挺大的，是真的会影响他们。有时候孩子在家也会打打闹闹，但一出家门，他们在一个学校，就特别团结。我觉得这一点真的要从小去影响。你想过如果这十年你没做汽车的话，可能会去做什么吗？我猜你在决定做汽车之前，也考虑过其他几个方向？没有，没有反复去想这件事。没有想过。就是在做汽车之家的过程中，到后期决定做汽车了，然后想清楚，就一直往前走。并不是有两三个难以取舍的选择，没有。虽然很累，但其实整体还是很开心的。对，我觉得这其实是幸福感很强的，挺开心的。制造业里最复杂的，一个是汽车，一个是手机。真的，在工业上就是极致复杂，根本没法“躺平”。而且你看我和团队里的小伙伴，基本上一年见一两次，每次大家再见面，都会觉得：哎，大家又老了一些。你想过退休以后的事吗？没想过。应该没想过，真没想过。所以我觉得这不是个好问题——但我一说，就被问，其实这个问题是合理的。每个人的情况也不一样。有的人你看，退休挺早的，觉得挺好。是不是我也应该五十多岁、六十岁就开始退休？包括乔布斯，去世那么早，五十岁就走了，他是被迫的。另一方面，其实时代也在变化。今天你又看到，像黄仁勋六十多岁了还在工作，还那么拼，状态很好。而我又看到身边有些比较早退休的人，好像没那么幸福。能够真正快快乐乐、毫无贡献和成就感的享受生活的人，其实从基因上讲是少数。包括马云最近回到阿里以后，感觉他特别开心。你看他每次出现的表情，那个我知道，肯定不是装出来的。所以我说，也可能工作就是我的命。我平安，还是很好的。该跟孩子在一起就在一起，该跟爱人在一起就在一起，该有些自己的爱好就有些爱好。所以工作对我而言不是什么负担，是件挺开心的事情，而且每天跟同学们在一起，挺开心的。但我想说，你觉得像做科技公司负责人这样的事，能干到七十多、八十多吗？我可能只有一个判断标准：只要我不是这公司的负担。我用这个做判断。如果我是这公司的负担了，是不是还占着这个位置？有这个感觉，我就得应该有自知之明，主动撤开。明白。我觉得我有这个自知之明。就像当时我认为秦致比我更强，我就从CEO退到总裁，他从总裁升到CEO。我觉得我有这个认知。你现在团队还没有找到第二个“秦致”，还没有？对。因为汽车业务还是个超级产品主导的。明白。说到这个，我想问一个不太客气的问题：除了你之外，你觉得中国这波造车新势力的老板里，谁也是一个超级产品经理型的老板？李想。对，就是李想。只有你们俩是真正懂产品的，或者说，能做出超级产品来的？是这个意思。但当然，你还要有水平——光有付出也没用，它得是一半一半的。你得是一个天才的产品经理，加上极度努力的付出。说白了，就是你在工作中得是一种状态：跟设计团队、研发团队、产品团队生活在一起，而不是说我是个老板，定期去做个评审。这肯定不行，这肯定不行。那只有传统老板——那些做油车的老牌企业的老板们，才有可能那样。雷军宣布不造车的时候，你紧张过吗？没有紧张过。而且确实，雷军还专门给我打过电话。雷军也跟我聊过一天。那时候还在疫情期间，我印象最深的是，我们打了将近两个小时电话。因为我后来还有一个面试，他就一直拉着我不停聊，推迟那个面试——是一个半夜的面试，因为那个人在海外，我们在面试一个海外员工。他当时问我对于特斯拉的看法、对比亚迪的看法、对华为的看法，聊了很长时间。最后他说：你只给我一个建议的话，你会怎么说？我说：我不要找任何的代理人，你自己干，亲力亲为，就能成这事。那是我当时给他的唯一建议。但后面我们遇到很多事情的时候，其实雷军……雷军帮过你们忙？对，他帮我们很多。我猜在你做出车之前，他有可能怀疑过？因为传统互联网公司出来的，确实很少又能把硬件做成功的。最初的时候……行，那咱们先这样吧，别耽误你太多时间。谢谢谢谢，谢谢你，全程状态都特别好。好，我们俩在这儿聊得挺好。可以可以。"
  },

  {
    "url": "/ai/2025/08/02/%E5%85%B3%E4%BA%8EAI%E5%BA%94%E7%94%A8%E7%9A%84%E6%80%9D%E8%80%83.html",
    "title": "关于AI应用的思考",
    "content": "关于AI应用的思考与IA共创1. 梯人纵发展目前的速度AI工具及应用层出不穷，几乎每天都会有新的style出来，从应用的角度来看有点应接不暇。从单纯的chat聊天模式开始，会发现有一部分的内容AI其实处理的不是很好，即使用到了一些先进的prompt词也不一定会有效果。这个可以想象AI技术能力的提升也是依赖于海量的知识数据，如果现行互联网的数据维持在一个相对静态的状态下，单纯靠AI在此基础上升华创造，不是说不肯能，只是需要的时间会更长。其实反过来如果在AI的加持下，通过人类的思维创造出更高维度的知识或者解决问题的思路，把这些方式公开到网络上，让AI进行提取学习，可能这种发展离真正的“智能”会更近一步。这种模式就是左脚踩右脚的模式，一步步靠近终极目标方向。2. 企业应用AI Accessibility现在AI应用无处不在，日常文案的优化、生活和工作中遇到问题会先用AI进行科普扫盲、AI Coding、代码review、调研报告等。但是可以看看真正企业与AI的结合程度如何？按照目前阶段来说还在初级阶段，目前使用的模型都是基于现有公开的网络的数据进行训练的，那么对于企业本身的数据在公网是无法被访问到的，这里面包括企业运过程中产生的数据、文档、知识库、业务领域知识、企业文化、日常工作流程等。成本角度  大多数企业不太可能基于开源的模型进行训练自己的私有模型，这个训练时需要额外的开销。当然大公司或者一些医院机构在使用AI的时候，会考虑用模型进行训练，给AI投喂的都是私有数据，在这种情况下进行使用的。安全角度  数据安全是目前企业考虑的一个方面，担心敏感隐私数据泄漏。这也是目前AI与企业业务结合相对慢的一个原因。这个当时也是可以解决的，就是把敏感数据排除在外进行脱敏处理，再让AI访问。从未来的角度看，如果那一天公司的相关数据能够被AI学习，那么有一天可能会出现的几个场景如下：  企业文化深度融入AI，大家日常工作中的行为、态度如果做的有不符合企业文化方面，系统会通过即时通讯工具进行提醒、在做决策时如果违反企业文化同样会被提醒，并给出对应的解决方案。  在软件研发时当一套方案出来时，AI会结合历史业务、业务代码、产品文档、知识库等直接给出方案是否可行（给打一个分），对于决策者只需要根据AI给出的结论再一次思考及决策。  日常的事物处理流程、会议形成、事情准备、日常团队沟通、培训这些，变成了AI每天或者提前规划一个人的事情，并给出重要性及优先级设定等。以上虽然目前还做不到，但是在不久的将来一定会如期而至。效率提升不等于生产力提升1. 效率提升当前AI coding是发展的非常迅猛，几乎头部公司都在开源自己的模型，从AI coding 模型的演进、AI IDE、围绕产研环节的产品非常众多（从0到1打造一款产品）。甚至在早期在国外有一些团队只有几个人凭借AI产生出几倍的ROI（这不是噱头）。对于AI从业者来说，效率的确是提升了，以工作为例，效率提升后是不是会有一些空闲时间去做其它的事情。从工作和个人方面来说可以借此机会去触达AI目前还不能涉及到的方面，例如个人成长、个人能力提升、AI实践方法论、以及使用AI过程的盲点梳理。代码编写提升效率60%，项目单侧覆盖80%，这些是AI现阶段的强项，利用这些的时候多一些自己的思考见解。2. 生产力提升效率的提升对于单次产出的确很明显。但是如果需要从生产力提升方面将，还需要多探索。例如这种效率的提升是否可以产生规模效用，使用过程中的SOP是否具有通用性，是否可以复制。这次是AI Coding的提升，那么下一次是否可以从需求理解开始到最终的交付，这个过程中如何让AI参与80%以上，真正达到AI工具在”干苦力“，对于这个过程中的使用者来说就有更多精力花在项目稳定性、安全性、可拓展、以及技术架构演进，相当于把效率本身做了一次升华及放大。生产力提升的同时，对于AI使用者来说也是能力的升华及迭代，提升AI从业者的竞争力。使用技巧在日常Al使用时，可以使用过程中的问题分为两类，待解决问题库和已验证问题库。1. 待解决问题库就是把工作中通过Al解决的，但是现在的模型还做不到的硬骨头，全部记下来，“例如根据这张草图直接生成可用代码”、“根据产品方案直接生成业务代码，达到可交付的目的”、“参考某款App的UI及业务进行复刻”等。2. 已验证问题库把你那些能够用尽AI潜力的，好的提示次（prompt） 和 交互技巧分门别类记录好，方便下次继续使用。当新的模型发布之后，不要只光看测评、不要迷信测评，可以直接用待解决问题库的问题，扔给新模型或者新工具，看看之前的问题是否能够得到解决（是骡子是马拉出来溜溜）。"
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/nginx/2025/07/01/Nginx-Ingress-%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5.html",
    "title": "Nginx Ingress 高并发场景优化实践",
    "content": "在高并发/高吞吐场景下，Ingress-Nginx 的瓶颈往往在四处：连接与端口、文件句柄、握手与 TIME_WAIT、日志 I/O。本文给出值可直接落地的 Helm values.yaml 片段、Linux 内核参数、日志轮转 sidecar、压测与观测清单。1. 云负载均衡（CLB/NLB）容量  选择性能容量型/增强型实例，并调高带宽上限；入口成为系统上限的概率远高于后端。  自建 CLB 后通过注解/固定 loadBalancerIP 复用为 Ingress 入口。2. Linux 内核参数（容器内以 initContainer 动态设置）Helm values.yaml：controller:  extraInitContainers:    - name: sysctl      image: busybox      imagePullPolicy: IfNotPresent      securityContext:        privileged: true      command:        - sh        - -c        - |          sysctl -w net.core.somaxconn=65535          sysctl -w net.ipv4.ip_local_port_range=\"1024 65535\"          sysctl -w net.ipv4.tcp_tw_reuse=1          sysctl -w fs.file-max=1048576说明：  somaxconn 提升监听队列，缓解 SYN/accept 队列溢出。  ip_local_port_range 扩大源端口范围，降低端口耗尽风险。  tcp_tw_reuse 在客户端侧端口紧张时复用 TIME_WAIT（谨慎，仍以观测为准）。  fs.file-max 与容器 ulimit/worker_rlimit_nofile 对齐。3. Ingress-Nginx 配置（连接与工作线程）controller:  config:    keep-alive-requests: \"1000\"                 # client &lt;-&gt; ingress 单连接可承载请求数    upstream-keepalive-connections: \"2000\"      # ingress &lt;-&gt; upstream 空闲长连接上限    max-worker-connections: \"65536\"             # 每 worker 可开的最大连接数要点：  keep-alive-requests 过高可能导致扩容后负载不均；建议结合压测观察。  upstream-keepalive-connections 是空闲连接上限（非总连接数）；按 worker 数乘算总上限。4. 日志落盘与轮转（降低高并发下 stdout CPU 开销）controller:  config:    access-log-path: /var/log/nginx/nginx_access.log    error-log-path: /var/log/nginx/nginx_error.log  extraVolumes:    - name: log      emptyDir: {}  extraVolumeMounts:    - name: log      mountPath: /var/log/nginx  extraContainers:    - name: logrotate      image: imroc/logrotate:latest      imagePullPolicy: IfNotPresent      env:        - name: LOGROTATE_FILE_PATTERN          value: \"/var/log/nginx/nginx_*.log\"        - name: LOGROTATE_FILESIZE          value: \"100M\"        - name: LOGROTATE_FILENUM          value: \"3\"        - name: CRON_EXPR          value: \"*/1 * * * *\"        - name: CROND_LOGLEVEL          value: \"8\"      volumeMounts:        - name: log          mountPath: /var/log/nginx5. 端到端压测与观测  压测：wrk（HTTP/1.x）、h2load（HTTP/2/3）、vegeta/fortio；建议 10–30 分钟稳定压测并观测收敛。  指标：活动连接、连接错误、$upstream_response_time 分位数、5xx 率、worker_connections 使用率、TIME_WAIT 总数、端口使用率。  日志：使用 JSON 格式，记录上游地址、上游时延、路由信息，便于定位热点与异常。6. 常见排障路径  端口耗尽：增大 ip_local_port_range，提升上游 keepalive，排查异常关闭；观测 ss -s。  队列溢出/5xx：调大 somaxconn 与 backlog，核查上游超时/重试策略，查丢包。  CPU 飙升：stdout I/O 抖动，切换日志落盘+轮转；或减少日志字段。参考链接：  高并发场景优化（外部实践指南）：https://imroc.cc/tke/networking/ingress-nginx/high-concurrency"
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/nginx/2025/06/28/Nginx-%E9%9B%B6%E5%81%9C%E6%9C%BA%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E4%B8%8E%E5%9B%9E%E6%BB%9A%E7%AD%96%E7%95%A5.html",
    "title": "Nginx 零停机灰度发布与回滚策略",
    "content": "从运维架构视角，结合 Nginx 的多种路由能力（权重、Header/Cookie、子域名、子路径）与容器编排（Docker/Kubernetes），构建“低风险、可审计、可回滚”的上线流程。本文给出平滑发布步骤、生产级配置、容器化集成与回滚预案。0. 目标与原则  不中断：对外 0 失败率、0 连接重置；  可回滚：故障秒级回退；  可观测：全链路指标与日志可追溯；  可审计：变更有记录，可复现。1. 平滑发布（通用步骤）1) 版本准备：构建 v2 镜像（含健康检查、版本信息接口），在 v1 旁路启动；2) 预热：v2 只接入探活与预热流量（本地缓存、JIT、连接池预连接）；3) 小流量灰度：按 1%/5%/10%/20%/50%/100% 切流，每步 5-15 分钟观察 SLI；4) 监控门禁：4xx/5xx、P95/P99、错误率、特定业务 KPI（下单/支付成功率）；5) 扩展面：流量达到 100% 后保持观察窗口（30-60 分钟）；6) 收尾：下线 v1 或保留一段时间作为热备用。  SLI/SLO 建议：错误率 &lt; 0.1%，P95 &lt; 目标阈值（如 300ms），下单成功率不下降。2. Nginx 路由策略2.1 权重切流upstream svc_v1 { server 10.0.0.1:8080 max_fails=2 fail_timeout=10s; }upstream svc_v2 { server 10.0.0.2:8080 max_fails=2 fail_timeout=10s; }map $upstream_choice $backend {  default      svc_v1;  v2           svc_v2;}# 灰度权重由外部工具写入变量（例如 lua_shared_dict / env / include 片段）map $cookie_gray $upstream_choice {  default      v1;  ~*gray=1     v2;  # 指定用户灰度}server {  location / {    proxy_next_upstream error timeout http_502 http_503 http_504; # 故障向上游重试    proxy_pass http://$backend;  }}2.2 百分比灰度（无 Cookie）借助 Nginx JavaScript（njs）或 lua，按哈希实现稳定的百分比切分：# 伪代码：基于 IP/用户ID 哈希到 0..99，&lt;10 命中 v2（10%）优势：用户命中稳定，不会在刷新间抖动；便于问题复现。2.3 子路径/子域名灰度  子路径：/v2/ 仅路由到 v2，便于 A/B 对比；  子域名：v2.api.example.com 专供内测或机器人流量。3. 容器化集成3.1 Docker Compose（蓝/绿）services:  nginx:    image: nginx:1.25    volumes: [\"./nginx.conf:/etc/nginx/nginx.conf:ro\"]    ports: [\"80:80\"]  app_v1:    image: app:1.0.0    healthcheck: { test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8080/health\"], interval: 5s, retries: 5 }  app_v2:    image: app:1.1.0    healthcheck: { test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8080/health\"], interval: 5s, retries: 5 }  切换方式：通过替换 map 变量/包含片段，或修改 upstream 指向容器服务名；  回滚：即时切回 app_v1。3.2 Kubernetes（Ingress/Service）  Ingress-Nginx + 两个 Service（v1/v2），通过 canary 注解分流：    metadata:annotations:  nginx.ingress.kubernetes.io/canary: \"true\"  nginx.ingress.kubernetes.io/canary-weight: \"10\" # 10%        替代方案：使用 nginx-ingress + njs/lua 做更复杂的路由，或使用 Gateway API/Service Mesh（Istio/Linkerd）进行百分比灰度、熔断、重试与熔断。4. 策略矩阵与适用场景  权重路由：最通用，适合整体灰度；  Cookie 灰度：便于定向用户/业务方验证；  Header 灰度：CI/CD/自动化探测流量；  子路径/子域名：A/B 实验或大版本对照；  哈希百分比：稳定命中，适合逐步放量。5. 生产案例（示意）  背景：交易系统网关，QPS 峰值 3w/s；  步骤：1) v2 部署完成，预热接口返回 200；2) Cookie 灰度给内部账号与监控机器人；3) 百分比灰度 1% -&gt; 5% -&gt; 10% -&gt; 20%（每步 10 分钟），观察错误率、P95、下单成功率；4) 50% -&gt; 100%，保持观察 30 分钟；5) 稳定后下线 v1，保留应急镜像与配置。  指标与日志：接入 Prometheus/Grafana，日志落 ES/ClickHouse，保留版本号与路由信息便于追踪。6. 回滚策略与演练  触发条件：错误率 &gt; 0.2% 或 P95 恶化 30% 且持续 5 分钟；  动作：1) 立即将灰度比例设为 0（或 Cookie 开关关闭）；2) 恢复 v1 权重至 100%；3) 保持观察窗口（10-30 分钟），同时收集 v2 诊断材料；4) 进入问题单流程与修复迭代；  演练：季度至少一次“带压回滚”演练（非峰值时段），验证脚本与值守响应。7. 关键配置清单  上游健康检查与 proxy_next_upstream 策略；  keepalive 连接池，proxy_http_version 1.1 与关闭 Connection: close；  请求超时/重试上限（避免风暴）；  限流与熔断（njs/lua 或接入网关/Service Mesh）。8. 审计与自动化  配置即代码（Git 管控），灰度参数来自集中配置；  CI/CD：合规检查（lint）、预热检查通过才允许放量；  ChatOps：发布与回滚都有机器人宣告与记录。9. 常见坑  预热不足：v2 首次请求抖动；  粘性策略缺失：会话跨版本导致登录/购物车异常；  观测延迟太长：等到告警触发时已影响大量用户；  权限与合规：回滚权限受限导致响应慢。  结论：Nginx + 容器编排可实现高可靠的零停机灰度。把“参数化灰度 + 可观测 + 自动化回滚”做成流程与工具，才是长期可靠之道。"
  },

  {
    "url": "/%E5%B7%A5%E5%85%B7/2025/05/13/%E5%85%85%E5%88%86%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E4%B9%8Bgithub.html",
    "title": "充分使用工具之github",
    "content": "定期追更的项目：1. Weekly（科技爱好者周刊）2. 《HelloGitHub》月刊无边界的学习资料库1. Librarian-pku 北大全套课程资料2. 清华大学计算机系课程攻略3. BiliBili公开课目录4. 从小学到高中所有教材5. 各教育机构学习资源6. 感觉把中医的知识全放进去了，推拿针灸啥的，几十T，应有尽有7. 各种各种资料，影视、学习、读书、自媒体神仙设计资源库1. design-resource2. Awesome Design Tools3. 中国色彩4. 字体[得意黑]Smiley Sans5. 白情包博物馆 ChineseBQB不只用来学习的GitHub1. 程序员做饭指南2. 996.ICU3. 各种资料、知识、影视、记录片、音乐、书籍、媒体聚集地，持续整理中GitHub依然固执地生长着最开放的互联网精神。"
  },

  {
    "url": "/ai/2025/05/04/AI%E8%BE%85%E5%8A%A9%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84LLM%E9%80%89%E6%8B%A9%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html",
    "title": "AI 辅助编程中的 LLM 选择最佳实践",
    "content": "AI 辅助编程中的 LLM 选择最佳实践看开发阶段、试不同模型、管好成本，最终找到最适合自己的方案软件开发有不同阶段，每个阶段需要 AI 的不同能力。开发分成四个阶段，并给出如何选择模型的建议：1. 设计与架构阶段      需求：这个阶段你需要一个能深度思考、有丰富知识的模型，帮助理解业务需求并设计架构。        推荐模型：OpenAI o1、Gemini 2.5 Pro、DeepSeek R1        为什么选这些：这些模型推理能力强，能帮你做出清晰的早期决策        成本建议：这里值得用高级模型，因为好的架构能省下后期改动的麻烦  2. 开发阶段      需求：写代码时，需要模型能理解代码模式、建议补全、解释实现        推荐模型：Gemini 2.5 Pro、GPT-4o、Grok 3        额外亮点：Claude 3.7 Sonnet 虽然基准测试分数不最高，但很多开发者喜欢，建议多试试        成本建议：简单编码用中档模型就够，复杂任务再用高级模型  3. 测试阶段      需求：写测试时，模型要能发现边缘情况、写出可靠的测试代码        推荐模型：Claude 3.7、OpenAI o1、GPT-4o Mini        成本建议：普通测试用中档模型，复杂或关键测试用高级模型  4. 部署与审查阶段      需求：审查大段代码时，模型要有大上下文窗口，能一次看懂整个代码库        推荐模型：Gemini 2.5 Pro、GPT-4o Mini、GPT-4.1、OpenAI o1        成本建议：高级模型能加快审查速度，节省时间，值得投资  实用建议：如何选到适合的模型除了按阶段选模型，还有一些实用技巧：      从小模型开始：先试试中档模型（如 Claude 3 Haiku 或 GPT-3.5），不够用再升级        任务分模型：在 Cline 中，可以为不同任务设置不同模型。比如头脑风暴用高级模型，日常编码用中档，写文档用便宜的        关注花销：用 Cline 的 token 计数器，看看哪些任务花钱多，优化模型选择        别只看分数：基准测试（如 MMLU Pro、Big CodeBench）只是参考，实际用起来可能不一样        多试试：在不重要的项目上实验不同模型，找到感觉        Plan/Act 分开选：Cline 有个 Plan/Act 模式，规划可以用推理强的模型（如 Gemini 2.5 Pro），实现用快又便宜的（如 Gemini 2.5 Flash Preview）  "
  },

  {
    "url": "/%E6%80%9D%E8%80%83/2025/05/03/%E5%AE%9E%E6%97%B6%E5%8F%8D%E6%80%9D%E4%BC%98%E5%8C%96%E7%AE%A1%E7%90%86%E8%83%BD%E5%8A%9B.html",
    "title": "实时反思优化管理能力",
    "content": "实时反思，优化管理能力回顾工作这么多年，从开始的基本的coding工作开始，一线资深研发到后来的技术决策者，再到后来的创业。这些工作过程中我体会到在技术管理方面有很多道理在人生道路上也一样。总结归纳为用三个词来形容：父母心、为人真诚、反思精进，这些也是我一直再坚守执行的。1. 父母心在最近两年家里有了小朋友，在照顾小朋友的同时会去学习如何照顾、怎么哄睡、怎么做辅食、对于一些游戏怎么交小朋友去做、平时在互动的过程中如何用精简的指令让小朋友明白你的表达是什么(特别是在还不太会说话阶段)，这些都是从书中去学习，过程中越觉得其中的理念跟管理相同。书里面所讲的不是数理化，而是一个人最根本的东西：好奇心、同理心、韧性、乐观、与遇到问题用不放弃。这里面也会谈到一个话题就是作为家长对于子女的期待是什么？是出人头地吗？放到现在这个时代背景下，大部分父母应该都不会是这个答案。我的答案也很简单就是有积极向上的价值观，长大了有自己独立思考的能力，即便没有大人的依靠，依然能够很好的过自己的生活。2. 为人真诚为人真诚，众多的管理方法都更像是术，而在这些技术之上是道的层面。这个真诚既是我们对自己真诚，也是我们对身边所有人都保持真诚的态度。说到真诚，我觉得它趋于一种价值观判断，甚至是道德要求，这部分无论在工作还是生活上都是相同的。对自己真诚：作为工作十多年的老兵来说，人的能力是逐步进行提升的，这个里面没有所谓的捷径。想提高、提升自己就得多精力一些事情，特别是经历所谓的“挫折”。踩坑不可怕，可怕的是不能真诚的面对，不能想法设法地赶上来（清晰的认识自己，往往大家总是强调自己会什么？而忽略了自己不会什么）。当我们在相对顺境的情况下呢，就会遇到另外一种考验，我们也不要膨胀，而是要始终带着一颗感恩的心。对别人的真诚：遇事情不能冲动，碰到冲突态度要好但是话重要。对一个人好，有时候可以一针见血，因为对人真诚当然也包括指出对方存在的问题，他可能会不好受，但是相信平静之后大部分人还是可以理解的。痛了，改了，就是更好的自己。3. 反思精进无论从事什么工作，最开始的部分都是从基础做起，遇到一些跨界的伙伴更是如此。回顾自己工作更是如此，能够逐渐成长、成熟起来，能够独挡一面，不断优化自己的能力，其实离不开反思精进这个方法。这个里面涉及到最基本的一个话题就是认知，让我不断反思的动力，其实是源于我想成为一个什么样子的人（这个很重要，真的很重要）。我一直相信人生是长跑，再难的事情也挡不住多年的专注与死磕，这里很重要的一个点就是一定要实践。这种模式就是：实践、认识、再实践、再认识的过程，循环往复以至无穷，而实践和认识之每一循环的内容，都比较地进到了高一级的程度。很多事情想做好，都不容易的，所以也希望你身处顺境时正视自己，遇到挫折时不被外界干扰。最后关于人生的意义。随着工作和生活阅历的增加以及年龄的增长，看多了一些身边的人情冷暖，生老病死。现在想来，我觉得每一个人在人生的不同阶段会有不一样的诉求。我还是觉得一个人活在世上应该不断努力不断精进，但是目的不是出人头地，而是自我实现和这一路的风景。如果你现在就要离开这个世界，闭上眼睛回顾这一生你会想起些什么呢？那个时候你会想起的事情和人才是你现在应该珍惜的。去追求更好的自己，但是不要太计较结果，活在当下。"
  },

  {
    "url": "/%E6%80%9D%E8%80%83/2024/08/25/%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B.html",
    "title": "你需要知道的事情",
    "content": "你需要知道的事情最近“黑神话悟空”游戏比较火热，看到有一句话就是直面天命，能量满满。想到游戏中角色扮演，想到生活中每个人也是一种角色，我们不也是在“扮演”吗？以下是近期的一些思考。1. 商业熟悉所有行业的底层逻辑，冷静的思考每一个行业(特别是作为商业投资者)。任何一个商业模式再变，商业底层逻辑万变不离其宗。日常生活中就有一些类似的场景，当你在一家餐饮店吃完饭后，老板说我们现在有个活动就是充值1000元，当前这顿饭免费(例如这顿饭价值200)，这个看似划算，可能当时一心动就充值了。理解本质的话这个顿饭并不是免费的，800/1000 = 0.8，相当于8折，就是用800充值抵1000。直接打折容易产生“产品价值被贬低”等副作用，而隐形打折却让人感觉占到了便宜又不容易产生“该产品质量有问题”等等的认知问题。类似的还有骗子的诈骗电话，你接到一个电话，对方操着很奇怪的口音对你说：“我是你领导，明天到我办公室来一趟。”，你一听就知道他是骗子，你甚至会觉得你不是在被骗而是在被羞辱。或许你会想：骗子现在也太不专业了吧，接受过培训吗？有成功率的考核吗？如果你有这样的想法，那你是在是多虑了。蹩脚的骗术才是高明的骗术，其实质是条件概率在起作用。把骗子人群分为易骗人群和难骗人群，比例各占（20% 和 80%）。易骗人群中60%容易得手，40%失败。难骗人群中10%容易得手，90%失败。骗子的得手率为20%，具体公式为：20%(易骗) * 60%(得手) + 80%（难骗）*10%（得手） = 20%，得手率20%意味着骗子打5个电话能骗到1个人，看起来 “效率有点低”。但是如果能把”难骗的人群“筛选出去。那么这个条件就是故意很像骗子，当难骗的人听到奇怪的口音明显感觉不是自己的老板时，会很快挂掉电话，这样，骗子就不用在他们身上多费口舌了，而骗子真花时间去聊的人群随之缩小为“易骗人群”，这样得手率就到了60%，即打5个电话可以骗到3个。条件概率不是骗子的独家武器，当它被用到正道时，可以发挥出难以想象的巨大作用。多和找真正的从业者交流，聊聊这行的底层商业逻辑。世界都在进步，你不进则退，没有一成不变的。2. 宏观、中观、微观的结合宏观规律、中观行业的基本面特征、微观交易上的、投资的技巧。 提早做未来5-10年的预判。大的宏观-&gt;中观的产业-&gt;微观的个体。99%是选择，1%时努力。选择错了，努力不值钱。对于年轻人或者是这个阶段的你，有时间可以与不同行业了解接触，即使当前跟我没有直接关系，也愿意去听，多问问why？因为这就是信息差。透过某个想象捕捉到背后的行业变化。在疫情前有一个外卖小哥负责片区的外卖配送，但是在做这份工作的时候，发现当时有一些餐馆的餐食就是预制菜，出单很快，甚至有一些店面都没有实际的餐厅。这个小哥当时打听到预制菜这一途径，自己也开了餐馆，等这波风口过了就把餐馆直接退掉，这也不为对于信息差的利用。反而到了现在你去餐馆吃饭，有一些餐馆还特别挂出牌子说明不是预制菜。即便在目前的传统行业中，也在爆发新的变化，比如台球厅、网吧等，整体模式相比5-10年前有巨大变化。用户在迭代，商业模式也要跟上。目前播客节目也比较好，在微观世界对于个体来说，可能单独的那一期播客或者文章很少能特别影响深刻的改变生活，可这一期、那一期、再加上其他主播或者节目的某一期，会碰撞出新的思路，总会链接到一起。就算现在没用，那也比刷视频强吧。3. 资产端回报到负债端回报资产端回报：资产升值，比如房价上涨负债端回报：资产不涨的前提下，降低成本，比如每年租金。过去二三十年，资产端回报太高，对于当时房子的这点租金根本看不上，同样那个阶段前存到银行产生的利息同样可能会被忽略，也从来没考虑过负债端回报。因为经济的整体走向，以及人们对经济的预期走势向好，整体因素作用直接购买房子带来的收益相比其它途径来的更快。不过现在大周期结束了，经济也是有周期性的，上行周期和下行周期相互交替，未来10-15年，大的宏观环境不支持太高的资产回报率了，应该投具有“负债端回报的资产”。 只有一代人腾出资源和空间，下一代人的风险偏好才会改善，这种大周期基本5-10年甚至更长时间。日本走了25年。如果目前你还在考虑职业规划、投资、创业，第一件事情是“稳”、当期现金流。一定要适应经济周期性的发展规律，如果所做的事情龉经济周期相反，那么最终的结果可能是努力了，但是收益并不是很大。追求资产端回报的时代结束了，是时候追求负债端回报了。4. 永远输钱的股民按照时间定律，要尽可能地做对事情，只要事情做得对，时间一长，想不进步都不可能。但是做对的事情并不容易，人总是在不断的犯错误。接下来的问题时，犯错误可怕吗？一个错误犯一次并不可怕，可怕的是同一个错误不断重复还不自知，当然比这更可怕的是，明知道什么是错误，明知道什么是对的，但依然要坚持错误。 在股市上，有输有赢是一件很正常的事情，但是有的故名永远只输不硬，这就有大问题了，因为让一直猴子来炒股，它可能输赢各半。有几点需要避免：不要把赌场当作投资的场合。 我们都知道长赌必输这句话，赌场玩的是一个零和游戏，考虑到赌场本身的运行成本，也就是庄稼必须抽取的费用，赌场是一个回报率为负值的地方。只要时间玩的长一些，再多的钱都必然会交给赌场。在股市中因为总有人觉得别人赔钱，自己能够把哪些“菜鸟”的钱挣到手，岂不知，想割“韭菜”的人，总是自己成为“韭菜”。投资和投机是有本质区别的。不要相信自己能够把我住时机。 我们从小被教育要把握时机，但是在股市中的时机难以把握。今天，但凡一个具备充足流动性的时长，资产的价格和它的价值就是一致的，因此不存在别人看不到，你看到的机会。有人看到某只股票下跌了10%，觉的自己能够便宜10%买到同样的东西，殊不知，昨天的这只股票和今天的这只股票不是同一个东西。股价是靠共识维持的，换句话说，当共识不在了，其价值也就不在了。不要相信自己看到了别人看不到的投资机会。今天，很多人投资喜欢买一些几分钱、几角钱一股的股票，因为他们觉得这些股票的价格已经低到无法再低了，只有向上的空间，没有向下的空间。事实上，一角钱一股的股票，未必比100元一股的更便宜。 一家股价不断上涨的企业，说明它的盈利越来越越多，这背后体现的是管理好，市场大，产品优。一家长期股价在一角钱徘徊的企业，其内部一定存在一大堆问题。在世界上任何人、任何组织、包括球队，都没那么重要，放弃他们，世界照样运转，更重要的是，我们可以把资源和专注度放在更有意义的事情上。5. 兴趣&amp;专业爱好最后不能当饭吃，是没有用的，得先养活自己。专业和商业的结合专业、兴趣很深，但不会把它转成赚钱，也活不下去。兴趣和最后的商业模式联合在一起。真正成功的大都是把自己的兴趣做成了事业，最难的是跨过爱好和商业化之间的鸿沟。一个事儿当你做起来毫不费力，但是别人很痛苦的时候，就是你的优势。6. 延展主业不可以放弃，但任何关联的都要延展。不要拒绝在任何一点上做延展，可以不测重于此，但不要拒绝新事物。各行各业只要愿意观察，还是有机会的。渗透率从0到1的时候是挖金子(赚钱),从1到10的过程是卖铲子(卖方法)。女装店：真正的逻辑是社交。日积月累的客群，是一个小社群的场景。如果创业那么商业逻辑必须非常清楚（变现），不是单纯的烧钱，最不确定的变量是“人”，合伙人很关键。创业时尽量选择同阶层的，能抗风险的、潜意识的社会资源更加匹配。新的行业、兴趣加上深度-&gt;专业，再多加一个商业思考，形成闭环。晚安！"
  },

  {
    "url": "/%E6%80%9D%E8%80%83/2024/08/18/%E6%95%B0%E5%AD%A6%E6%80%9D%E7%BB%B4%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F.html",
    "title": "日常思考问题的5种数学思维思维模式",
    "content": "日常思考问题的5种数学思维思维模式1. 从不确定性中找到确定性第一种数学思维源于概率论，叫作“从不确定性中找到确定性”。假如一件事情的成功概率是20%，是不是意味着我重复做这件事5次就一定能成功呢?很多人会这样想，但事实并不是这样。如果我们把95%的概率定义为成功，那么，这件20%成功概率的事，你需要重复做14次才能成功。换句话说，你只要把这件20%成功概率的事重复做14次，你就有95%的概率能做成。计算过程如下，对公式头疼的朋友可以直接略过。做1次失败的概率为:1-20%=80%=0.8重复做n次都失败的概率是:80%”=1-95%=5%=0.05(重复做n次至少有1次成功的概率是95%，就相当于重复做 n次、每一次都不成功的概率是5%)  n = log0.08^0.05≈13.42所以，重复做14次，你成功的概率能达到 95%。如果你要达到99%的成功概率，那么你需要重复做21次。虽然这个世界上没有100%的成功概率，但是只要重复做大概率成功的事情，你成功的概率就能够接近100%。这就是从不确定性中找到确定性，这是概率论交给我们最重要的思维2. 用动态的眼光看问题第二种数学思维源于微积分，叫做“用动态的眼光看问题”。宏观上，我们看到的是位移，但是从微观的角度来看，整个过程是从加速度开始的：加速度累积，变成速度；速度累积，变成位移。这就是积分。反过来说，物体之所以会有位移，是因为加速度经过了一段时间的累积。而物体之所以会有速度，是因为加速度经过了一段时间的累积。而物体之所以会有位移，是因为加速度经过一段时间的累积。位移相对于时间的一阶导数是速度，速度相对时间的一阶导数是位移，微观上其实是每一个瞬间速度的累积。而位移的倒数，就是从宏观回到微观，去观察它瞬间的速度。这就是微分。那么微积分对于我们日常生活到底有什么作用呢？理解微积分，你看问题的眼光就会从静态变为动态。加速度累积，变成速度；速度累积，变成位移，其实人也一样。你今天晚上努力学习了，但是一晚上的努力并不会直接变成你的能力。你的努力得积累一段时间，才会变成你的能力。而你有了能力，并不会马上作出成绩。你的能力得积累到一段时间，才会变成你的成绩。而你有了一次成绩，并不会马上得到领导的赏识。你的成绩也得积累一段时间，才会使你得到领导的赏识。从努力到能力、到成绩、到赏识，是有一个过程的，有一个积分的效应。努力的时候，希望瞬间得到大家的认可，但是出了问题后却不去想几个月前的懈怠。这是很多人容易走进的思维误区。从本质上讲，微积分的思维方式就是用动态的眼光看问题。一件事情的结果并不是瞬间产生的，而是长期以来的积累效应造成的。出了问题，不要只看当时那个瞬间，只有从宏观一直追述到微观，才能找到问题的根源。3. 公里体系第三种数学思维源于几何学，叫做公里体系。如果说公里体系是一个大树，那么，公里体系就是大树的树根。在几何学中，一旦制定了不同的公里，就会得到完全不同的知识体系。这就是公里体系的思维。这种思维在我们的生活中非常重要，比如，每家公司都有自己的愿景、使命、价值观，或者说公司基因、文化。因为愿景，使命，价值观不同，公司与公司之间的行为和决策差异就会很大。一家公司的愿景、使命、价值观，就相当于这家公司的公里。公里直接决定了这家公司的各种行为往那个方向发展。所有的规章制度，工作流程，决策行为，都是在愿景，使命，价值观这些公里上“生长”出来的定理，他们构成这家公司的公里体系。而这个体系一定是完全自洽的。不管公司以后如何发展，只要有公里存在，就会演绎一出一套能够解决问题的新法则（定理）。公理没有对错，不需要被证明，公理是一种选择，是一种共识，是一种基准原则。制定不同的公理，就会得到完全不同的公理体系，并因此得到完全不同的结果。4. 数字的方向性第四种数学思维源于代数，叫作“数字的方向性”。数这个东西，除了大小，还有一个非常重要的属性：方向。在数学上，我们把有方向的数字叫作向量。数其实是有方向的，在日常的工作和生活中可以得以体现。在公司做事情，两个人都是很有能力，合作的时候，如果他们的能力都往一个方向使，形成合力，这是最好的结果。但如果他们的能力不往一个方向使，反而相互牵制，那可能还不如把这件事情交给其中一个人来做。5. 全局最优和达成共赢第五种数学思维源于博弈论，叫作“全局最优和达成共赢”。我们每天大大小小的决策，每个决策的背后逻辑就是一场博弈。下围棋就是典型的博弈场景。没走一步棋，我的所得就是你的所失，我的所失就是你的所得。这是博弈论中典型的零和博弈。在零和博弈中，你一定要保持清醒：你要的是全局最优解，而不是局部的最优解。经营公司也一样，不要总是想着每件事情都必须一凡风顺，如果你想得到最好的结果，在一些关键步骤上就要做出妥协。除了零和博弈之外，还有一种是非零和博弈，它讲究共赢，共赢的前提是建立信任，但是建立信任特别不容易。孔子说“三十而立，四十而不惑，五十而知天命，六十而耳顺，七十而从心所欲不逾矩”。所谓“从心所欲不逾矩”，不是说你要通过约束自己来让自己做的事情不越出边界，而是当你拥有符合规律的思维方式时，你做的事情根本就不会越出边界。"
  },

  {
    "url": "/%E6%80%9D%E8%80%83/2024/08/11/%E5%91%A8%E6%9C%AB%E6%80%9D%E8%80%83%E8%AE%B0%E5%BD%95.html",
    "title": "周末思考记录20240811",
    "content": "周末思考记录202408111. 找到知识的盲点在小时候记得映像比较深刻的就是，就是在课堂上背诵九九乘法表，背不过放学后还不让回家（天快黑了，还是会放的）。包括现在一些简单的乘法算术在计算的时候也会采用乘法表进行，当时以为乘法只有一种计算方式，其实后来才了解到乘法在不同的国家则计算方式不一样，在俄罗斯采用的是“俄罗斯农夫乘法”，在古埃及通过垒石头的方式进行计算，叫做“古埃及乘法”，类似的还有“印度乘法”。同样的还有10进制、12进制、60进制、生肖等，这些是如何进行计数的，到目前知道的是，这些进制就跟人类的双手和脚趾有关，10个手指头，直接计数比较简单这就是10进制，12进制就是把一个人的的单手除大拇指之外的，其它每一根手指分为3节，所以一只手除开大拇指就是12节，类似的还有60进制，无非是用上双手等。其实想想这些定义和发明都是源于事物本身，如果当时学习的时候能知道这些，那么学习的时候是否兴趣会更大一些。2. 把手弄脏的理解回顾过往的工作经历中，在职场中有意或者无意的会去把一件事情整的明明白白、或者是对于业务来说那块是难点就会花时间去啃、在团队中会时不时出现救火场面。其实这些成长也罢、或者让自己的工作经历更加丰富，这无非是通过一种把手弄脏的途径（路径），到逼自己成长的一种方式。记得一次我回老家，去一家在县城从上学期间就在吃的蒸面店，据说蒸面老板在当地相当有钱（相对），那次去吃的时候，在蒸面端上桌子的时候，应该是鞋子比较滑的原因，有一半蒸面直接倒在的地上，老板下意识的去拿扫帚和纸巾把地上收拾干净，其实当时我看了店里还有其他服务员（当时并没有在做事情）。其实老板的行为是自主意识的，地上脏了就回去擦。现在想想，我们身处现实生活中，那个人的手是干净的呢？与其说把手弄脏，反倒是可以说何必在意是否会把手弄脏，在这个过程中重要的是如何面对或这面对这件事情的反应。3. 听到的不一定可靠这个事情也许在现实生活中，太司空见惯了。这里说一个不争的事实，尤其在近1-2年，大家都在讨论经济不好，大环境不好之类的话，或者是针对这些还做了一些讨论。有意思的是我看了一个数据（真正的大众群体：月薪3000~5000，分布在三四线城市，平均受教育年限10.9年左右（即中专到大专水平）。中国有护照的人不到1亿、没做过飞机的大概10亿、缴纳个人所得税大概几千万。1970年~1985年出生的人占总人口23%左右，占总消费量58%。90后、00后占比不足10%。）。不难看出，目前的这些声音很多是通过媒体平台或者是能在网上留下足迹之后被人看到进行传播的，那么还有很多人从不接触互联网，或者是在网络上的足迹相对比较少，那么这部分的声音是无法被外界知道的，。在当前的经济环境下，养老、医疗等服务性行业任然是很具前景的，大环境不好是事实，但是并不是所有的行业，只是我们常常只关注我们看到的罢了。4. 日常反思无论在生活上和工作上，都需要对自己当下的状态进行一些反思、总结。在工作中我会专门花时间回顾一周或一个月的工作，其实工作的过程和日常处理的事情并没有那么高大上，但是如果这些反思通过笔记记录下来，会很有意思，工作中的周报这些我同样会花时间思考记录，可能有人会问这有啥用？其实你想想，整个过程不就是一个成长的过程吗，这些记录下的思考和总结是不同阶段对新事物的反馈，或者是旧事物的思考，这也代表了当下最真实的自己，如果回过头再看这些，这就是一部成长记录，也许在未来的某个时间可以发挥巨大作用。也就像此时此刻，我在记录一些东西，记录一些的思考见闻。这些记录当然可以选择一个不易丢失的设备进行存储，这也是一路走过来我发现现在互联网上搜索到的东西没有以前多的原因。5. 家人陪伴在职业生涯中，家庭给予我的帮助挺大的，一些重大选择都选择基于支持，我非常欣慰能有这样的家庭。即使目前即使在工作中会疲惫不堪，但是回到家中看到家人和小孩之后，这些都消失了，感觉自己立刻切换了场景，这也许就是被治愈的一种方式。当我们放下键盘，关掉电源的这一刻，我们的生活才刚刚开始，抽出时间尽量陪伴家人，做一些高价值的陪伴。PS：最近身边的一些伙伴感冒发烧，咳嗽不断，去检测是新冠病毒，方便化大家备一些常用的药（对乙酰氨基酚片，可以备一点）"
  },

  {
    "url": "/%E6%88%90%E9%95%BF/2024/05/19/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%9A%84%E7%90%86%E8%A7%A3.html",
    "title": "最佳实践的理解",
    "content": "最佳实践的理解最近因为家里的事情，有一段时间没有更新了。刚在整理近期的工作和生活中的事情，想到一个词是“最佳实践“这个词。这个词也不陌生，经常在软件研发领域会说这个方案是最佳实践或者不是、在其他行业有时后会说应该这么做才是最好的、在生活中回顾做的一些决策和操作之后，在现在看来可能部分决策不是最佳实践。1. 概率在生活和工作中处处面临选择，每种选择其实可能都会伴随着不同的结果，其实这就产生了概率问题。只是现实社会中往往大家可能会总结经验，让好的结果尽可能发生，那么从概率的角度讲就是正向概率增大，那么这就是最佳实践的叠加效应。回想最早的机器学习(监督和无监督)、当前生成式AI(GAI)、金融行业的量化交易等，这些其实最终追求的就是概率问题，在量化交易行业中这个就是胜率问题。那么最佳实践本质上来说就是做选择，既然做选择就会存在概率问题，在实际生活中会发现最佳实践多了，那么就会形成叠加效应，胜率会增大，就会直接或间接带来一定的收益。2. 学习既然面临选择，那么当时不是盲目选择，这里也需要基于一定的事实客观规律，那就是学习。选择要建立在一定的理论基础和方法论，这里有很多关于这方面的文章。我想说的就是费曼的学习法，知识的积累是需要通过学习的方式。其实费曼的学习法是后人通过费曼的诸多文献总结出来的，学习法的精髓有2点：1. 把学到的知识内容用自己的理解进行输出、记录笔记，输出形式没有限制，重要的就是需要用自己理解的方式，这很重要2. 把通过获取知识理解后的内容作为输入给到自己，倒逼自己输出，其实这个环节就是说的实践把上述方法应用到实际的场景中，至少在做选择时会多一个参考，一定不要盲目选择，通过知识的积累，让自己有做更多选择的可能性，从而增加最佳实践的概率。3. 因小失大，得不偿失在重要的事情上多花心思，不是重要的事情上选择果断。可能很多人说什么事情时重要的事情？就是一件事情这么做都无畏那么就可以视为不重要，但凡还要经过大脑思考几回那说明存在一定的重要性。回想自己生活中就做过比较草率的决定，当时买房子的时候，没有话很多心思、没有参考过一些数据、甚至房子都没仔细看过就决定把房子买了，在当时想着自己能挣到钱无所谓。但是随着房价的下行，发现房子跌了不少，其实这个直接带来的就是经济上的损失，由于当初自己的没有经过认真思考导致的。反而有时间在tb和jd上买东西会纠结这个平台比那个平台便宜，因为这个会在上面停留过多的时间，这个就是不值当的。相比事情来说这就是典型的时捡了芝麻丢了西瓜，这就不是最佳实践。在工作中同样存在类似的问题，在做重大的技术方案时，虽然不要求面面具到，但是一定要抓住关键核心、识别出方案中的盲点、救命稻草、基础框架逻辑稳定自洽。这个就可以算在当时那一刻的最佳实践，最担心的就是考虑较少，一顿操作猛如虎，回头一地鸡毛。 在核心业务、核心领域上要多花心思，反倒是一些相对不是那么重要的业务功能迭代上方案上考虑够用就好，不要锦上添花。4. 主动与被动生活和工作中我们需要主动去面对和take一些事情。很多人认为这是心态问题，其实这是能力问题。主动与不主动，生命资源相差30倍。在工作中，主动思考和行动的能力尤其重要，主动承担能力和责任之外的事情，本身就是一个非常好的锻炼和成长机会，不要总担心自己的能力不够，害怕没把事情做好，其实不管你最终有没有把这件事情做成，但在做的过程中就是一次非常好的锻炼机会，用了公司的资源，成长了自己的能力，这是一个很划算的事情。 主动者每天都在日拱一卒，被动者每天都在左右徘徊。这个象限在现实情况下普遍存在，主动一些会让一些不可能成为可能，经历过这样几次之后，你可能在能力上会有很大的提升，在后面做决策和选择时，胜率就会加大，这也是最佳实践。5. 把手弄脏在目前阶段获取资讯或者知识的方式很多，知识在传递的过程中也会发生一些变化(理解偏差)，加上知识的输出者也不不可能把所有细节和方法论都讲出来，这也不太现实。我们在理解这些知识后切记隔岸观火，把这些知识和输出直接用在实际的场景中。我们一定要结合实际情况，深入理解事情的逻辑和本质，适当的结合和改造、优化，切记空有一套方法论。在软件研发领域，可能你已经是研发小组长、研发Leader，但是对于一线的一些问题必须去了解，知根知底。一定要 do something ，而不是 own stomething。"
  },

  {
    "url": "/web3/2024/04/16/Web3-%E6%B8%B8%E6%88%8F-%E9%93%BE%E4%B8%8A%E8%B5%84%E4%BA%A7%E4%B8%8E%E7%BB%8F%E6%B5%8E%E5%B9%B3%E8%A1%A1.html",
    "title": "Web3 游戏：链上资产、可组合性与经济平衡",
    "content": "Web3 游戏并非“把游戏搬上链”，而是利用“链上可验证资产 + 可组合协议 + 开放市场”构建新型经济系统：资产可流通、玩法可叠加、内容可共建。工程落地的关键是资产与经济的严谨设计、反作弊与反女巫、链上/链下分工与可观测体系。本文给出一套可直接实操的参考方案。1. 资产设计：ERC-721/1155 与可组合  角色/装备：稀有度、属性、成长路径；  可组合：装备作为组件装配到角色（EIP-998/可组合规范），或在外部合约读取“装备映射”；  动态属性：升级/附魔/修复，链上存储核心属性，链下计算细节；  元数据：图素与动画通过 IPFS/Arweave 存储，链上记录 CID。2. 经济平衡（产出/消耗闭环）  产出：打怪/任务/挖矿 掉落；  消耗：修理/强化/合成/门票；  通胀控制：掉率衰减、合成概率、消耗品设计；  市场：玩家间自由交易（AMM/订单簿），平台抽取少量手续费回流金库；  预言机：如涉及法币锚定，采用时间加权价格，规避闪崩影响。3. 反脚本与反女巫  行为指纹：节奏/移动/时序统计识别自动化；  风控阈值：异常收益、频繁交易、深夜高频；  DID/VC：绑定可验证凭证降低批量女巫；  处罚与申诉：温和限流、冻结审核、黑白名单。4. 链上/链下分层  链下高频：战斗匹配、物理/数值计算；  链上结算：资产增减、关键事件（铸造/销毁/合成）；  事件设计：每个关键变化 emit 事件以供索引器重放；  可验证随机数：Chainlink VRF 或 commit-reveal。5. 市场与交易  订单：固定价/拍卖/荷兰拍；  税费：平台费、创作者分成、回购与销毁；  防洗钱与反作弊：同地址/相关地址频繁交易告警；  订单撮合：链上撮合（昂贵）或链下签名订单 + 链上结算（高效）。6. 跨链与 L2  L2 部署：降低 Gas，提升交互体验；  跨链：资产映射/桥接，小游戏分链分服；  同步：统一身份（DID）与跨链资产视图（索引层聚合）。7. 反作弊与可观测  监控：日活/留存、经济指标（通胀率/回收率/交易额）、机器人占比；  日志：关键交互埋点与链上事件对账；  告警：异常产出/价格操纵/批量转移；  A/B：经济参数灰度试验，避免一次性调整导致崩盘。8. 上线与运营 SOP  技术：Testnet 压测 → L2 主网灰度；  市场：创作者合作、空投/白名单；  安全：审计/赏金计划、Key 管理、多签金库；  版本：前端 CDN 可回滚、合约保留暂停开关；  演练：回滚/风控封禁/桥接中断的应急预案。9. 示例：装备合成合约（简）function combine(uint256 a, uint256 b) external payable {  // 检查持有、扣除消耗、概率判定、生成新装备token  emit Combined(msg.sender, a, b, newId, success);}10. 小结Web3 游戏成功的关键不在“链”。它需要与玩法、经济、反作弊、内容生态共同作用。以“链上凭证 + 可组合资产 + 开放市场”打造可持续的经济系统，再用工程化手段（索引、风控、看板、演练）保证长期稳定，才是可走通的路线。"
  },

  {
    "url": "/%E6%80%9D%E8%80%83/2024/03/25/%E4%BA%8C%E5%85%AB%E6%B3%95%E5%88%99%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83.html",
    "title": "二八法则的一些思考",
    "content": "关于二八法则的另外一种叫法是80/20法则，或者叫关键少数法则。在生活工作方各方面都有体现：在经济学领域，全球最富有的20%的人口，控制着世界收入的82.7%。在软件领域，可以应用于优化软件工作，通过修复报告最多的错误的前20%，给定系统中80%的相关错误将被消除。在运动锻炼上，20%的练习和习惯影响着80%的结果，受训者不应该专注于多种训练。将二八法则落实到行动上，简单整理了如下方法做有复利积累的事情复利特别在经济学领域比较常用，例如做量化一般也会评估复利的长期收益(常说的利滚利)。最常见的复利即资产，即可以自行为持有人带来收益的东西，资产本身是固化的劳动，而靠其赚到的钱又可以固化为资产，从而以指数增长的方式增殖。当然，任何可以积累的东西都是具有复利效应：知识是可以积累下来的，积累的知识帮助做出更高概率正确的决策，带来更大的视野，从而有需求及动力学习更多知识；个人IP影响力是可以积累的，更高的影响力带来更大的曝光，接触更多优秀的人，有更多合作机会，反过来又增强个人的影响力。极致聚焦，做减法现实中每个人的精力有限，不太可能可以做所有的事情，要通过分析和评估来确定哪些是产生最大价值的关键因素。旦识别出关键因素，就需要对它们进行优先排序。这意味着要将资源和精力集中在那些最能产生效益的领域。识别并剔除那些消耗时间、金钱和资源但收益甚微的活动。在决策过程中，尽量减少不必要的选项和复杂性。通过简化流程，可以提高效率并减少错误。有效地利用资源，提高效率和产出。战略优于战术程序员应该都有感受，写代码最重要的是前面的思考的环节，写只占据很少时间，若思考不清晰，后续会有无尽的debug负担；做产品也一样，我个人看来，商业模式&gt;流量策略&gt;具体开发，商业模式定义了是否解决的是痛点问题，该问题是否给用户带来价值从而用户有付费意愿，该问题定义清楚后，流量策略和具体开发则是水到渠成的事情，而渠道的重要性往往要高于具体开发。发挥自己的比较优势社会分工之所以存在，是因为每个人有其比较优势，各自做擅长的事情并合作，会提升整体效率。对个人来说，发挥自己的比较优势，只做那 20% 自己擅长的或有热情的事情（热情本身也会变为擅长），其他事情则是最大程度自动化或者外包出去。当前AI能力如此强大，各细分领域服务极度充沛，特定问题付费解决可节省大量人力，成本远低于自己浪费时间。"
  },

  {
    "url": "/%E5%B7%A5%E5%85%B7/2023/12/19/%E5%AE%9E%E7%94%A8Mac%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E5%88%97%E8%A1%A8.html",
    "title": "实用Mac软件推荐列表",
    "content": "Apps日常使用ClashX Pro：科学上网只有先科学上网，才能装后面的Notion：笔记输入 + 博客输出的工具Chrome：浏览器Xnip：截图工具1password 7：密码管理工具其它的也用过，还是这个原生 App 比较流畅CleanMyMac X：Mac优化清理工具Warp WindTerm iTerm2：终端Alfred：本地搜索、应用启动、剪贴板 📋MarkEdit: Mac上开源markdown编辑器效率神器Karabiner-Elements：键盘键位修改神器一些配置 karabiner.json ，主要是改 HHKB 和 Apple Keyboard滴答清单 ：任务和规划时间（GTD）的应用flomo ：快速记录一些想法Bob 社区版 ：划词翻译和截图翻译工具支持多个翻译聚合还挺方便的Input Source Pro ：不同应用、不同网站自动切换输入法QQ Music ：网络音乐服务产品百度五笔输入法试过 Mac 上各类的五笔输入，还是这个好用NetNewsWire ：开源、免费、全平台的 RSS 订阅、阅读订阅 index.opmlBartender 4 ：菜单栏应用图标管理工具管理挺方便，就是 Mac 屏中间刘海那块没适配好OpenInTerminal：从 Finder 一键打开 Terminal之前的 Go2Shell 似乎不维护了，就用了这个IINA ：媒体播放器Kap ：开源录屏工具可转成 gif、mp4，支持插件新 Mac 生成 gif 基本是秒级导出TaskPaper ：文本编辑器模式的任务管理工具（GTD）经常用来管理工作上需要长期跟进的事，和滴答清单结合使用MindnodeTelegram ：相对匿名安全的聊天软件Cubox ：一站式信息收集、阅读、管理和回顾碎片化阅读时代的文章、视频收集器RunCat ：在任务栏奔跑的猫猫奔跑的速度会随着CPU使用率提升而越来越快（新 Mac 怎么开发都没看猫奔跑过）Magnet ：窗口管理MonitorControl ：显示器亮度调节StandUp ：提醒站立WiFriedX ：关闭 AWDL/AirDrop，优化 M1 系列 Mac 的 Wifi 连接 开发使用VSCode ：代码编辑器通过自带的 Settings Sync 功能一键同步GitUp ：Git GUI 软件比 SourceTree 等软件要简洁，日常开发中基本没有做不了 GUI 操作Sublime Text ：文本编辑器准确来讲，经常用这个编辑器快速做一些纪要DataGrip：数据库开发工具Goland：Gopher 开发工具Dash：API 文档和代码片段管理一直在用，找 API 文档和用法太方便了Postman ：API 调试神器SwitchHosts ：管理、切换多个hosts 方案的工具QuickLook 预览插件quicklook-jsonqlmarkdownQLVideo System Configuration触摸板三指拖拽系统设置 → 辅助功能 → 指针控制 → 触控板选项 → 启用拖移（三指拖移）退格键响应速度系统设置 → 键盘，按键重复 调到最快、重复前延迟调最短Github clone 加速屏保 Aerial Devbrewon-my-zshfzfautojumplazygit ：命令行版 Git GUIripgrep ：快速搜索文件/目录中包含的字符串batghglabgit-switchergraphvizNode.js 相关fnmnode 16 似乎用不了 node-gyp-buildPython 相关pyenvJava 相关jenvGomoddtree字体安装brew install –cask font-fira-code font-jetbrains-mono PluginsAlfred workflowsalfred-chromium-workflow ：浏览器历史记录搜索找一些页面很方便YoudaoTranslator ：有道搜索平时直接 yd 中英文单词/句子 很方便NpmSearch ：npm 包搜索npm 包名 搜索一些包版本，同时支持任意 registry 源"
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/nginx/2023/12/05/Nginx-Ingress-%E5%9C%A8Kubernetes%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E9%85%8D%E7%BD%AE.html",
    "title": "Nginx Ingress 在 Kubernetes 的高可用配置",
    "content": "在 K8s 中落地 Ingress-Nginx 时，如何配置高可用、弹性与灰度？本文给出实操 YAML、金丝雀流量与压测/演练手册。1. 基础部署（示例）apiVersion: networking.k8s.io/v1kind: Ingressmetadata:  name: web  annotations:    kubernetes.io/ingress.class: nginxspec:  rules:  - host: demo.example.com    http:      paths:      - path: /        pathType: Prefix        backend:          service:            name: web-svc            port:              number: 802. 金丝雀灰度metadata:  annotations:    nginx.ingress.kubernetes.io/canary: \"true\"    nginx.ingress.kubernetes.io/canary-weight: \"20\" # 20%3. HA 形态  DaemonSet + hostNetwork + externalTrafficPolicy=Local，保持源地址；  或 Service L4 LB + 多副本 Ingress Controller。4. 压测与演练  fortio/vegeta 压测 10-30 分钟，观察 2xx/4xx/5xx 与 P95；  演练：杀死节点/Pod、模拟 LB 抖动，验证会话粘性与重试策略。5. 拓扑与调度（反亲和/跨区扩散/PDB/容忍）controller:  replicaCount: 3  affinity:    podAntiAffinity:      requiredDuringSchedulingIgnoredDuringExecution:        - labelSelector:            matchLabels:              app.kubernetes.io/name: ingress-nginx              app.kubernetes.io/component: controller          topologyKey: kubernetes.io/hostname  topologySpreadConstraints:    - maxSkew: 1      topologyKey: topology.kubernetes.io/zone      whenUnsatisfiable: ScheduleAnyway      labelSelector:        matchLabels:          app.kubernetes.io/name: ingress-nginx          app.kubernetes.io/component: controller  tolerations:    - key: \"node-role.kubernetes.io/ingress\"      operator: \"Exists\"      effect: \"NoSchedule\"PodDisruptionBudget（避免滚动/维护时一次性驱逐）：apiVersion: policy/v1kind: PodDisruptionBudgetmetadata: { name: ingress-nginx-pdb, namespace: ingress-nginx }spec:  minAvailable: 1  selector:    matchLabels:      app.kubernetes.io/name: ingress-nginx      app.kubernetes.io/component: controller6. 升级与优雅收敛controller:  updateStrategy: { type: RollingUpdate }  minReadySeconds: 10  terminationGracePeriodSeconds: 60  config:    worker-shutdown-timeout: \"30s\"    proxy-next-upstream: \"error timeout http_502 http_503 http_504\"    proxy-next-upstream-tries: \"2\"    proxy-read-timeout: \"30s\"    proxy-send-timeout: \"30s\"要点：  minReadySeconds 确保就绪后才接流量；worker-shutdown-timeout 提供连接迁移时间。  与上游的重试与超时上限要保守，防止风暴。7. 容量与弹性（HPA）controller:  metrics:    enabled: true    serviceMonitor:      enabled: true  autoscaling:    enabled: true    minReplicas: 3    maxReplicas: 20    targetCPUUtilizationPercentage: 60    targetMemoryUtilizationPercentage: 70建议：基于 CPU/内存或自定义 QPS/连接数指标（需自定义 Metrics Adapter）弹性扩缩容。8. 上游容错与连接复用controller:  config:    keep-alive-requests: \"1000\"                # client &lt;-&gt; ingress 长连接复用上限    upstream-keepalive-connections: \"512\"      # ingress &lt;-&gt; upstream 空闲长连接上限    max-worker-connections: \"65536\"    retries: \"1\"    retry-non-idempotent: \"false\"注意：若上游有会话亲和（如登录态），需与 session-cookie/一致性哈希配合，避免跨请求状态混淆。9. 可观测与演练清单（扩展）  指标：活动连接、$upstream_response_time 分位数、5xx 率、队列与 fd 用量。  日志：统一 JSON 格式，保留版本/路由/上游信息，便于问题回溯。  演练：          杀 Pod/节点；      人为提升上游错误，验证 proxy-next-upstream；      LB 抖动/跨区故障；      扩缩容/滚动升级下的会话粘性与连接复用表现。      "
  },

  {
    "url": "/web3/2023/08/09/Web3-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E9%92%B1%E5%8C%85%E6%B3%A8%E5%85%A5%E6%A0%87%E5%87%86.html",
    "title": "Web3 浏览器与钱包注入：EIP-1193/6963 与隐私实践",
    "content": "Web3 浏览器的要义是“让网页安全地调用用户的加密身份与链上资源”。核心落在 Provider 标准（EIP-1193）、多钱包发现（EIP-6963）与网络切换（EIP-3085/3326），同时还要面对隐私合规、反钓鱼、兼容性与多链适配等现实问题。本文从标准到工程实践，系统讲解如何构建“安全、可靠、好用”的 Web3 浏览器/前端。1. EIP 标准速查  EIP-1193：Provider 请求/事件接口；  EIP-6963：多钱包发现与选择；  EIP-3085：向钱包添加链配置；  EIP-3326：请求钱包切换链；  EIP-155（签名交易链ID）、EIP-712（结构化签名）。常用调用：await provider.request({ method: 'eth_requestAccounts' })await provider.request({ method: 'wallet_addEthereumChain', params: [{ chainId:'0x1', rpcUrls:['...'], chainName:'Ethereum', nativeCurrency:{name:'ETH',symbol:'ETH',decimals:18} }] })await provider.request({ method: 'wallet_switchEthereumChain', params: [{ chainId:'0x1' }] })2. 多钱包与注入（EIP-6963）  发现：页面监听 eip6963:announceProvider 事件，聚合候选；  选择：弹出钱包列表，用户选择后注入该 Provider；  兼容：Fallback 到 window.ethereum。document.addEventListener('eip6963:announceProvider', (event) =&gt; {  const detail = event.detail; // { info, provider }  wallets.push(detail)})3. 权限与安全  权限最小化：仅在需要时请求账户与签名；  白名单域名与签名域隔离（SIWE domain binding）；  反钓鱼：明确签名提示含意，拦截 setApprovalForAll 弹窗的风险提示；  Sandboxing：对第三方脚本注入做 CSP 限制；  兼容 DNT/隐私：不上传可识别信息，客户端缓存敏感数据。4. 签名与交易  登录：SIWE（EIP-4361）签名会话；  交易：预估 Gas，失败提示与替代交易；  批量与 AA：账户抽象（EIP-4337），用 UserOp 合并多个动作；  非 EVM：签名格式差异（Solana/Polkadot），抽象 Provider 层。5. 多链与兼容性矩阵  EVM 兼容链：主网/L2（Arbitrum/Optimism/zkSync/Linea/Base/…）；  非 EVM：通过特定 SDK/适配器；  检查清单：链ID、单位、RPC 限流、交易池差异、确认规则；  错误处理：网络切换失败/链不支持 → 降级只读。6. 调试与监控  调试：启用 eth_call 与 debug_traceTransaction（权限谨慎）；  监控：钱包连接率、签名拒绝率、交易失败率、平均确认时间、非预期链切换次数；  前端埋点：区分 Provider 版本、钱包类型（扩展/移动/内嵌）。7. 用户体验优化  首屏无需连接钱包（只读模式），用户操作再请求授权；  断线重连与会话恢复（SIWE + 短期 token）；  错误文案本地化与“下一步指引”；  一键复制错误详情到工单；  预加载常用合约 ABI 与代币列表；  慢链/高拥塞时的友好提示与替代方案（切 L2）。8. 反钓鱼与合规  域名与合约白名单：显示“已验证合约/域名”；  显示授权范围：spender/tokenId/amount；  风险评分：黑名单/社交举报/交易图谱；  法务：隐私政策、KYC/AML 适配（若涉及法币出入金）。9. 示例：最小可用多钱包接入import { createConfig, http, createStorage } from 'wagmi'import { injected, walletConnect, coinbaseWallet } from 'wagmi/connectors'export const config = createConfig({  chains: [mainnet, arbitrum, optimism],  transports: {    [mainnet.id]: http('https://...'),    [arbitrum.id]: http('https://...')  },  connectors: [injected(), walletConnect({ projectId:'...' }), coinbaseWallet({ appName: 'app' })],  storage: createStorage({ storage: window.localStorage })})10. 小结一个好的 Web3 浏览器前端，既要“懂标准”也要“懂用户与风控”。以 EIP-1193/6963 为锚点构建 Provider 层，围绕权限/隐私/多链/监控/反钓鱼持续打磨，才能在复杂生态中提供长期可靠的体验。"
  },

  {
    "url": "/web3/2023/03/22/Web3-DAO-%E6%B2%BB%E7%90%86%E4%B8%8E%E5%8D%8F%E5%90%8C%E5%AE%9E%E8%B7%B5.html",
    "title": "DAO：治理、金库与协同实践",
    "content": "DAO（Decentralized Autonomous Organization）强调“公开规则 + 透明资产 + 社区协作”。要把 DAO 从“概念”落地为可持续运作的“组织”，需要同时构建规则（合约/章程）、流程（提案/投票/执行）、工具（多签/投票/论坛/工单）与度量（金库/参与度/交付）。本文从治理模型到金库运营、从合约到日常协同，给出可直接落地的实践手册与脚本示例。1. 治理模型概览  Token-based：一币一票，参与门槛低但易受“鲸鱼”影响；  Delegated（委托制）：将投票权委托给代表，兼顾广泛参与与专业决策；  二次方投票（Quadratic）：缓解大户垄断影响，但需反女巫措施；  基于声誉/贡献积分：非金融化权重，强调长期贡献；  混合模型：不同领域/金额使用不同门槛与投票机制（如技术提案 vs. 市场预算）。2. 提案生命周期（从草案到执行）1) 草案（RFC）：论坛/Discord 讨论，明确动机、方案、预算、风险；2) 影子投票/温度测试（Snapshot 温度计）：收集倾向；3) 正式提案（SIP/DAOIP 等）：链上/链下同步发布；4) 投票：Snapshot（off-chain）或 Governor（on-chain）；5) 执行：多签 Safe 模块/Timelock 合约触发链上动作；6) 复盘：记录影响、里程碑达成情况、后续跟踪 KPI。2.1 模板（提案正文）  摘要：一句话说明；  动机与目标：解决什么问题；  方案与里程碑：阶段、交付物、完成标准；  预算：金额、释放节奏、验收条件；  风险与替代方案：关键假设与兜底；  法务与合规：需要注意的限制；  执行方式：多签/合约接口/可验证凭证；  监控指标：成功/失败的量化定义。3. 投票与执行：Snapshot + Safe  Snapshot（off-chain）：使用签名（EIP-712）完成不可抵赖投票，低成本；  Safe 多签（Gnosis）：金库与执行器，支持模块化扩展；  自动执行：Snapshot 的 SafeSnap 模块可将投票结果自动化为多签交易批次；  门槛设置：法定人数（quorum）、通过阈值、投票时长；  防作弊：反女巫、投票权截快照、委托机制。配置片段（Snapshot space）：{  \"name\": \"Example DAO\",  \"strategies\": [{\"name\":\"erc20-balance-of\",\"params\":{\"address\":\"0xToken\",\"symbol\":\"TKN\",\"decimals\":18}}],  \"quorum\": 0.1, \"voteDuration\": 5}4. 链上治理：OpenZeppelin Governor/Timelock  Governor Bravo / OZ Governor：支持法定人数、投票/延时/执行窗口；  Timelock：为关键变更设置最短延时（如 24~72 小时），保证公众可审阅；  模块化：可组合多策略读权重（ERC20、NFT、声誉积分）。部署要点（Foundry 伪代码）：Governor g = new Governor(\"DAO\", token, quorum, votingDelay, votingPeriod);Timelock t = new Timelock(minDelay, proposers, executors);g.setTimelock(address(t));5. 金库与预算管理  收入：协议费/捐赠/资助；  支出：运营/研发/社区激励/生态合作；  预算流程：提案 → 执行里程碑释放 → 结项复盘；  资产配置：稳定币 vs 原生代币，风险敞口与对冲；  支付工具：多签批量支付、流式支付（Sablier/Stream），可回收未完成预算。多签批量交易（Safe API/脚本）：// 组装批量转账与合约调用，提交到 Safe 服务，收集签名后上链执行6. 角色、工组与激励  角色：理事会（多签签署人）、运营（主持流程）、审计（风险/合规）、贡献者；  工组（Working Group）：按照领域划分（协议、市场、内容、数据）；  激励：按里程碑支付 + 绩效加权；  声誉系统：非金融化的贡献度积分，与资金激励分离；  透明度：公开任务看板/排期/预算消耗。7. 法务与风险  法人格：基金会/非营利组织/公司壳；  合规：税务、KYC/AML、地区限制；  知识产权：内容与品牌使用授权；  保险/代偿：关键风险（跨链桥、金库）购买保险或建立风险准备金；  紧急权限：仅限暂停关键合约/支出，必须有时效与审计日志。8. 运营度量与工具栈  指标：提案数、参与率、委托覆盖率、预算执行率、交付完成率；  金库仪表：资产构成、资金流出入、 runway；  安全告警：异常转账、权限变更、合约事件；  工具：          协同：Discourse/Notion/GitHub Projects/Discord；      治理：Snapshot、Tally、Boardroom、Charmverse；      金库：Safe、Llama、Sablier；      数据：Dune、Flipside、自建 ETL。      9. 应急与回滚演练  触发条件：关键 KPI 恶化（参与率骤降/预算滥用/安全事件）；  行动：临时冻结非关键支出 → 召开紧急会议 → 提案通过后执行回滚或更换模块；  演练：季度进行“带压回滚/金库紧急冻结/密钥更换”演练；  日志：所有应急动作记录在案（链上事件 + 协作平台日志）。10. 案例（示意）  目标：为协议升级与市场推广申请 50 万 USDC；  流程：1) RFC 收集需求与 KPI；2) Snapshot 温度计投票，&gt;60% 支持进入正式投票；3) 正式投票通过 → Safe 批量交易分期付款；4) 里程碑验收：GitHub Release / 合约已上线 / 监控指标达到阈值；5) 复盘发布与预算结项，未用资金退回金库。11. 小结DAO 的难点不是“投票按钮”，而在于“透明、可持续的组织工程”：规则清晰、角色分明、流程可审计、资金可追踪、风险可控。以 Snapshot + Safe + Governor 为核心治理栈，配合度量与演练，DAO 才能在开放环境中长期稳定运转。"
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/mysql/2023/02/27/MySQL-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E4%BB%8E-explain-%E5%88%B0%E7%81%AB%E7%84%B0%E5%9B%BE.html",
    "title": "MySQL-慢查询优化-从-explain-到火焰图",
    "content": "在大多数互联网业务中，性能问题往往集中在查询侧（读多写少、读写比常见为 10:1），而慢查询占据了主要矛盾的“C 位”。要系统性地把慢查询优化好，必须同时理解数据库的底层原理（磁盘 IO、B+ 树、优化器）、索引设计的工程原则、可落地的重写与调参手法，以及边界条件——哪些场景即便你用尽 SQL 和索引也很难救。本文在高技术细节的基础上，结合一线经验进行结构化扩展与工程化整理，以期给出一份可直接借鉴的优化指南。一、底层原理速览：为什么索引有效、为什么会慢  磁盘 vs 内存的数量级鸿沟          随机磁盘 IO 的代价远高于内存访问。一次随机 IO 需要经历寻道、旋转延迟、传输时间，数量级毫秒；CPU 指令数量级纳秒。我们优化的核心目标，是让“每次查询落盘的随机 IO”尽量变少甚至可控。        InnoDB 与 B+ 树          InnoDB 二级索引和聚簇索引（主键索引）均是 B+ 树。B+ 树扇出高、树高低（常见 2～4 层），单次定位数据通常 2～3 次 IO 即可。二级索引叶子节点只存被索引列和主键值，真实行数据在聚簇索引上，因此“二级索引命中但需要回表”会产生额外 IO。        页与顺序读取          InnoDB 页默认 16KB，局部性/预读使得顺序 IO 的吞吐远优于大量随机 IO。覆盖索引、索引下推、减少回表，本质都是在“让更多命中停留在更少的页里”。      这组常识决定了：合理的索引与查询改写，能把“全表扫描 + 大量随机 IO”变成“极小范围树检索 + 少量随机/顺序 IO”。二、方法论：从观测、定位到验证  观测          开启并分析慢查询日志（slow_query_log、long_query_time、log_queries_not_using_indexes）      使用 pt-query-digest 聚合热点 SQL；借助 performance_schema/sys schema 获取 Wait、IO、Lock 等维度        定位          EXPLAIN 与 EXPLAIN ANALYZE（8.0.18+）评估真实执行路径与耗时分布      关注 type、key、rows、filtered、Extra（Using index、Using where、Using temporary、Using filesort、Using index condition）        验证          基线采样（QPS、P95/P99 延迟、Rows examined/Rows sent、临时表与回表次数）      审慎灰度：MySQL 8.0 可用 Invisible Index 验证索引有效性；在线 DDL 降低变更风险        回归          用真实业务参数覆盖极端分支；关注“看似更快但在特定参数下灾难性退化”的情况（本文后面会给典型案例）      三、索引优化的核心原则（工程可落地）  核心一：围绕“查询模式”而不是“字段”建索引          只为 WHERE、JOIN、ORDER BY、GROUP BY 等过滤/排序参与列建立索引      高基数（高选择性）列优先（如 user_id &gt; status）；极低选择性列（如性别）单独加索引意义不大        核心二：联合索引的列序必须与谓词和排序兼容          “等值列在前，范围列靠后”，让尽量多的谓词参与到索引扫描而非回表过滤      同时需要权衡“列选择性”和“使用频率”，一般建议：等值频繁且选择性高的列靠前；用于排序/分组的列一并纳入并统一升降序      兼顾 ORDER BY/ GROUP BY 的“索引有序性”，避免 Using filesort/Using temporary        核心三：覆盖索引优先          SELECT 的列尽量被索引覆盖，Extra 出现 Using index 表示“无需回表”。这对热点 TopN 查询、Feed/列表页尤其致命有效        核心四：让条件可 SARGable（可由索引评估）          避免对列做函数或表达式：如 UPPER(col) = ‘X’、DATE(create_time) = ‘2025-08-01’      解决手法：函数生成列 + 函数索引（MySQL 8.0 支持 Functional Index）；或用范围改写（create_time &gt;= ‘2025-08-01’ AND create_time &lt; ‘2025-08-02’）        核心五：LIKE 前缀命中与全文检索          LIKE ‘abc%’ 可用 btree 前缀走索引；LIKE ‘%abc%’ 需全文索引（FULLTEXT/倒排/NGRAM）或改造数据结构（反向存储 + 前缀匹配 + 函数索引）        核心六：ORDER BY/分页优化          避免“大偏移”分页（LIMIT 100000, 20）；推荐“基于游标”的 Seek 方法（WHERE (k, id) &gt; (?, ?) LIMIT N）      如必须排序分页，尽量使用能满足排序的联合索引（与 WHERE 子句兼容）        核心七：主键与二级索引协同          InnoDB 主键即数据物理顺序。主键应短、递增（雪花 ID/自增/UUIDv7），避免随机 UUIDv4 导致频繁页分裂      二级索引叶子存主键，回表代价与主键长度、行大小、局部性直接相关        核心八：统计信息与优化器          定期 ANALYZE TABLE，开启持久统计（innodb_stats_persistent）；必要时使用直方图（MySQL 8.0 histogram）提升基数估计      在小概率误判时使用优化器 Hint（STRAIGHT_JOIN、USE INDEX、INDEX_MERGE、BKA/BKA ON/OFF 等）        核心九：分区不是索引的替代          分区降低“被扫描的数据量”，但分区内仍需索引；分区键必须参与查询谓词才能有效裁剪分区        核心十：变更安全          使用 Invisible Index 验证效果；在线 DDL 降低锁表风险；灰度发布与回滚预案必备        四、实际慢查询案例与可落地重写            案例 1：多条件计数 + 时间范围业务 SQL（简化自业界常见模式）：SELECT COUNT(*)FROM taskWHERE status = 2  AND operator_id = 20839  AND operate_time &gt; 1371169729  AND operate_time &lt; 1371174603  AND type = 2;常见问题  单列索引分散在各列，导致优化器选一个索引，再对其它条件做回表过滤，Rows examined 仍然很大。  时间范围是“范围谓词”，放在联合索引中靠后更合理。建议索引  建立联合索引：(status, operator_id, type, operate_time)。等值列在前，范围列 operate_time 放最后。  若查询还常常 ORDER BY operate_time，可考虑 (status, operator_id, type, operate_time) 同时覆盖排序。验证要点  EXPLAIN 观察 type: range/ref、key: idx_s_o_t_ot、rows 明显下降；Extra 无 Using filesort/Using temporary。  COUNT(*) 可结合覆盖索引实现“无回表计数”。案例 2：排序 + LIMIT 的 TopN 与 Join 的悖论目标 SQL（取最新创建的 10 条）：SELECT c.id, c.name, c.created_timeFROM contact cJOIN ... -- 复杂多表过滤WHERE ...ORDER BY c.created_time DESCLIMIT 10;两种思路  先全量 Join 后排序再 LIMIT：如果 Join 过滤后仍有海量行，再排序与分页，代价巨大。  优化策略：基于 c.created_time 可排序的联合索引（如 (created_time, id) 或与 WHERE 兼容的更长索引），先从 c 上用索引顺序取 TopN，再做 Join 过滤，不够再取下一批（Loop 取 TopN+Join 过滤）。巨幅加速 vs 灾难性退化  在“Join 过滤率较高但非极端”的情况下，这种“先取 TopN 再 Join”的策略往往带来数量级的速度提升（实践中可从秒级降到毫秒级）。  但当 Join 过滤极端严格，TopN 的候选一再被过滤掉，则会出现“反复取 10 条、反复 Join、始终不够”的灾难性退化，整体甚至比原始写法更慢。由于 MySQL 的 Nested Loop 特性，这类退化在优化器层面很难被完全消弭。工程建议  预先把 Join 侧过滤做“强裁剪”（如用子查询或派生表先把候选主键集缩小到 O(1e3) 级别，再回表取 TopN）  若业务允许，把排序字段与过滤字段合并为能被同一联合索引同时支持的模式  极端场景交由应用逻辑优化，例如缓存预计算 TopN 候选集、分层存储、异步刷新等案例 3：EXISTS + 多表 Join 的过滤上移原始 SQL（示意）：SELECT c.id, c.name, c.created_timeFROM contact cWHERE EXISTS (  SELECT 1  FROM contact_branch cb  JOIN branch_user bu ON cb.branch_id = bu.branch_id AND bu.status IN (1,2)  JOIN org_emp_info oei ON oei.data_id = bu.user_id                        AND oei.node_left &gt;= 2875                        AND oei.node_right &lt;= 10802                        AND oei.org_category = -1  WHERE c.id = cb.contact_id)ORDER BY c.created_time DESCLIMIT 10;优化思路  为 Join 键与过滤列建立必要索引：cb(branch_id, contact_id)、bu(branch_id, status)、oei(org_category, node_left, node_right, data_id) 等  半连接（Semi-join）重写：在 MySQL 8.0 上，优化器对 EXISTS/IN 有半连接转换，可显著减少回表  将“组织区间过滤”下推产生“候选 user_id 集合”，再回表关联 contact，避免大范围 Join 后再过滤  使用 STRAIGHT_JOIN 在个别误判时固定 Join 顺序案例 4：模糊匹配与全文搜索原始 SQL：SELECT id FROM article WHERE title LIKE '%分布式事务%';结论  %xxx% 前导通配符使得无法按 btree 自左向右利用索引，只能全表扫描  备选路径：全文索引（FULLTEXT/倒排/NGRAM）、ES/搜索服务；或改造为“前后缀可命中”的查询模式；或建立“反向字符串 + 函数索引”的特定业务替代方案（有代价）案例 5：函数过滤与 SARGable 改写问题 SQL：SELECT * FROM ordersWHERE DATE(create_time) = '2025-08-09';改写SELECT * FROM ordersWHERE create_time &gt;= '2025-08-09 00:00:00'  AND create_time &lt;  '2025-08-10 00:00:00';  或在 MySQL 8.0 上使用函数索引/生成列：          生成列 create_date = DATE(create_time)，并对其建索引，查询改为 WHERE create_date = '2025-08-09'      五、那些“很难优化或不该在数据库层面优化”的场景  先排序再 Join + LIMIT 的极端退化          如前述案例 2，当 Join 过滤极端严格且结果集稀疏，MySQL 将反复取 TopN 候选再 Join，导致“指数级”重试。优化器很难自动摆脱这种结构性退化，通常需要业务/架构层面改造（缓存/预计算/拆查询）。        低选择性列的大范围过滤          如 status IN (1,2,3)、gender in (0,1)，索引帮助不大。通常是全表扫描更快。需通过复合谓词联合高选择性列，或改业务模型/分区/冷热分表        全字段模糊匹配          LIKE ‘%keyword%’、跨多列 OR 混合匹配，本质是搜索问题。应引入搜索引擎或全文索引。强行在 MySQL 用索引 merge 往往治标不治本        返回超大行/大字段          查询即便命中索引，但需要回表读取大量列（BLOB/TEXT、大 JSON），IO 成本依旧高。考虑列裁剪、行列分离（大字段外置）        复杂 UDF、存储过程型逻辑          复杂运算难以下推，无法被优化器重写与索引利用。需要在应用层/ETL 预处理，或改写为可下推的谓词        数据太小/Buffer 命中率极高          小表全表扫描更快，建索引可能适得其反（维护成本 &gt; 受益）。应基于基线指标权衡        高更新写入压力下的过度索引          每个索引都是写放大。对高频写表，索引数量应严格节制；必要时离线/异步索引化（如汇总表/物化视图）      六、实施清单：从方案到上线的工程流程  明确目标与基线          指标：平均/尾延、QPS、Rows examined、临时表、回表次数、网络时间、锁等待        重写/加索引的操作顺序          先改写使 SARGable；再评估联合索引顺序；验证 ORDER BY/WHERE 兼容性      能覆盖索引则覆盖；无法覆盖时最小化回表列        EXPLAIN/EXPLAIN ANALYZE 验证          看 rows x filtered 评估真实扫描量；观察 Extra 是否出现 Using filesort/temporary        统计信息与优化器纠偏          执行 ANALYZE TABLE；必要时直方图；少量使用 Hint 纠偏误判        安全上线          使用 Invisible Index 预验证；在线 DDL；灰度与回滚；限流与隔离（读写分离、只读副本压测）        回归测试与极端参数          针对“TopN + Join 过滤极端稀疏”等已知退化路径，设计覆盖性测试数据，避免“线上才暴雷”      七、EXPLAIN 关键信号的快速判读  type：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL（越靠左越好）  key：命中的索引名；key_len：使用的索引前缀长度  rows、filtered：估计扫描行数与过滤比例；rows * filtered 近似为后续参与的行数  Extra：          Using index：覆盖索引，无回表      Using where：回表或额外条件过滤      Using index condition：索引下推（ICP）      Using temporary/Using filesort：排序/分组代价高，多半需要改写/加索引      Using join buffer：说明发生了 Block Nested-Loop Join，索引缺失或不匹配      八、索引设计的可执行准则（Checklist）  必做          为最常用的查询模式建立联合索引，等值列在前，范围列靠后      能覆盖就覆盖；返回列尽量落在索引上      避免函数包裹列；避免 %keyword% 的模糊匹配；避免大偏移分页      优化 ORDER BY/WHERE 一致性，必要时使用降序索引（MySQL 8.0 支持）      定期维护统计信息与直方图；使用 Invisible Index 做灰度验证        慎做          对低选择性列单独加索引      为“读少写多”的表加过多索引      在数据量很小的表上执意强索引化        不做          期望“先排序后 Join + LIMIT”在极端稀疏条件下自动变快      在数据库层硬啃“搜索引擎问题”（跨列 OR + 模糊）      九、总结  索引与慢查询优化的本质，是利用 B+ 树和统计信息，让绝大多数查询在“极小的页数与极少的随机 IO”中完成。  工程上，索引顺序、覆盖索引、SARGable 改写、ORDER BY 与 WHERE 的兼容性，是性价比最高的四大抓手。  “先排序 + LIMIT + 再 Join”的策略在大多数情况下很香，但在极端稀疏过滤下会灾难性退化，这是优化的边界之一，通常需要业务侧改造。  不要迷信“给所有条件列都加索引”，依查询而建才是正道。  持续基线化、灰度验证与极端参数回归，是让优化“安全落地”的保障。本文重点覆盖了索引优化原则、典型慢查询案例（含“排序+LIMIT+Join”悖论）、以及不可优化或不宜在数据库层优化的边界场景；提供了实施清单与 EXPLAIN 判读清单，可直接按清单逐项落地。"
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/golang/2022/10/07/Go-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-Channel%E4%B8%8EContext%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html",
    "title": "Go 并发模型：Channel 与 Context 最佳实践",
    "content": "如何用 Channel 建模生产者-消费者、扇入扇出、超时与取消？Context 在线程间传递取消与元数据，避免协程泄漏。1. 扇入扇出func fanOut(in &lt;-chan T, n int) []&lt;-chan T { /* ... */ }func fanIn(cs ...&lt;-chan T) &lt;-chan T { /* ... */ }2. 超时select {case &lt;-time.After(200*time.Millisecond): /* timeout */case v := &lt;-ch: _ = v}3. 泄漏排查  goroutine 泄漏：未读的 channel 阻塞；  使用 pprof 的 goroutine profile 与阻塞分析。"
  },

  {
    "url": "/web3/2022/10/01/Web3-NFT-%E6%A0%87%E5%87%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5.html",
    "title": "NFT 标准与应用实践：ERC-721/1155、元数据与版税",
    "content": "NFT（Non-Fungible Token）不是“把图片放上链”，而是在链上记录“不可替代的资产凭证”，其核心在于可验证的所有权、可组合的协议接口和链上/链下协作的系统工程。本文从标准、元数据与存储、铸造与交易、版税争议、动态 NFT、跨链、索引与运维全方位实战讲解。1. 标准概览与对比  ERC-721：一物一权，每个 tokenId 独立；适合独特资产（艺术品、门票）。  ERC-1155：同一合约内可发行“半同质/多类型”资产，节省 Gas；适合游戏道具/批量空投。  EIP-2981（版税建议）：提供 royaltyInfo(tokenId, salePrice) 接口，市场可选择是否尊重。  元数据 URI：tokenURI(tokenId) -&gt; string，可返回 HTTP/IPFS/Arweave 等。接口最小集合：interface IERC721 {  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);  function ownerOf(uint256 tokenId) external view returns (address);  function safeTransferFrom(address from, address to, uint256 tokenId) external;  function tokenURI(uint256 tokenId) external view returns (string memory);}2. 元数据与存储：IPFS/Arweave 与缓存  结构：name/description/image/attributes（OpenSea 等通用字段）；  存储：          中心化 HTTP（快速，但需确保持久与防篡改）；      IPFS：内容寻址（CID），需 pin 服务保障可用性；      Arweave：长久存储付费一次。        缓存：CDN 前置（Cloudflare IPFS Gateway），前端做占位与懒加载；  防篡改：在链上记录 CID（如 ipfs://CID/123.json），并将根目录 CID 固定到事件或不可变变量。生成与上传脚本（Node.js）：// 生成 10k 元数据并上传到 IPFS（示意）const { create } = await import('ipfs-http-client')const ipfs = create({ url: 'https://ipfs.infura.io:5001/api/v0' })const meta = { name:'Art #1', description:'...', image:'ipfs://.../1.png', attributes:[{trait_type:'Rarity',value:'Rare'}] }const { cid } = await ipfs.add(JSON.stringify(meta))console.log('tokenURI=ipfs://'+cid)3. 铸造/交易流程与合约实践  铸造（Mint）：公开/白名单/签名授权（EIP-712）；  交易：P2P、拍卖、订单簿；  安全：重入防护、白名单签名防复制、safeMint/safeTransferFrom 防止接收方丢失。签名白名单铸造（示意）：contract MintPass is ERC721, EIP712 {  mapping(bytes32=&gt;bool) public used;  function mint(address to, bytes calldata sig) external {    bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(keccak256(\"Mint(address to)\"), to)));    require(!used[digest],\"used\");    address signer = ECDSA.recover(digest, sig);    require(signer==whitelistSigner,\"!auth\");    used[digest]=true; _safeMint(to, ++id);  }}4. 版税争议与处理  背景：部分市场为提高流动性取消强制版税，仅保留可选打赏；  链上强制：通过转移白名单/Operator Filter 限制交易场所（兼容性差）；  现实折中：EIP-2981 提供建议值 + 市场生态共识，或链下结算；  运营建议：透明声明、签约支持版税的平台、给创作者留足分润空间。5. 动态与可组合 NFT  动态元数据：tokenURI 返回的 JSON 随链上状态或时间变化（需缓存刷新策略）；  可组合（Composable NFT）：装备/组件作为子 NFT（EIP-998/可组合规范），或通过外部合约组合查询；  关联状态：质押/解押、升级、跨合约权限校验。6. 跨链与桥接  方式：锁定-铸造、燃烧-铸造、轻客户端证明；  风险：桥被攻击、双花、流动性不足；  建议：尽量在单链内沉淀资产，通过显示跨链凭证映射，或使用成熟跨链基础设施。7. 索引与缓存：高性能展示  单个查询：ownerOf/tokenURI 直读 RPC；  批量：订阅 Transfer 事件构建持有关系；  缓存图像与元数据：CDN/边缘缓存 + 定期刷新；  SEO/社交：预生成 OpenGraph 卡片（标题/图），避免钱包/市场的拉取超时。索引器（Node + DB）示例：provider.on({ address: NFT, topics: [topicTransfer] }, async (log)=&gt;{  const { from, to, tokenId } = decode(log)  await db.tx(async t =&gt; {    if (from !== ZERO) await t.none('DELETE FROM hold WHERE addr=$1 AND id=$2',[from, tokenId])    if (to !== ZERO)   await t.none('INSERT INTO hold(addr,id) VALUES($1,$2) ON CONFLICT DO NOTHING',[to, tokenId])  })})8. 反女巫与防钓鱼  反女巫：行为/社交/设备指纹综合评分；  防钓鱼：签名提示明确用途，警惕 setApprovalForAll 的授权弹窗；  白名单分发：与 DID/VC 结合减少机器人；  前端：标注“仅签名登录/不转移资产”的提示卡片。9. 运维与看板  指标：铸造成功率、二级交易量、地板价、持有者分布、活跃度；  异常：元数据拉取失败率、渲染错误、跨链失败；  资产备份：元数据与图像的多地备份（IPFS + HTTP 备份）。10. 实操清单  设计：标准选择（721/1155）、版税策略、元数据模式；  工程：合约安全、签名授权、事件设计；  内容：版权与授权、图像防伪与盲盒揭示；  上线：白名单预热、灰度分发、市场联动；  运营：看板与告警、创作者沟通、反作弊与法务合规。  结语：NFT 的价值在于“开放可验证的所有权”和“可组合的协议接口”。在实践中，工程与运营要素同样重要：安全、缓存、跨链风控、看板告警，缺一不可。"
  },

  {
    "url": "/web3/2022/05/18/Web3-%E4%BB%A3%E5%B8%81%E7%BB%8F%E6%B5%8E%E5%AD%A6-%E4%BB%8E%E8%AE%BE%E8%AE%A1%E5%88%B0%E5%AE%9E%E6%93%8D.html",
    "title": "加密货币与代币经济：从模型设计到实操监控",
    "content": "代币经济（Tokenomics）是协议可持续的核心约束。成功的设计既要有工程严谨性（参数/代码/可观测）也要有博弈论直觉（激励一致性/抗攻击）。本文从“发行→释放→流动性→治理→风控→监控看板”构建一套可落地的代币经济方法论，附上可复用的合约与脚本片段。1. 发行与释放（Token Generation &amp; Emission）  初始分配：团队/顾问/投资人/社区/金库比例；  释放曲线：线性/阶梯/里程碑触发，避免短期砸盘；  锁仓与归属（vesting）：可撤回与不可撤回的权衡；  二级市场前的“冷启动”：空投/任务/白名单+反女巫。合约片段（Vesting）：contract Vesting {  IERC20 public token; mapping(address=&gt;uint256) public total; mapping(address=&gt;uint256) public claimed; uint64 public start; uint64 public cliff; uint64 public duration;  function claim() external { /* 线性释放，检查 cliff 后可领取 */ }}2. 治理与金库（Treasury）  治理代币与权重：一币一票/锁定加权/代表委托；  投票与执行：Snapshot+Governor，Timelock 管控；  金库支出：预算提案→投票→多签执行；  长期激励：生态基金、Grants、赏金计划。3. 流动性与做市（AMM/CEX/MM）  AMM：Uniswap v2（x*y=k）、v3 集中流动性（价格区间提供）；  初始流动性：金库注入与 LP 代币管理；  价稳策略：回购与销毁、协议费回流；  防闪崩：限价/时间加权平均（TWAP）价作为参考。操作脚本（提供流动性）：// 使用 viem/ethers 调用路由合约添加流动性4. 模型案例与参数  通胀模型：恒定/递减/事件触发；  双代币模型：治理代币 + 价值捕获代币（fee share/质押奖励）；  激励分配：按使用量/贡献度发放，反垃圾策略（行为签名/反女巫）；  费用结构：交易费/提取费/提前解锁罚金；  跨链发行：桥接与记账，避免双花。5. 反女巫与合规  反女巫：PoH、社交图、设备/行为指纹、多维度阈值；  合规：KYC/AML、地区限制、证券属性评估；  法务协调：条款、风险披露、隐私策略。6. 风控指标与告警  持仓集中度（头部地址占比）；  周转率与链上活跃度；  价格锚（预言机）与滑点监测；  资金流入/流出异常、跨链桥风险；  善意与恶意机器人占比（MEV/三明治）。7. 仪表盘与数据源  On-chain 指标：自建 ETL 或 dune/subsquid；  价格与流动性：The Graph、Coingecko API；  金库资产与支出：多签事件索引（Gnosis Safe）。8. 运营节奏与迭代  周期性回顾：代币释放/通胀/金库余额/激励效果；  参数治理：SIP/提案流程，临时变更走紧急流程；  防御演练：闪崩/预言机异常/桥被攻击时的兜底方案。9. 小结代币经济的“好坏”，体现在能否让参与者激励一致并抵御攻击。用工程化手段（合约/脚本/看板/告警）让模型“可测量、可回滚、可演进”，才是真正可持续的路径。"
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/java/2022/03/30/Java-Spring-%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E9%99%B7%E9%98%B1.html",
    "title": "Java Spring 事务传播与隔离级别陷阱",
    "content": "事务机制在软件开发中扮演举足轻重的角色。本文系统介绍数据库与分布式事务的原理与应用、隔离级别与典型并发现象示例，并结合 Spring 的传播机制与实现原理，最后从 CAP 视角给出大型系统中确保“相对一致性”的工程方案与实战蓝本。一、为何需要事务  目标：在并发与故障条件下，保证数据正确性与可预期性。  ACID：原子性、一致性、隔离性、持久性；工程上需在性能、可用性与一致性间权衡。二、数据库事务与隔离级别（含示例）  常见隔离级别与现象          Read Uncommitted：可能脏读；几乎不用。      Read Committed (RC)：避免脏读；仍有不可重复读与幻读（PostgreSQL 默认）。      Repeatable Read (RR)：同一事务内多次读取结果一致；InnoDB 的 RR 基于 MVCC + Next-Key Lock，普通一致性读看到“快照”，更新扫描加间隙锁抑制幻行（MySQL 默认）。      Serializable：最强隔离；性能代价大，通常依赖锁或乐观并发控制。        并发现象最小示例          脏读（只在 RU）：        -- 会话ABEGIN;UPDATE account SET balance = balance - 100 WHERE id = 1; -- 未提交-- 会话B（RU）SELECT balance FROM account WHERE id = 1; -- 读到未提交数据（脏读）                    不可重复读（RC）：        -- 会话ABEGIN;SELECT balance FROM account WHERE id = 1; -- 读到 1000-- 会话BBEGIN; UPDATE account SET balance = 900 WHERE id = 1; COMMIT;-- 会话ASELECT balance FROM account WHERE id = 1; -- 再读到 900（不可重复读）COMMIT;                    幻读（RC 或部分 RR 场景）：        -- 会话ABEGIN;SELECT * FROM orders WHERE amount &gt; 100; -- 返回 N 行-- 会话BINSERT INTO orders(id, amount) VALUES(999, 200); COMMIT;-- 会话ASELECT * FROM orders WHERE amount &gt; 100; -- 返回 N+1 行（幻读）COMMIT;                      实现与注意          MVCC：RC/RR 通过快照读减少锁冲突；RR 在 InnoDB 下对“锁定读/更新”使用 Next-Key Lock 抑制幻读。      加锁读：SELECT ... FOR UPDATE/LOCK IN SHARE MODE 可确保当前读一致且参与加锁，抑制写冲突与幻读。      建议：默认 RC/RR；强一致写路径（转账、库存）采用 RR + 加锁读，或使用可控的序列化/业务锁。      三、分布式事务模式与取舍  XA/2PC（协调器 + 参与者，两阶段提交）          优点：强一致；缺点：阻塞、对资源管理器要求高、性能与可用性差；云原生场景较少采用。        TCC（Try-Confirm-Cancel）          优点：业务可感知，接口粒度可控；缺点：实现复杂，需要补偿与悬挂/空回滚处理；适用于账务/库存等核心域。        Saga（编排/舞蹈）          优点：最终一致、扩展性好；缺点：中间态可见、补偿设计复杂；适用于电商下单等长链路。        可靠消息 + Outbox          优点：本地事务落库，与“待发消息”同库同事务，异步发布，消费端幂等；工程落地成熟。      缺点：引入异步与补偿复杂度；需要投递保证与去重。      四、Spring 事务：传播机制与实现原理  实现原理          AOP 代理（JDK/CGLIB）拦截 @Transactional 方法，委派 TransactionInterceptor。      PlatformTransactionManager（如 DataSourceTransactionManager/JpaTransactionManager）负责开启/提交/回滚。      TransactionSynchronizationManager 用 ThreadLocal 绑定连接/资源与同步回调。      回滚规则：默认对 RuntimeException/Error 回滚；受检异常需显式 rollbackFor。        源码级实现细节（传播行为如何生效）          激活入口（配置）：@EnableTransactionManagement → TransactionManagementConfigurationSelector → 注册 ProxyTransactionManagementConfiguration                  定义 BeanFactoryTransactionAttributeSourceAdvisor（切点）          使用 AnnotationTransactionAttributeSource 解析 @Transactional          注入 TransactionInterceptor（拦截器）                    代理创建：基础设施自动代理器（如 InfrastructureAdvisorAutoProxyCreator）为匹配切点的方法创建 JDK/CGLIB 代理，解决横切逻辑织入      拦截主链：TransactionInterceptor#invoke → TransactionAspectSupport#invokeWithinTransaction1) 解析事务属性：TransactionAttributeSource#getTransactionAttribute2) 解析事务管理器：determineTransactionManager（支持 transactionManager 指定）3) 按传播语义开/加入事务：createTransactionIfNecessary → PlatformTransactionManager#getTransaction4) 调用业务方法：invocation.proceed()5) 正常则 commit，异常走 completeTransactionAfterThrowing 判定回滚（TransactionAttribute#rollbackOn(Throwable)，默认仅回滚 RuntimeException/Error）      传播决策核心：AbstractPlatformTransactionManager#getTransaction(TransactionDefinition)                  若存在事务（isExistingTransaction）：                          PROPAGATION_REQUIRED/SUPPORTS/MANDATORY：加入当前事务（共享连接与同步）              PROPAGATION_REQUIRES_NEW：suspend 挂起当前事务 → doBegin 开新事务 → 结束后 resume              PROPAGATION_NOT_SUPPORTED：suspend 挂起，以非事务方式执行 → resume              PROPAGATION_NEVER：存在事务直接抛 IllegalTransactionStateException              PROPAGATION_NESTED：如支持保存点（useSavepointForNestedTransaction）则在当前事务 createSavepoint，失败回滚到保存点；否则可能抛 NestedTransactionNotSupportedException                                若不存在事务：                          REQUIRED/REQUIRES_NEW/NESTED：doBegin 开启新事务（NESTED 在无外部事务时等价于新事务）              SUPPORTS：非事务执行              MANDATORY：抛 IllegalTransactionStateException              NOT_SUPPORTED/NEVER：非事务执行                                          数据源事务实现（典型）：DataSourceTransactionManager                  开启：doBegin 获取连接并配置隔离级别、setReadOnly(true)、setAutoCommit(false)，绑定 ConnectionHolder 至 TransactionSynchronizationManager          挂起/恢复：doSuspend/doResume 解绑/重新绑定资源          提交/回滚：doCommit/doRollback；NESTED 通过 SavepointManager 创建/回滚保存点                    资源与同步：TransactionSynchronizationManager                  线程级别绑定资源：bindResource/unbindResource（如 DataSource → ConnectionHolder）          暴露上下文：isActualTransactionActive、getCurrentTransactionName、isCurrentTransactionReadOnly          注册同步回调：registerSynchronization（JPA/Hibernate flush、MQ 出库回调等借此挂接）                    隔离与只读映射：TransactionDefinition → JDBC Connection#setTransactionIsolation 与 setReadOnly（是否真正生效取决于驱动与数据库）      关键类型速览：TransactionAttribute/RuleBasedTransactionAttribute（回滚规则）、RollbackRuleAttribute、TransactionStatus（事务状态/保存点控制）      JPA/Hibernate Flush 时机与事务边界  Flush 不等于提交：Flush 将持久化上下文（一级缓存）中的变更同步到数据库，但仍处于当前数据库事务内，直到 commit。  触发时机（Hibernate FlushModeType.A\u00000UTO 默认）：          查询前：为保证查询结果与当前持久化上下文一致，可能在执行查询前先 flush（同表/相关实体时）。      显式调用：EntityManager.flush()/Session.flush()。      事务完成前：在 commit 前自动 flush。        Flush 模式：          AUTO（默认）：必要时自动 flush（查询前/提交前）。      COMMIT：延迟到提交前再 flush（可能减少中途多次 flush）。      MANUAL：仅在显式调用 flush() 时触发。        与 Spring 只读事务的关系：          Spring 在使用 Hibernate 时，@Transactional(readOnly = true) 通常通过方言（如 HibernateJpaDialect）将会话 flush 模式降为 MANUAL，减少不必要的脏检查与 flush；这只是“优化提示”，并不强制禁止写入。      仍需数据库权限控制与代码自律（如不在只读事务中执行写操作）。        一致性影响：由于 AUTO 模式下查询可能触发 flush，很多约束/唯一键冲突会在“查询时”或“提交前”抛出，而非在调用 persist() 当下，测试时需注意断言位置。@Transactionalpublic void demo(EntityManager em) {  user.setEmail(\"dup@example.com\");  em.persist(user);  // 这里未必立即抛异常  em.createQuery(\"select u from User u where u.email = :e\")    .setParameter(\"e\", \"someone@example.com\")    .getResultList(); // 若查询触发 flush，唯一索引冲突可能在此处抛出}OpenEntityManagerInView 模式影响与建议  原理：OpenEntityManagerInViewFilter/Interceptor 在 Web 请求整个生命周期内绑定 EntityManager 到线程，使得 Controller/View 层在 Service 事务结束后仍可进行延迟加载，避免 LazyInitializationException。  风险：          模糊事务边界：在“视图渲染期”继续访问数据库，容易形成 N+1 查询与不可预期的长连接占用。      可观测性降低：难以定位慢查询发生在业务层还是视图层。      写路径混入：若无约束，视图层也可能触发写相关 flush（尽管少见，但应避免）。        Spring Boot 默认：spring.jpa.open-in-view 在多数版本默认 true，官方已在 2.x/3.x 强烈提示谨慎使用。  建议：          对写请求或核心域接口，设置 spring.jpa.open-in-view=false，在 Service 层完成 DTO 裁剪/投影映射与必要的 fetch join。      对读多的页面，如确需开启，务必配合 @Transactional(readOnly = true)、限制查询数量、启用二级缓存/查询缓存谨慎优化。      通过 EntityGraph/fetch join/投影（如 Spring Data JPA interface-based projections）解决懒加载需求。      # application.ymlspring:  jpa:    open-in-view: false// 通过 fetch join 在事务内一次性加载所需数据@Query(\"select o from Order o join fetch o.items where o.id = :id\")Optional&lt;Order&gt; findWithItems(@Param(\"id\") Long id);调用链流程图（简化）sequenceDiagram  autonumber  participant Client  participant Proxy as AOP Proxy  participant TI as TransactionInterceptor  participant TAS as TransactionAttributeSource  participant TM as PlatformTransactionManager  participant Biz as BusinessMethod  Client-&gt;&gt;Proxy: 调用 @Transactional 方法  Proxy-&gt;&gt;TI: invoke()  TI-&gt;&gt;TAS: 解析事务属性  TI-&gt;&gt;TM: getTransaction(def)  TM--&gt;&gt;TI: TransactionStatus（可能挂起/新建/加入）  TI-&gt;&gt;Biz: proceed()  Biz--&gt;&gt;TI: 返回或抛异常  alt 正常返回    TI-&gt;&gt;TM: commit(status)  else 异常    TI-&gt;&gt;TM: rollback(status)（按 rollbackOn 判定）  end  TI--&gt;&gt;Proxy: 返回结果  Proxy--&gt;&gt;Client: 返回结果传播决策流程（核心分支）flowchart TD  A[进入 getTransaction] --&gt; B{是否存在事务}  B -- 否 --&gt; C{传播属性}  C -- REQUIRED/REQUIRES_NEW/NESTED --&gt; D[doBegin 新事务]  C -- SUPPORTS/NOT_SUPPORTED/NEVER --&gt; E[非事务执行]  C -- MANDATORY --&gt; F[抛 IllegalTransactionStateException]  B -- 是 --&gt; G{传播属性}  G -- REQUIRED/SUPPORTS/MANDATORY --&gt; H[加入当前事务]  G -- REQUIRES_NEW --&gt; I[suspend 挂起 -&gt; doBegin 新事务]  G -- NOT_SUPPORTED --&gt; J[suspend 挂起 -&gt; 非事务]  G -- NEVER --&gt; K[抛 IllegalTransactionStateException]  G -- NESTED --&gt; L[createSavepoint 保存点]精简源码片段引用（Spring Framework）// org.springframework.transaction.interceptor.TransactionInterceptorpublic Object invoke(MethodInvocation invocation) throws Throwable {    Class&lt;?&gt; targetClass = AopUtils.getTargetClass(invocation.getThis());    return invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);}// org.springframework.transaction.interceptor.TransactionAspectSupportprotected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass,                                         InvocationCallback invocation) throws Throwable {    TransactionAttributeSource tas = getTransactionAttributeSource();    TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);    PlatformTransactionManager tm = determineTransactionManager(txAttr);    TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, methodIdentification(method, targetClass));    try {        Object ret = invocation.proceedWithInvocation();        commitTransactionAfterReturning(txInfo);        return ret;    }    catch (Throwable ex) {        completeTransactionAfterThrowing(txInfo, ex);        throw ex;    }    finally {        cleanupTransactionInfo(txInfo);    }}// org.springframework.transaction.support.AbstractPlatformTransactionManagerpublic final TransactionStatus getTransaction(TransactionDefinition definition)        throws TransactionException {    Object transaction = doGetTransaction();    if (isExistingTransaction(transaction)) {        // 根据传播行为: REQUIRED/SUPPORTS/MANDATORY/REQUIRES_NEW/NOT_SUPPORTED/NEVER/NESTED        return handleExistingTransaction(definition, transaction, debugEnabled);    }    // 无事务，根据传播行为决定 doBegin 或非事务/异常    return startTransaction(definition, transaction, debugEnabled);}// org.springframework.jdbc.datasource.DataSourceTransactionManagerprotected void doBegin(Object transaction, TransactionDefinition definition) {    Connection con = DataSourceUtils.getConnection(this.dataSource);    con.setAutoCommit(false);    prepareTransactionalConnection(con, definition); // 隔离级别/只读    DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;    txObject.setConnectionHolder(new ConnectionHolder(con), true);    TransactionSynchronizationManager.bindResource(this.dataSource, txObject.getConnectionHolder());}  版本注记：上述调用链在 Spring Framework 5.3.x 与 6.x 之间主体一致；个别方法签名与内部重构可能略有差异，但关键职责与流程相同。  传播行为（常用）          REQUIRED（默认）：有则加入，无则新建；通用首选。      REQUIRES_NEW：挂起外部事务，新建新事务；常用于审计/日志/可靠消息，避免与外层同生共死。      SUPPORTS：有则加入，无则非事务。      MANDATORY：必须在事务内，否则异常。      NOT_SUPPORTED：挂起事务，以非事务方式执行；适合大查询/报表。      NEVER：存在事务则抛异常。      NESTED：保存点；内层失败可局部回滚（需 JDBC Savepoint 与 DataSourceTransactionManager 支持；JPA 不支持真嵌套）。        关键示例          REQUIRED 与 REQUIRES_NEW：        @Servicepublic class OrderService {  @Transactional // REQUIRED  public void placeOrder() {    inventoryService.deduct();    auditService.record(); // 方法上标注 REQUIRES_NEW，独立提交  }}                    NESTED 局部回滚：        @Transactionalpublic void batchCreate(List&lt;Item&gt; items) {  for (Item item : items) {    userService.createOneNested(item); // @Transactional(propagation = NESTED)  }}                      常见陷阱          自调用不生效（同类内方法互调绕过代理）；将被调方法提取到另一 @Service 或注入自身代理。      private/final 方法、构造器不拦截；异步/新线程无事务上下文。      多数据源需独立 TransactionManager 或采用分布式事务模式。      readOnly=true 仅作优化提示，不保证不写；仍需权限与代码约束。      NESTED 仅在底层事务管理器支持保存点时才是真嵌套（如 DataSourceTransactionManager）；JpaTransactionManager 不支持嵌套，可能抛异常或退化为新事务策略。      五、大型系统一致性策略（结合 CAP）  CAP 取舍：分布式系统必须容忍分区（P），在一致性（C）与可用性（A）间取舍。          CP 优先：撮合引擎、资金账本、强一致库存；采用单主/共识、严格限流与降级，牺牲可用性换正确性。      AP 优先：订单、推荐、搜索、报表；采用最终一致、补偿/重试、幂等、读写分离、缓存旁路。        工程基线          本地事务 + 出库表（Outbox）+ MQ      幂等：幂等键/唯一索引/幂等表、去重缓存、乐观锁（version/timestamp）      显式状态机：订单/库存/支付状态跃迁，防止“写两份不同真相”      读模型：CQRS/物化视图；前台读可用性优先，后台对账纠偏      重试与时序：至少一次投递 + 幂等消费，必要时按业务键分区保证顺序      热点与锁：场景化选择悲观/乐观/分布式锁，控制锁粒度与超时      六、实战蓝本（落地建议）      可靠消息 + Outbox 工作流1) 业务服务本地事务内：写业务数据 + 写 outbox（状态 PENDING）2) 提交后由发布器轮询/CDC 发布 MQ；成功标记 SENT3) 消费者：用“消息ID 唯一索引/去重表”保证幂等；处理成功后标记完成4) 失败自动重试（指数退避）+ 死信队列 + 人工干预    @Transactionalpublic void createOrder(CreateOrderCmd cmd) {  orderRepo.save(order);  outboxRepo.save(Outbox.of(\"OrderCreated\", payload, msgId));}        Saga（编排型）：编排器持久化 Saga 状态，顺序调用步骤；失败按反向补偿逐一回滚。  TCC 接口：资源服务提供 try/reserve、confirm、cancel；实现幂等、空回滚与悬挂处理。七、测试与验证建议  隔离级别：集成测试开两连接/两线程，用 CountDownLatch 控制交错，验证 RC/RR 行为与锁持有。  传播机制：SpringBootTest + Testcontainers，验证 REQUIRES_NEW 独立提交、NESTED 保存点回滚。  一致性链路：本地起 MQ（Kafka/RabbitMQ），模拟网络抖动、重复投递、乱序，核验幂等。  观测性：为每个事务/消息打 traceId、msgId，收集提交时延、重试次数、DLQ 速率等指标。八、实施注意  严格控制事务边界与时长：仅包裹必要的 DB 写入与同库查询，不包远程调用/外部 IO。  明确每条链路的目标一致性等级与降级策略。  把“补偿与对账”作为一等公民：对账任务、自动巡检、纠偏脚本。"
  },

  {
    "url": "/web3/2021/11/06/Web3-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E5%AE%89%E5%85%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html",
    "title": "智能合约工程与安全最佳实践：Solidity/Foundry 上手到上线",
    "content": "智能合约是 Web3 应用的“规则中枢”。它一经部署即“公开、自动、可验证”，带来强信任的同时也几乎没有运维回旋空间。要在生产环境长期稳定运行，必须以工程化与安全为第一原则：标准化目录结构、完善测试与审计流程、上线策略与紧急预案、可观测与变更留痕。本文体系化给出从 0 到 1 的落地路径与可直接复用的清单。1. 工程化目录与依赖管理  目录结构建议：    contracts/       # 合约源码└── modules/     # 复用模块（库、接口）src/             # 或 contracts/（Foundry 惯例为 src/）scripts/         # 部署与迁移脚本lib/             # 依赖（OpenZeppelin 等）test/            # 单元/属性/模糊测试out/             # 构建产物（abi、bin）        依赖：锁定版本，尽量固定到 commit（forge install OpenZeppelin/openzeppelin-contracts@v5.0.1）。  约定：Solidity ^0.8.x，启用 viaIR/优化器配置；启用 emit 与事件留痕，重要状态变化务必emit 事件。2. 测试金字塔：单元→属性→模糊→集成  单元测试：逻辑分支与边界（溢出/零地址/重复调用）；  属性测试（invariant）：在任意序列操作下不变式成立（余额守恒、权限不泄露、利率界限）；  模糊测试：随机生成输入与调用序列，捕获隐藏分支（Foundry forge test --fuzz-runs 10000）；  集成测试：与真实依赖交互（主网 fork），验证预言机、路由器、金库等外部合约适配。示例（Foundry）：contract Invariant is Test {  MyVault v; ERC20 token;  function setUp() public { /* 部署并注入 */ }  function invariant_totalSupplyLeBalance() public view {    assertLe(v.totalSupply(), token.balanceOf(address(v)));  }}3. 常见漏洞矩阵与防护| 类型 | 描述 | 防护 || — | — | — || 重入 | 外部调用后状态未更新 | Checks-Effects-Interactions、ReentrancyGuard、最小外部调用 || 访问控制 | onlyOwner 缺失/后门 | 明确角色（AccessControl）、多签、不可升级关键路径 || 算术 | 下溢/溢出（&lt;0.8） | Solidity 0.8+ 或 SafeMath || 授权 | ERC20 approve 竞态 | increaseAllowance/permit，或拉取模型 || 预言机 | 价格被操纵 | 取中值/时间加权、聚合源、熔断 || 可升级 | 存储冲突/不可逆 | UUPS/Transparent Proxy 模式，固定存储布局，脚本化校验 || 随机性 | blockhash 可预测 | VRF 或承诺-揭示（commit-reveal） || 初始化 | 代理未初始化 | initializer 修饰器与构造参数校验 |4. 审计前自查与工具  Slither：静态分析（可集成 CI）；  Mythril/ConsenSys Diligence：符号执行；  Echidna/Foundry：属性/模糊测试；  Surya：合约可视化，辅助审查调用图；  Foundry debug：调试交易回溯；  Gas Reporter：识别高消耗路径。CI 示例：name: solidity-cion: [push, pull_request]jobs:  test:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v3      - uses: foundry-rs/foundry-toolchain@v1        with: { version: nightly }      - run: forge build      - run: forge test -vv --ffi      - run: slither . --solc-remaps @openzeppelin=lib/openzeppelin-contracts/5. Gas 优化与经济性  读/写路径拆分，减少 SSTORE 次数；  unchecked 包裹可证明安全的运算；  事件参数使用 indexed 提高检索效率；  小心 for/数组扩容，必要时映射替代；  批处理与“延迟结算”减少链上交互次数；  将重计算改为链下预处理+链上验证（ZK/签名校验）。6. 可升级/代理模式与版本治理  Transparent Proxy：用户总是通过 Proxy 地址交互；  UUPS：逻辑合约自持升级；  风险：存储槽冲突、初始化复用、访问控制绕过；  治理：升级由多签/Timelock 控制，至少 24h 延时+公告。存储布局对齐示例：contract V1 { uint256 a; }contract V2 is V1 { uint256 b; } // 仅追加，不可重排/删除7. 部署、参数与变更留痕  所有部署脚本参数入库（链ID、实现地址、Proxy 地址、owner 多签、初始化参数）；  生成 deployments.json，前端/后端/监控统一读取；  变更审计：每次升级/参数调整产生日志与签名人列表；  版本标签：事件中携带 VERSION，便于索引。Foundry 脚本：contract Deploy is Script {  function run() external {    vm.startBroadcast();    Impl impl = new Impl();    TransparentUpgradeableProxy p = new TransparentUpgradeableProxy(address(impl), admin, data);    vm.stopBroadcast();  }}8. 紧急预案与演练  Kill Switch（暂停开关）仅限关键逻辑，使用 Pausable；  金库提款白名单与日限额，防单点提空；  回滚流程：升级记录可随时回退至前版本实现；  演练：季度在低流量窗口做“带压回滚/暂停/恢复”演练。9. 观测与运营  事件流：关键事件建立告警规则（异常频次/金额阈值）；  交易成败与 Gas：P95 确认时间、失败率；  用户路径：签名拒绝率、网络切换失败率；  合作依赖：预言机更新延迟、路由合约可用性；  文档与教育：授权/签名解释页、风险披露、常见问题库。10. 小结合约开发不是“写几份 Solidity 就完事”，而是端到端的工程体系：安全第一、测试充分、可观测完备、上线有门禁、变更可回滚。以“最小信任后端+合约为规则源+严格审计与演练”的组合，才能在开放环境中长期生存。"
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/php/2021/06/10/PHP-%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E4%B8%8E%E9%9B%86%E4%B8%AD%E5%8C%96.html",
    "title": "PHP 实时日志采集与集中化",
    "content": "如何在 PHP 体系下实现实时日志采集、清洗、聚合与检索？本文结合物理机与 Kubernetes 两种运行环境，给出分阶段演进路线、最佳实践与可落地配置（EFK/PLG/ClickHouse/OTel），并附带 PHP 端具体实现建议。架构概览物理机 / VM 拓扑flowchart TD  A[\"微服务 (物理机/VM)\"] --&gt; B[\"应用日志: JSON 文件 / journald\"]  B --&gt; C[\"宿主机 Agent: Fluent Bit / Vector / OTel Collector\"]  C --&gt;|\"TLS+重试+背压\"| D[\"Kafka (可选缓冲)\"]  C --&gt; E[\"处理/路由: Logstash / OTel Collector / Vector\"]  D --&gt; E  E --&gt; F[\"Elasticsearch / OpenSearch\"]  E --&gt; G[\"ClickHouse\"]  E --&gt; H[\"Loki\"]  F --&gt; I[\"可视化: Kibana / Grafana\"]  G --&gt; I  H --&gt; I  J[\"治理: 时间同步(NTP) + 结构化Schema + 脱敏/掩码\"] -.-&gt; EKubernetes 拓扑flowchart TD  subgraph K8s[\"Kubernetes 集群\"]    A1[\"Pod: 微服务容器\"] --&gt; B1[\"stdout/stderr (结构化JSON)\"]    B1 --&gt; C1[\"DaemonSet: Fluent Bit / Vector\"]    A1 --&gt; D1[\"Sidecar(可选): OTel Collector / Fluent Bit\"]    C1 --&gt;|\"TLS+背压+限流\"| E1[\"集群网关: OTel Collector / Ingress\"]  end  E1 --&gt; F1[\"Kafka / NATS / Redis Streams (缓冲)\"]  E1 --&gt; G1[\"Loki / Elasticsearch / ClickHouse\"]  F1 --&gt; H1[\"处理与路由: Logstash / Vector / OTel Collector\"]  H1 --&gt; G1  G1 --&gt; I1[\"Grafana / Kibana / 自研埋点分析\"]  J1[\"治理: 多租户、标签、索引生命周期、合规脱敏\"] -.-&gt; H1演进阶段与适用场景  传统本地文件 + logrotate：单机/少量服务；简单但难检索、风险高。  中央化 Syslog（rsyslog/syslog-ng/journald）：轻量汇聚，结构化不足。  EFK/ELK：强检索与可视化；成本与治理压力需控制（ILM）。  容器化（stdout JSON + DaemonSet Agent）：与 K8s 契合；注意 label 基数。  事件流驱动（Kafka/NATS 缓冲解耦）：高吞吐可重放；链路更长。  OpenTelemetry 一体化：标准 OTLP，日志/链路/指标互相关联。  成本/性能优化（Loki/ClickHouse/对象存储分层）：性价比高，查询语义差异需适配。通用最佳实践  结构化与上下文：统一 JSON Schema（timestamp、level、service、env、trace_id、span_id、request_id、user_id）。  安全合规：采集端脱敏/掩码；TLS 传输；RBAC；多租户隔离。  稳定性：本地缓冲、断点续传、退避重试、背压/限流、时钟同步。  成本与性能：控制日志级别与采样；热/温/冷分层；限制高基数字段。  运维治理：ILM/TTL；集中配置与热更新；SLO/告警（延迟、拒收、落库错误率）。物理机/VM 最佳实践推荐：应用输出 JSON 到文件或 journald；宿主机 Agent（Fluent Bit/Vector/OTel Collector）采集→可选 Kafka 缓冲→后端（OpenSearch/ClickHouse/Loki）。Fluent Bit（Tail → Kafka → OpenSearch）[SERVICE]    Flush        1    Parsers_File parsers.conf    Log_Level    info[INPUT]    Name              tail    Path              /var/log/app/*.log    Tag               app.*    Multiline         On    Parser            docker    DB                /var/lib/fluent-bit/tail.db    Mem_Buf_Limit     50MB    Skip_Long_Lines   On[FILTER]    Name          modify    Match         app.*    Add           env prod    Add           service myservice[OUTPUT]    Name            kafka    Match           app.*    Brokers         kafka-1:9092,kafka-2:9092    Topics          logs.app    rdkafka.queue.buffering.max.ms 100    rdkafka.compression.codec      lz4    rdkafka.security.protocol      ssl[OUTPUT]    Name            es    Match           app.*    Host            opensearch.local    Port            9200    HTTP_User       fluent    HTTP_Passwd     xxxxxx    Logstash_Format On    tls             OnVector（Tail → 脱敏 → Loki）[sources.app]type = \"file\"include = [\"/var/log/app/*.log\"]ignore_older_secs = 86400fingerprint.strategy = \"device_and_inode\"[transforms.mask]type = \"remap\"inputs = [\"app\"]source = '''. = parse_json!(.message).email = replace!(.email, r'([\\\\w.%+-]+)@([\\\\w.-]+\\\\.[A-Za-z]{2,})', \"***@***\").credit_card = null'''[sinks.loki]type = \"loki\"inputs = [\"mask\"]endpoint = \"https://loki.local\"encoding.codec = \"json\"labels = {service=\"myservice\", env=\"prod\"}out_of_order_action = \"accept\"logrotate（与 tail/采集器配合）/var/log/app/*.log {  daily  rotate 7  compress  missingok  copytruncate  create 0640 app app}Kubernetes 最佳实践原则：应用只输出 stdout JSON；使用 DaemonSet（Fluent Bit/Vector/Promtail）统一采集 /var/log/containers/*，自动附加 k8s 元数据；Sidecar 仅在需本地解析/脱敏时使用；开启本地缓冲、资源限额、背压与基数治理。Fluent Bit DaemonSet（Containers → Loki）[SERVICE]    Parsers_File parsers.conf[INPUT]    Name              tail    Path              /var/log/containers/*.log    Tag               kube.*    Parser            docker    Docker_Mode       On    Mem_Buf_Limit     100MB    DB                /var/fluent-bit/tail.db[FILTER]    Name                kubernetes    Match               kube.*    Kube_URL            https://kubernetes.default.svc:443    Merge_Log           On    Keep_Log            Off[OUTPUT]    Name          loki    Match         kube.*    Host          loki-gateway    Port          3100    Labels        job=fluentbit, env=prod, kubernetes['namespace_name'], kubernetes['container_name']    Auto_kubernetes_labels OnPromtail（自动发现 Pods）scrape_configs:- job_name: kubernetes-pods  pipeline_stages:  - docker: {}  - labeldrop:      - filename  kubernetes_sd_configs:  - role: pod  relabel_configs:  - source_labels: [__meta_kubernetes_pod_label_app]    target_label: appOpenTelemetry Collector（OTLP/filelog → Kafka/Loki）receivers:  otlp:    protocols: {http: {}, grpc: {}}  filelog:    include: [/var/log/containers/*.log]    operators:    - type: json_parserprocessors:  batch: {}  attributes:    actions:    - key: env      value: prod      action: upsertexporters:  kafka:    brokers: [kafka-1:9092]    topic: logs.app  loki:    endpoint: http://loki:3100/loki/api/v1/pushservice:  pipelines:    logs/primary:      receivers: [filelog, otlp]      processors: [attributes, batch]      exporters: [kafka, loki]可落地方案与模板小团队低成本（PLG）  Promtail/Fluent Bit → Loki → Grafana；控制标签基数，分层保留。    limits_config:retention_period: 168hcompactor:working_directory: /data/compactorcompaction_interval: 5mdelete_request_cancel_period: 24h      中型团队检索优先（EFK + Kafka）  Fluent Bit/Vector → Kafka → Logstash/OTel Collector → OpenSearch；Kafka 缓冲与多消费者，OpenSearch 做 ILM。    {\"policy\": {  \"phases\": {    \"hot\": {\"actions\": {\"rollover\": {\"max_size\": \"50gb\", \"max_age\": \"7d\"}}},    \"warm\": {\"actions\": {\"forcemerge\": {\"max_num_segments\": 1}}},    \"cold\": {\"min_age\": \"30d\", \"actions\": {\"freeze\": {}}},    \"delete\": {\"min_age\": \"90d\", \"actions\": {\"delete\": {}}}  }}}      海量吞吐/性价比（Vector + ClickHouse）  Vector DS/Agent → Vector Aggregator → ClickHouse（MergeTree/表分区）。    CREATE TABLE logs.app(ts DateTime CODEC(Delta, ZSTD),level LowCardinality(String),service LowCardinality(String),trace_id String,message String,k8s_namespace LowCardinality(String),labels Map(String, String))ENGINE = MergeTreePARTITION BY toDate(ts)ORDER BY (service, ts)TTL ts + INTERVAL 30 DAY DELETESETTINGS index_granularity = 8192;      合规与审计  采集端脱敏（Vector remap/Fluent Bit grep），传输与落盘加密，审计日志 WORM/对象存储锁不可篡改。边缘/离线  本地持久化缓冲，网络可用回传；启用压缩与节流；按优先级丢弃非关键日志。PHP 实践与配置示例目标  统一 JSON Schema；stdout（K8s）或文件/journald（VM）；与链路追踪关联（trace_id/span_id）；采集端脱敏与缓冲。Monolog（stdout JSON + 关联上下文）&lt;?phprequire 'vendor/autoload.php';use Monolog\\\\Logger;use Monolog\\\\Handler\\\\StreamHandler;use Monolog\\\\Formatter\\\\JsonFormatter;$logger = new Logger('app');$handler = new StreamHandler('php://stdout', Logger::INFO);$handler-&gt;setFormatter(new JsonFormatter(JsonFormatter::BATCH_MODE_JSON, false));// 处理器：注入通用字段（建议从请求头、会话、OTel 上下文中提取）$logger-&gt;pushProcessor(function (array $record) {    $record['extra']['env'] = getenv('APP_ENV') ?: 'prod';    $record['extra']['service'] = 'my-php-service';    $record['extra']['request_id'] = $_SERVER['HTTP_X_REQUEST_ID'] ?? null;    $record['extra']['trace_id'] = $_SERVER['HTTP_X_TRACE_ID'] ?? null; // 或从 OTel SDK 获取    $record['extra']['user_id'] = $_SESSION['user_id'] ?? null;    return $record;});$logger-&gt;pushHandler($handler);// 示例$logger-&gt;info('user login', ['user_id' =&gt; 123]);$logger-&gt;error('db failed', ['error_code' =&gt; 'DB_CONN_TIMEOUT']);PHP-FPM/Nginx（容器化）将错误与访问日志输出到 stdout/stderr; php.inilog_errors = On; php-fpm.conf 或 www.conferror_log = /proc/self/fd/2; 可选：将 FPM 访问日志也导向 stdout/stderr; access.log = /proc/self/fd/2物理机（文件落盘）  Monolog 将日志写入 /var/log/app/app.log，配合 logrotate；采集器使用 tail 指纹/offset 防重。与 OpenTelemetry 关联  在反向代理或应用层透传 traceparent/baggage，在 Processor 中提取 trace_id/span_id；  采用 OTel PHP SDK（可选）向后端上报 Traces，与 Logs 通过共同字段实现互跳。常见坑与自检清单  时间戳/时区混乱；多行堆栈未结构化；  采集器与 logrotate 不匹配导致丢失；  生产误开 DEBUG/TRACE 导致成本暴涨；  在业务线程直连日志后端造成阻塞；  标签高基数（Loki/Prometheus 类系统致命）；  未做脱敏，泄露 PII/密钥；  无本地缓冲，网络抖动即丢；无 ILM/TTL 费用失控。迁移与落地步骤  盘点与分层：统一 Schema 与追踪字段，按服务/环境/吞吐/保留需求分层。  PoC：PLG/EFK/ClickHouse 各选一条链路做对比，回放历史日志估算成本与延迟。  渐进式上线：按业务域切流，灰度与采样并行，保留回滚通道。  治理与可视化：建立日志 SLO，Grafana/Kibana 看板与告警；  成本优化：ILM/TTL、热温冷分层、标签治理、对象存储归档。简要结论：统一 JSON Schema 与追踪上下文是基础；stdout（K8s）/文件或 journald（VM）为入口，Agent 端做脱敏与缓冲；强检索选 OpenSearch，性价比选 Loki/ClickHouse，高可靠加 Kafka；OTel 统一日志/链路/指标可显著提升排障效率；生产环境务必控制标签基数、采样与 ILM/TTL，并启用背压与本地缓冲。"
  },

  {
    "url": "/web3/2021/03/12/Web3-%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E5%BA%94%E7%94%A8DApps%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98.html",
    "title": "去中心化应用（DApps）架构实战：钱包、签名与读写分层",
    "content": "在 Web3 语境下，“应用”与传统 Web2 的差异并不只是是否使用区块链，而是信任模型从“平台背书”转向“代码即法律（Code is Law）”与“加密签名即授权”。DApp 的工程化落地，归根结底是围绕三件事：身份与授权（钱包）、状态与规则（智能合约）、读写与观测（RPC/索引器）。本文从体系结构到实战细节，带你搭建一个可上线的 DApp，并覆盖常见错误与运维要点。1. 架构概览与信任边界  前端（dApp）：运行在用户浏览器或移动端，负责连接钱包、发起签名、调用合约、渲染数据；  钱包（Provider/Signer）：保存私钥，EIP-1193 暴露统一接口，EVM 链上用 eth_* JSON-RPC；  合约（EVM Solidity）：在链上保存规则与资产，事件（logs）作为“事实来源”；  后端/索引器：尽量“最小信任”。使用 The Graph/SubQuery/自建 ETL，将事件抽取到可查询存储以供前端检索；  节点与网关：Infura/Alchemy/自建 Geth/Erigon；选择稳定 RPC 与指数退避策略；  可观测与告警：交易成功率、确认时间、事件延迟、钱包连接失败率、RPC 错误码分布。graph LR  UI[dApp Frontend] -- EIP-1193 --&gt; Wallet  Wallet -- sendTx/sign --&gt; Chain[Blockchain]  UI -- read --&gt; RPC  UI -- query --&gt; Indexer[(Indexer/DB)]  Chain -- logs --&gt; Indexer2. 钱包连接与权限模型（EIP-1193/6963）EIP-1193 统一了 Provider 的交互方式，EIP-6963 定义多钱包发现与选择机制。常见流程：1) 发现与连接钱包（请求账户权限）；2) 检查与切换网络；3) 监听账户/网络变化；4) 以签名/交易完成授权。// 探测 Provider（EIP-1193），兼容多钱包import { ethers } from 'ethers'const anyProvider = window.ethereumif (!anyProvider) throw new Error('No wallet provider found')// 请求账户权限（用户会看到弹窗）await anyProvider.request({ method: 'eth_requestAccounts' })const provider = new ethers.BrowserProvider(anyProvider)const signer = await provider.getSigner()console.log('address=', await signer.getAddress())// 监听账户/网络变化anyProvider.on('accountsChanged', (accs)=&gt;{ /* 刷新会话 */ })anyProvider.on('chainChanged', (chainId)=&gt;{ window.location.reload() })网络切换（EIP-3085/3326）：// 若链ID不匹配，引导用户添加并切换await anyProvider.request({  method: 'wallet_addEthereumChain',  params: [{ chainId: '0x1', chainName: 'Ethereum', rpcUrls: ['https://mainnet.infura.io/v3/xxx'], nativeCurrency: {name:'ETH',symbol:'ETH',decimals:18}}]})3. 合约设计与最小可行用例（Solidity）以“白名单凭证 NFT”举例：  功能：允许白名单地址铸造一次；  事件：Minted(address indexed to, uint256 tokenId)；  安全：只读视图函数 whitelisted(address)；  运维：合约版本标识与所有者（多签）。// SPDX-License-Identifier: MITpragma solidity ^0.8.20;import {ERC721} from \"solmate/tokens/ERC721.sol\";import {Owned} from \"solmate/auth/Owned.sol\";contract Voucher is ERC721, Owned {    mapping(address =&gt; bool) public used;    uint256 public nextId;    string public baseURI;    event Minted(address indexed to, uint256 indexed tokenId);    constructor(string memory _name, string memory _symbol, string memory _base) ERC721(_name,_symbol) Owned(msg.sender) {        baseURI = _base;    }    function tokenURI(uint256 id) public view override returns (string memory) {        return string(abi.encodePacked(baseURI, _toString(id), \".json\"));    }    function mint() external {        require(!used[msg.sender], \"used\");        used[msg.sender] = true;        uint256 id = ++nextId;        _safeMint(msg.sender, id);        emit Minted(msg.sender, id);    }}部署（Foundry）：forge create --rpc-url $RPC --private-key $PK src/Voucher.sol:Voucher \\  --constructor-args \"Voucher\" \"VCH\" \"ipfs://CID/\"4. 前端读写分层与索引器  写：调用 mint() 发起交易。需要 Nonce 管理（失败重发）、Gas 估算冗余（+10~20%）、提示用户确认。  读：合约状态（used(addr)、ownerOf）适合实时 RPC；批量列表（最近铸造）用索引器重放事件。// 写：mintconst voucher = new ethers.Contract(addr, abi, signer)const tx = await voucher.mint()const receipt = await tx.wait() // 等待确认，前端显示 Pending/Confirmed// 读：单点查询const used = await voucher.used(address)// 读：通过 subgraph/自建 indexer，// 例如请求 /api/minted?owner=0xabc 返回分页列表索引器方案：  The Graph：声明式子图，快；  自建 ETL：使用 ethers 订阅事件写入 PostgreSQL/ClickHouse，配合 REST/GraphQL 查询；  延迟与一致性：UI 上标注“最新区块高度”，避免用户对数据新鲜度的误解。5. 错误处理与用户体验  交易被用户拒绝：错误码 4001 → 友好提示；  Nonce 过低/冲突：后端给出“替换交易”指导；  Gas 估算失败：提供“手动输入”模式，并提示风险；  网络切换失败：指导手动添加 RPC，或降级到只读模式；  交易 Pending 过久：给出区块浏览器链接；  本地缓存：用 IndexedDB 缓存用户最近交互状态，提升体验。6. 安全清单  签名提示（EIP-4361 SIWE）明确用途，避免“盲签”；  前端不要保存私钥；  合约函数最小暴露，使用 reentrancy guard 与访问控制；  升级与多签：关键参数由多签修改，预留“暂停开关”；  依赖锁定：固定依赖版本，审计后再升级；  漏洞响应：准备紧急流程与白帽通道。7. 部署与运维  环境：Testnet（Sepolia/holesky）→ Mainnet/L2；  RPC：多供应商容灾（Infura/Alchemy/自建），退避+重试；  日志：合约事件/前端错误/链上回执三方对账；  指标：交易成功率、确认时间分布、钱包连接失败率、索引器延迟；  版本回滚：前端通过 CDN 回滚，合约通过“开关+迁移”方案；  风险演练：限流/拥塞/价格飙升场景压测。8. 典型问题与排查  交易总失败：检查链 ID、不足 Gas、Nonce 冲突、RPC 限流；  事件读取不全：索引器区块范围/重组处理、分片并行拉取；  钱包不兼容：提供 WalletConnect 与多 Provider 适配；  L2 差异：确认时间、手续费代币与跨链桥时延。9. 进阶：多链与账户抽象（AA）  多链：统一接口层（如 wagmi/viem），在 UI 与配置层做网络切换；  账户抽象（EIP-4337）：用 UserOperation 替代直接 sendTransaction，可实现“代付手续费”“批量操作”等体验优化。10. 小结一个可上线的 DApp，不只是一两个合约与一个页面，需要“端-链-索引-观测”的闭环设计。以钱包为入口、合约为规则源，辅以稳健的读写分层与索引器，是工程落地的通用路径。持续优化签名提示、错误处理与运维指标，才能支撑从爱好者到大众用户的跃迁。"
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/nginx/2020/09/22/Nginx-%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E4%B8%8E%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E5%AE%9E%E8%B7%B5.html",
    "title": "Nginx 缓存策略与动静分离实践",
    "content": "CDN 前移与边缘缓存固然重要，源站 Nginx 的缓存与动静分离同样关键。本文给出缓存键、缓存层级与缓存失效策略。1. CDN 的概念与原理CDN（Content Delivery Network，内容分发网络）通过在全球各地部署边缘节点，将内容缓存并就近分发给用户，以缩短 RTT、降低回源压力和抖动。其核心机制包括：  路由调度：基于 Anycast、DNS 或 HTTP 重定向，将用户引导到就近/最优节点。  边缘缓存：边缘节点依据源站响应头（如 Cache-Control、Expires、ETag、Last-Modified、Vary、Surrogate-Control、s-maxage 等）决定存储与回源策略。  回源与验证：命中失败或过期后，边缘向源站回源；支持条件请求（If-None-Match/If-Modified-Since）。  失效与刷新：通过 API 触发 URL/PATH/Tag 维度的失效（Soft/Hard Purge），或自然到期。实践上，合理设计缓存层级（浏览器 → CDN 边缘/中间层 → 源站 Nginx）与一致的缓存语义，是稳定与性能的关键。2. 从 Nginx 反向代理角度：职责与作用Nginx 作为源站或中间层反向代理，承担：  协议终止：TLS 终止、HTTP/2/HTTP/3（QUIC），HSTS、安全头治理。  流量治理：限流、熔断、重试、健康检查、连接复用（keepalive）、负载均衡（轮询/一致性哈希）。  路由与动静分离：路径/主机名路由，将静态交给文件系统/对象存储，动态交给应用上游。  缓存与加速：proxy_cache/fastcgi_cache/uwsgi_cache 微缓存，削峰填谷（use_stale/background_update）。  可观测性：接入/上游日志、$upstream_cache_status、自定义头（如 X-Cache-Status）。3. Nginx 缓存原理与类型Nginx 缓存本质是以“缓存键 → 缓存对象（响应头+体）”的 KV 存储，命中由“键一致 + 仍在有效期 + 可用状态”决定。  缓存类型：          proxy_cache：反向代理上游（HTTP）      fastcgi_cache：PHP/FPM 等 FastCGI 应用      uwsgi_cache：uWSGI 协议上游        核心要素：          缓存键：常见构成为 scheme + method + host + uri + args + 关键头/变量，需谨慎纳入 Cookie/User-Agent/Accept-Language/Device 等差异维度，避免过度碎片化。      有效期：proxy_cache_valid（命中后 TTL），与上游头（Cache-Control/Expires）的关系可通过 proxy_ignore_headers、proxy_cache_revalidate on; 调整。      失效策略：自然过期、主动清理（ngx_cache_purge 或重新变更缓存键/版本位）。      抖动优化：proxy_cache_lock（合并并发 miss）、use_stale updating/error（错误/更新期间复用旧值）、proxy_cache_background_update（后台刷新）。      4. 缓存配置示例（微缓存 + 静态长缓存）http {  upstream api_upstream {    server 127.0.0.1:8080;    keepalive 64;  }  proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=api_cache:256m inactive=1d max_size=20g use_temp_path=off;  # 登录/写操作等绕过缓存  map $http_cookie $bypass_cache_cookie { default 0; ~*(session|token|auth) 1; }  map $request_method $bypass_cache_method { default 0; ~^(POST|PUT|PATCH|DELETE)$ 1; }  map \"$bypass_cache_cookie$bypass_cache_method\" $bypass_cache { default 0; \"10\" 1; \"01\" 1; \"11\" 1; }  # 可选：版本位，灰度/全量刷新时提升为新版本（与 CDN Tag/Key 搭配）  # map $http_x_cache_version $cache_version { default \"v1\"; }  server {    listen 443 ssl http2;    server_name www.example.com;    # 与 CDN/前置代理配合的真实 IP 处理（将网段替换为实际 CDN 出口段）    # set_real_ip_from 203.0.113.0/24; real_ip_header X-Forwarded-For; real_ip_recursive on;    # API 微缓存：强削峰、弱一致（1s~3s 级别）    location /api/ {      proxy_pass http://api_upstream;      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header X-Forwarded-Proto $scheme;      proxy_cache api_cache;      proxy_cache_key \"$scheme$request_method$host$request_uri\"; # 可拼入 $cache_version 等变量      proxy_cache_lock on;                 # 合并并发 miss，避免狗群效应      proxy_cache_lock_timeout 5s;      proxy_cache_background_update on;    # 后台刷新      proxy_cache_use_stale error timeout invalid_header updating http_500 http_502 http_503 http_504;      proxy_cache_valid 200 1s;            # 微缓存 TTL（示例）      proxy_cache_valid 301 302 10m;      proxy_cache_valid any 1m;            # 其他状态的保守缓存      proxy_no_cache $bypass_cache;        # 条件下不写入缓存      proxy_cache_bypass $bypass_cache;    # 条件下不读取缓存      add_header X-Cache-Status $upstream_cache_status always;    }    # HTML：短 TTL + s-maxage 交给 CDN，浏览器不持久缓存    location = /index.html {      etag on; if_modified_since exact;      expires -1;      add_header Cache-Control \"public, s-maxage=60, stale-while-revalidate=120, stale-if-error=86400\" always;      add_header Vary \"Accept-Encoding, Accept-Language\" always;      try_files $uri /index.html;    }  }  # 静态域（动静分离）：长缓存 + 指纹命名 + immutable  server {    listen 443 ssl http2;    server_name static.example.com;    root /var/www/static;    location / { try_files $uri =404; }    location ~* \\.(?:css|js|woff2?|ttf|otf|eot|svg|png|jpg|jpeg|gif|ico)$ {      access_log off;      expires 1y;      add_header Cache-Control \"public, max-age=31536000, immutable\" always;    }  }}5. 缓存删除与灰度刷新  源站侧：          ngx_cache_purge：对指定 URL/key 做强制清理（需相应模块/规则）。      版本位切换：将 $cache_version/路径前缀/资源指纹切换到新版本，实现“旧缓存自然淘汰，新缓存即时生效”。      use_stale updating + background_update：对热点内容采用平滑刷新。        CDN 侧：          Tag/Key/路径维度的 API 失效（尽量 Soft Purge + stale-while-revalidate，避免缓存雪崩）。      对 HTML/聚合页先 Soft 后 Hard，控制潮汐效应。      6. CDN 与 Nginx 的协同（通信与对齐）  缓存语义：          浏览器用 max-age/immutable，CDN 用 s-maxage/Surrogate-Control，两者各司其职。      条件请求：启用 ETag/Last-Modified，允许 CDN 及 Nginx 复用 304 验证，减少字节回源。      Vary 对齐：与实际差异维度一致，避免误合并或碎片化；慎用 Vary: Cookie（更推荐在 CDN 端剥离无关 Cookie）。        连接/身份：          透传链路：X-Forwarded-For、X-Forwarded-Proto，并在源站恢复真实 IP（set_real_ip_from）。      观测头：统一 X-Cache（CDN）、X-Origin-Cache（Nginx）等便于排障。        回源与削峰：          CDN 打开 Collapsed Forwarding/Origin Shield；Nginx 打开 proxy_cache_lock/use_stale，双层合并并发 miss。      7. 动静分离最佳实践  域名分离：www.example.com（动态/HTML 短缓存）与 static.example.com（静态资源长缓存）分域，便于策略与权限隔离。  指纹命名：静态资产使用内容哈希（如 app.&lt;hash&gt;.js），配合 Cache-Control: immutable 与 1 年 TTL。  HTML/接口：          HTML 由 CDN 短 TTL + stale-while-revalidate，源站可微缓存 1s~3s 抗尖峰。      API GET 可微缓存；写操作/登录态通过 Cookie/Method 映射绕过缓存。        资源下沉：将图片/视频等大文件迁移至对象存储 + CDN 边缘，Nginx 只做签名鉴权与 302 跳转（或代理带范围请求）。  压缩与协议：开启 brotli/gzip（二选一优先 brotli），启用 HTTP/2/3，合理的 TLS 会话复用与 OCSP Stapling。8. 注意事项（坑点清单）  语义不一致：源站与 CDN 的 Cache-Control 冲突，导致双层缓存不可控；确保 s-maxage 与 max-age 区分清晰。  过度 Vary：将 Cookie、User-Agent 直接纳入键导致碎片化；优先在 CDN 端规整头部/剥离无关 Cookie。  个性化内容被缓存：涉及用户态/地域/AB 实验的页面需加 private, no-store 或显式绕过。  重复压缩：CDN 与源站同开 gzip/brotli 可能叠加问题；只保留一处压缩（通常边缘）。  清缓存风暴：大规模 Hard Purge 触发回源雪崩；优先 Soft + stale-while-revalidate，并打开合并回源。  Range 与视频：确认 CDN 与源站均支持 Range；Nginx 需 aio on; directio 等以优化大文件。  真 IP 获取：补全 CDN 出口网段至 set_real_ip_from，否则访问日志皆为边缘 IP。9. 排错清单（最小化工具）  响应头核对：curl -I https://www.example.com/ | sed -n '1,200p'，检查 Cache-Control、Age、ETag、Vary、X-Cache、X-Cache-Status。  分层命中：分别查看 CDN 命中（X-Cache: HIT）与 Nginx 命中（X-Cache-Status: HIT）。  条件请求：If-None-Match/If-Modified-Since 是否 304；如无 ETag，考虑在 HTML/静态启用 etag on;。  键确认：临时把 proxy_cache_key 响应回显到头部以核对（调试时用，勿在生产保留）。10. 小结合理的“浏览器 → CDN → 源站 Nginx”三层缓存设计，配合动静分离与微缓存，可同时获得低时延、高吞吐与稳定性。关键在于：一致的缓存语义、谨慎的缓存键设计、可控的失效策略，以及双层削峰机制的配合。"
  },

  {
    "url": "/web3/2020/08/19/Web3-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%A0%88.html",
    "title": "Web3 的链上基础：共识、状态机与扩容栈",
    "content": "区块链是“可验证状态机复制”（Replicated State Machine）。要把 DApp 做稳，必须理解状态如何被转换、共识如何达成、数据如何被持久化与对外可读。本文从状态机、共识、存储与扩容（L2/DA）出发，构建一条可实践的技术路径，并附带节点与索引的工程建议。1. 状态机与区块  交易（Tx）是对状态的变更请求；  区块是时间窗口内的交易集合；  状态机：state_{n+1} = transition(state_n, block_txs)，其中 transition 由虚拟机（EVM/WASM）与合约逻辑决定；  真实性：通过 Merkle/Patricia Trie/Verkle commitment，为状态/交易/收据生成可校验根。2. 共识算法与容错  PoW：算力竞争，安全性来源于经济成本与难度调节；  PoS：权益质押 + 随机选举/委员会 BFT；  BFT 家族（Tendermint/HotStuff）：低延迟、确定性最终性，容忍 f 个拜占庭节点需总数 ≥ 3f+1；  最终性（Finality）：概率型（PoW） vs. 确定性（BFT/PoS 的检查点最终性）；  安全-去中心化-性能“铁三角”权衡。3. 存储与索引  账户/存储：以太坊账户模型、合约存储槽；  索引：事件（logs）作为可订阅变更源；  历史访问：归档节点（Erigon）与快照；  自建索引：消息队列 + ETL（ClickHouse/PostgreSQL），支持分页、聚合与时间序列；  校对：按区块高度对账，处理链重组（reorg）。4. 扩容：Layer2 与数据可用性（DA）  Rollup：Optimistic（欺诈证明）与 ZK（有效性证明）；  Validium：链下数据可用性，吞吐更高但信任更强；  DA 层：Celestia/EigenDA 作为数据发布层，L2 提交证明到 L1；  桥接安全：原生桥/轻客户端桥/流动性桥的风险比较。5. 读写路径与最终一致  写：tx -&gt; mempool -&gt; proposer -&gt; block -&gt; consensus；  读：RPC（视图函数） + 索引器（事件订阅）；  一致性：UI 上呈现“确认数/最终性状态”，避免用户误解；  重组处理：短暂回滚时，索引器需要撤销并重放受影响区块。6. 节点与网络  客户端：Geth/Nethermind/Erigon；  RPC 网关：Infura/Alchemy/self-hosted Nginx 负载；  P2P：节点发现、区块/交易传播；  指标与日志：区块延迟、孤块率、重组率、peer 数量；  安全：私钥隔离、远程签名（HSM/Signer）。7. 工程与运维建议  多供应商 RPC 容灾，指数退避与幂等机制；  节点同步：快速同步/快照/检查点；  资源：IO/CPU/网络的均衡，SSD 与队列深度；  压测：fork 主网、回放真实负载；  成本：根据读写比例选择 L2/缓存/索引器策略。8. 代码与命令片段  使用 ethers.js 订阅事件并写入数据库：    const provider = new ethers.JsonRpcProvider(RPC)const iface = new ethers.Interface(abi)provider.on({ address: CONTRACT, topics: [iface.getEventTopic('Transfer')] }, (log)=&gt;{const evt = iface.decodeEventLog('Transfer', log.data, log.topics)// 写入数据库，带 blockNumber/txHash，便于去重与回滚})        Geth 启动与快照：    geth --http --http.api eth,net,web3 --syncmode snap --datadir /data/geth        Erigon 归档节点（示）：    erigon --chain mainnet --http --http.api=eth,debug,net,web3 --datadir /data/erigon      9. 小结链上是“慢且稳”的全局真相，链下是“快且灵活”的读取与分析。将状态转换、共识与数据可用性理解清楚，配合合理的索引与缓存，才能在可用性与可信度之间取得平衡。选择成熟 L1 + 合适 L2，减少自研链的复杂性，是当下工程落地的主路径。"
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/mysql/2020/07/19/MySQL-%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%9B%9E%E8%A1%A8%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html",
    "title": "MySQL 索引设计与回表优化实战",
    "content": "索引，是 MySQL 性能工程的地基。设计得当，查询如行云流水；设计不当，慢查询、锁等待、CPU 飙高全都找上门。本文在原“回表优化实战”的基础上，系统扩展到索引必要性、InnoDB B+ 树底层原理、索引大小对性能的影响、工程化建索引方法论与排障清单，给出一套可直接落地的完整方案。1. 为什么需要索引：必要性与代价的平衡没有索引时，只能全表扫描，I/O 与 CPU 成本随数据量线性增长。索引将“查找”从 O(N) 降为 O(log_f N)，其中 f 为 B+ 树扇出（可达数百至上千），并提供有序访问能力，显著优化范围扫描、排序与分组。同时必须正视代价：  写放大：DML 需要维护主键与二级索引，伴随页分裂/合并；  存储膨胀：索引页占用 Buffer Pool，命中率受影响；  计划风险：索引过多/质量差会让优化器选择困难，出现计划抖动。结论：索引不是越多越好，而是“必要且刚好”。2. 底层原理：为什么是 B+ 树？InnoDB 采用 B+ 树组织数据与索引（聚簇索引与二级索引），核心动机：  磁盘/页友好：节点存大量键指针，扇出大、树高低（亿级数据常 3~4 层）；  顺序扫描：叶子节点双向链表，天然支持范围/排序；  缓存友好：热路径节点易命中 Buffer Pool；  对比哈希/红黑树：B+ 树既支持范围/排序，又以页为单位贴合块设备。两个关键事实：  聚簇索引叶子存整行，主键既是逻辑主键也是物理组织；  二级索引叶子为“索引键 + 主键”，因此二级索引命中后常需“回表”。这解释了覆盖索引为何能避免回表：当查询列全被索引覆盖时，无需回到聚簇索引取整行。3. 索引大小如何影响性能1) 树高与扇出：键越短、记录越小，扇出越大、树高越低；树高每 +1，未命中缓存时多一次随机 I/O，P95/99 延迟明显上升。2) 缓存命中与热点：索引越小，更多页常驻 Buffer Pool，随机 I/O 更少；大索引会稀释缓存，导致更频繁的落盘访问。3) 写放大与碎片：宽主键（如 UUID v4 文本）插入随机，页分裂与碎片更多；宽二级索引（长字符串/多列组合）放大维护成本。工程启示：  控制主键宽度，倾向递增或准递增（BIGINT 雪花、UUID v7/Binary(16)）；  长字符串用前缀索引或生成列（表达式持久化/CRC32）缩小叶子记录；  复合索引列顺序以短且高选择度列在前，降低树高。4. 设计方法论：如何系统化建索引4.1 读路径画像与选择度把 80% 关键查询归类为：点查、范围、排序、分组、Top-N、Join。逐条识别过滤列、排序/分组列、返回列与基数（选择度）。4.2 等值-范围-排序的列序复合索引常见顺序：等值列 → 范围列 → 排序/分组列。-- 典型 OLTP 列表页CREATE INDEX idx_u_s_ctid ON orders(user_id, status, created_at, id);-- WHERE user_id=? AND status=? AND created_at BETWEEN ... ORDER BY id LIMIT N注意：范围列之后的排序是否生效，取决于范围收敛与索引序可用性，否则仍可能 filesort。4.3 覆盖索引优先，尽量避免回表将 SELECT 所需列合入索引尾部，形成覆盖（Extra: Using index）。  列表页热点读优先覆盖；  谨慎控制索引宽度，避免为覆盖无限扩列；  搭配 LIMIT 收敛候选集。4.4 索引下推（ICP）与条件重写MySQL 5.6+ 支持 Index Condition Pushdown，在索引层预过滤，减少回表。  避免在索引列上包裹函数/隐式类型转换；  用生成列持久化表达式并建函数索引：ALTER TABLE t  ADD COLUMN created_date DATE GENERATED ALWAYS AS (DATE(created_at)) STORED,  ADD INDEX idx_created_date(created_date);4.5 低选择度列的处理将低选择度枚举（性别/状态）与高选择度列（租户/用户/时间）复合，提升过滤效率。4.6 排序/分组利用索引序  让 ORDER BY 列与 WHERE 等值列共用一个索引，避免外部排序；  GROUP BY 尝试松散索引扫描（loose index scan），在可跳跃场景显著降低代价。4.7 JOIN 场景  驱动表选高过滤性；  被驱动表在 Join key 建索引，保证 Nested Loop 点查高效；  Join + Order 时，考虑“Join key + 排序列”复合。4.8 反模式速查  LIKE '%kw%' 不走前缀索引：考虑反向索引、ngram、全文索引；  表达式在列外：WHERE DATE(ts)=...、col+1=... 阻断索引；  隐式转换：字符串列与数值比较触发转换，索引失效；  8.0 混合排序：按需指定 ASC/DESC，避免额外排序。5. 回表优化：理解并减少回表代价在于额外随机 I/O 与潜在锁冲突。1) 覆盖索引优先：尽可能避免回表。2) 限制回表次数：  提升过滤收敛；  ICP 在索引层筛除不匹配；  Top-N 列表减少 LIMIT，利用更强 WHERE。3) 利用主键有序性：  让二级索引输出的主键更“聚集”（时间段/自增 ID），减少跨页跳转；  使用 seek 分页替代深 OFFSET，避免无效回表。-- 基于主键的延续分页SELECT cols FROM t FORCE INDEX(idx_a_created_id)WHERE a=? AND (created_at,id) &gt; (?,?)ORDER BY created_at,idLIMIT 50;4) 特殊手段：  热点路径物化/汇总表，用写放大换读性能；  使用外部缓存兜热点主键查；  JSON/表达式查询用生成列 + 函数索引减少“索引参与度低”的回表。6. 主键设计：影响一切的根基  宽度：尽量短（BIGINT 优于 UUID v4 文本）；必要时用 BINARY(16) 或 UUID v7；  递增性：递增/准递增减少页分裂、提升局部性；  业务含义：避免在主键编码复杂业务语义，后期变更代价高。7. 统计与优化器：让选择更聪明  ANALYZE TABLE 刷新统计，保证基数估计；  8.0 直方图（CREATE HISTOGRAM）改善倾斜分布估计；  持久统计（innodb_stats_persistent=ON）减少重启抖动；  不可见索引（Invisible Index）灰度验证，新索引先不可见，验证后再切换可见。CREATE INDEX idx_demo ON t(col1,col2) INVISIBLE;ALTER TABLE t ALTER INDEX idx_demo VISIBLE;8. 实战建索引流程（可执行清单）1) 收集与分群：  慢日志、Top SQL（performance_schema / sys）；  按 DIGEST 聚类，统计 QPS、P95/P99、Rows Examined。2) 设计与评审：  为每类查询提出 1~2 个候选复合索引；  检查“等值→范围→排序/分组”、是否可覆盖；  评估索引宽度、写放大、与现有索引冗余关系。3) 预演与验证：  影子环境回放真实流量；  用 EXPLAIN ANALYZE 对比访问类型、rows/filtered、Extra；  评估 CPU/I-O/延迟改善与副作用。4) 渐进上线：  不可见索引或分批实例灰度；  观察计划回归、锁等待、写延迟；  冗余索引及时下线，保持索引集简洁。9. DDL 模板与技巧-- 1) 复合 + 覆盖：等值-范围-排序CREATE INDEX idx_a_b_c_id ON t(a, b, c, id);-- 2) 前缀索引：控制宽列大小（留意选择度与碰撞）CREATE INDEX idx_email_prefix ON users(email(16));-- 3) 生成列 + 函数索引：避免表达式阻断索引ALTER TABLE users  ADD COLUMN email_lc VARCHAR(255) GENERATED ALWAYS AS (LOWER(email)) STORED,  ADD INDEX idx_email_lc(email_lc);-- 4) 混合排序（8.0+）：与业务排序一致CREATE INDEX idx_city_score ON shop(city_id ASC, score DESC, id ASC);-- 5) JSON 多值索引（8.0.17+）ALTER TABLE doc ADD INDEX idx_tags(tags) COMMENT 'MVI on JSON array';-- WHERE JSON_CONTAINS(tags, '\"ai\"', '$')-- 6) 不可见索引灰度CREATE INDEX idx_hot ON t(a,b,c) INVISIBLE;ALTER TABLE t ALTER INDEX idx_hot VISIBLE;10. 监控与排障：发现“坏索引/缺索引”  慢日志：Rows_examined 远大于返回行；  performance_schema/sys：按 DIGEST 聚合最高延迟/扫描行；  EXPLAIN ANALYZE 指标：          type=ALL：全表扫；      key=NULL：未命中索引；      rows ≫ 返回行：回表/过滤浪费；      Extra 含 Using filesort/Using temporary：排序/分组未利用索引序；        InnoDB：Buffer Pool 命中率、页分裂率、history list length（长事务影响 purge 与统计）。11. 常见问答与取舍  外键列要不要建索引？建议要。否则外键检查/级联会加大锁范围与阻塞。  INDEX MERGE 能替代复合索引吗？不建议依赖。常需临时合并，CPU 与内存代价高。  宽文本如何索引？前缀 + 覆盖或生成列，全文检索需求引入专用引擎更合适。  是否删除“看似无用”的索引？先做不可见灰度并跨报表/离线窗口观察，避免尖峰慢查。12. 经典案例回顾（结合回表优化）问题：SELECT id FROM t WHERE a = ? AND b &gt; ? ORDER BY c LIMIT 20 filesort + 回表严重。方案：CREATE INDEX idx_a_b_c_id ON t(a, b, c, id);EXPLAIN SELECT id FROM t WHERE a = 1 AND b &gt; 10 ORDER BY c LIMIT 20; -- Extra: Using index要点：  等值 a 在前、范围 b 其后、排序 c 与主键 id 形成覆盖；  若范围过宽导致排序失效，缩小 b 的范围或改以 (a,c,id) 兜底并增加 WHERE 收敛；  LIMIT 收敛候选集，减少回表数量。13. SQL 排查脚本（保留与扩展）-- Top 慢 SQL 家族SELECT * FROM performance_schema.events_statements_summary_by_digest WHERE DIGEST_TEXT LIKE 'SELECT%FROM t%'ORDER BY AVG_TIMER_WAIT DESC LIMIT 20;14. 总结：可落地的准则  以查询为中心：有读路径画像，后有索引方案；  等值→范围→排序/分组组织复合索引，热点读优先覆盖；  控制索引大小：短主键、前缀/生成列、谨慎扩列；  减少回表：覆盖索引 + ICP + seek 分页；  喂饱优化器：直方图、持久统计、定期 ANALYZE；  灰度为先：不可见索引/影子环境验证；  持续治理：监控—评审—精简的闭环。"
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/java/2019/12/14/Java-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98-%E4%BB%8EG1%E5%88%B0ZGC.html",
    "title": "Java 垃圾回收调优：从 G1 到 ZGC",
    "content": "延迟敏感系统如何选择 GC？如何系统地读懂 GC 日志并做出有效调优？本文从 JVM 基础、STW 机制、垃圾回收算法、收集器演进到实战调优，给出可落地的方法与示例。1. JVM 内存模型与 STW/Safepoint 基础在 HotSpot 下，内存大体分为：  Java 堆（年轻代/老年代，G1/ZGC 采用 Region/分页结构）  线程栈（每线程独立）  元空间（Metaspace，用于类元数据）  本地内存（如直接缓冲区、JIT 代码缓存等）两个重要的分配/复制概念：  TLAB（Thread-Local Allocation Buffer）：线程本地的堆分配缓冲，减少分配锁竞争。  PLAB（Parallel/Promotion LAB）：年轻代向老年代晋升时的并行复制缓冲。Stop-The-World（STW）是 GC 暂停所有 Java 线程的时刻。JVM 通过 Safepoint 实现可停位置控制（比如方法调用边界、循环回边、异常处理器等），在进入关键阶段（如初始标记、重新标记、对象移动/重定位）时触发短暂停顿。理解 STW 有助于判断“为什么延迟尖刺发生在这个阶段”。观测 STW 的现代方式（JDK9+）：java -Xlog:safepoint,classhisto*=off:file=safepoints.log:tags,uptime -Xlog:gc*:file=gc.log:time,uptime,level,tags ...关键指标：暂停时长（p95/p99/p999）、分配速率、晋升速率、RSet 扫描成本、引用处理（Reference Processing）、类卸载、字符串去重等耗时分布。2. 垃圾回收算法与屏障技术HotSpot 基础算法与实现要点：  可达性分析：从 GC Roots（线程栈、静态引用、JNI 句柄等）做遍历。  三色标记（白/灰/黑）+ 写屏障/读屏障：保证并发标记/移动时的正确性。  标记-清除（Mark-Sweep）：快，但会产生碎片。  标记-整理（Mark-Compact）：消除碎片，但需要对象移动（常伴随 STW 或并发移动）。  复制（Copying）：典型用于年轻代（Eden→Survivor），快且局部性好。  分代假说：大多数对象“朝生夕死”，少数对象“越活越老”。引用语义（强/软/弱/虚）与终结（finalize/Cleaner）在 GC 中有独立处理阶段。引用处理过重时常见“长尾暂停”，建议：避免 Finalizer、使用 java.lang.ref.Cleaner 并限制队列堆积。3. 收集器演进路线  Serial/Parallel（Throughput 收集器）          关注吞吐，允许较长 STW；适合批处理、计算密集型、少交互的服务。      关键项：-XX:+UseParallelGC、-XX:ParallelGCThreads、-XX:NewRatio。        CMS（Concurrent Mark Sweep）          并发标记，降低暂停，但有碎片与“Concurrent Mode Failure”。      JDK9 起废弃，JDK14 移除。仅在历史系统中遇到，不建议新项目使用。        G1（Garbage-First）          基于 Region 的分代收集器。分为 Young、Concurrent Marking、Mixed 周期，按收益选择回收集（Collections Set）。      关键概念：Region（含 Humongous 大对象）、RSet/卡表（Remembered Set）、IHOP（Initiating Heap Occupancy Percent）。      优点：更可预测的暂停目标；可并发标记与分阶段回收。      常见瓶颈：RSet 扫描（卡表爆炸）、Humongous 对象回收不及时、Evacuation Failure（to-space/exhausted）。        Shenandoah（Red Hat）与 ZGC（Oracle）          共同目标：并发压缩/移动，极低暂停（亚毫秒到个位数毫秒级）。      屏障差异：Shenandoah 使用 Brooks Pointer + 写屏障；ZGC 使用“有色指针（Colored Pointers）”+ 读屏障，配合多阶段重标记/重定位。      ZGC 建议 JDK17+，JDK21 起支持分代 ZGC（-XX:+ZGenerational）。      4. 选择收集器的思路  吞吐优先（批处理/离线计算）：Parallel GC。  延迟优先（在线服务/交易系统）：G1（JDK11+），更高要求可选 ZGC（JDK17+/21+）。  小堆（&lt;4G）且并发不高：G1 也能给出稳定暂停；ZGC 在极小堆下优势不明显。5. 调优方法论（可落地流程）1) 设定 SLO：如 p99 暂停 &lt; 200ms，或 CPU/吞吐目标。2) 固定运行基线：容器/宿主 CPU/NUMA/THP 设置、JDK 版本、-Xms = -Xmx、-XX:+AlwaysPreTouch。3) 打开观测：GC/JFR/应用指标。java \\  -Xms8g -Xmx8g -XX:+AlwaysPreTouch \\  -Xlog:gc*,safepoint:file=gc.log:time,uptime,level,tags \\  -XX:ActiveProcessorCount=8   # 容器 CPU 配额感知（必要时）4) 建立压测基线：记录分配速率（Allocation Rate）、晋升速率（Promotion Rate）、混合回收频次、Humongous 分配率、RSet 扫描耗时。5) 定位瓶颈：  暂停超标多数发生在 Initial-Mark/Remark？→ 检查引用处理/类卸载/卡表维护。  Mixed 过于频繁？→ IHOP 偏低或老年代增长过快。  Evacuation Failure？→ to-space 不足，Region 预留或对象过大。6) 逐步调整参数与代码，单一变量、对比压测，保留实验记录。6. G1 实战参数与解释常用启动模板（JDK11+/17+）：java \\  -XX:+UseG1GC \\  -Xms8g -Xmx8g \\  -XX:MaxGCPauseMillis=200 \\  -XX:InitiatingHeapOccupancyPercent=45 \\  -XX:G1ReservePercent=20 \\  -XX:G1HeapRegionSize=4m \\  -XX:G1NewSizePercent=20 -XX:G1MaxNewSizePercent=40 \\  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=8 \\  -XX:+ParallelRefProcEnabled \\  -XX:+UseStringDeduplication \\  -Xlog:gc*,gc+heap=debug,gc+age=trace:file=gc.log:time,uptime,level,tags调参要点：  MaxGCPauseMillis：目标暂停时间。过低会引发更频繁 GC 与更重的并发负担。  IHOP：老年代占用触发并发标记阈值。负载有爆发时可调高（如 45→55），减少并发标记重叠时间。  G1ReservePercent：预留 to-space，减少 Evacuation Failure 风险。  G1HeapRegionSize：Region 大小影响 Humongous 阈值（&gt; 50% Region 即为 Humongous）。对象略大时可适当增大 Region，减少 Humongous 分配。  新生代比例与晋升阈值：平衡吞吐与老年代压力，避免 Survivor 放不下导致早晋升。常见告警与应对：  Mixed 过密：上调 IHOP、降低 G1MixedGCLiveThresholdPercent、限制 G1MixedGCCountTarget。  Evacuation Failure（to-space exhausted）：增大堆/预留比例、减少大对象、错峰分配高峰。  RSet 过大：排查跨区大量写入热点（缓存结构、共享对象），优化对象图或拆分。7. ZGC 实战参数与解释（JDK17+/21+）java \\  -XX:+UseZGC \\  -Xms8g -Xmx8g \\  -XX:ConcGCThreads=2 \\  -XX:ZUncommitDelay=300 \\  -Xlog:gc*,safepoint:file=gc.log:time,uptime,level,tags要点：  ZGC 通过读屏障与有色指针实现并发移动，对暂停极其敏感的在线业务非常友好。  内存回收的“拆借/归还”速度与分配速率密切相关。ZUncommitDelay 可控制未使用页面的回退时机。  JDK21+: -XX:+ZGenerational 以降低短命对象对并发标记的干扰（分代 ZGC）。何时不必用 ZGC：小堆、高分配峰值但暂停目标在百毫秒级时，G1 往往足够且更易调参。8. GC 日志快速解读示例（G1）[3.456s][info][gc,start     ] GC(12) Pause Young (Normal) (G1 Evacuation Pause)[3.456s][info][gc,heap      ] GC(12) Eden regions: 24-&gt;0(20)[3.456s][info][gc,heap      ] GC(12) Survivor regions: 3-&gt;4[3.456s][info][gc,heap      ] GC(12) Old regions: 120-&gt;123[3.460s][info][gc,phases    ] GC(12) Evacuate Collection Set: 3.2ms[3.462s][info][gc           ] GC(12) Pause Young (Normal) (G1 Evacuation Pause) 512M-&gt;498M(8G) 6.1ms关注点：  暂停类型（Young/Mixed）、暂停时长、堆前后使用、Region 变化。  Evacuation 耗时是否成为主因；Old 增长是否过快（晋升压力）。更多细节可打开 gc+age=trace 观察对象年龄分布，辅助设置 MaxTenuringThreshold。9. 代码层面的可操作优化  降低短命对象创建：复用 StringBuilder/ByteArrayOutputStream、批量处理、避免无谓装箱/拆箱与流式中间对象。  控制大对象：避免一次性构造超大 byte[]/String，对网络/IO 使用分片与缓冲；必要时改用直接内存并限制 -XX:MaxDirectMemorySize。  减少跨代/跨区写入：将热点可变状态下沉到局部，避免共享大图结构被频繁修改导致卡表膨胀。  善用 ThreadLocal 存放临时缓冲（谨防线程池泄漏，务必清理）。  让逃逸分析生效：内联/标量替换通常受益于“简单可分析”的代码路径（避免过度反射、动态代理链）。10. 两个简短实战案例  案例 A：在线 API（G1，8C/16G）          目标：p99 暂停 &lt; 200ms；现状：Mixed 频繁、p99 380ms。      调整：IHOP 45→55，G1ReservePercent 10→20，限制 Humongous（将 2.5MiB 的 JSON 拼接拆分为流式写出）。      结果：Mixed 降 35%，p99 降至 160ms。        案例 B：低延迟撮合（ZGC，16C/32G）          目标：单次暂停 &lt; 10ms；现状：G1 在 Remark 尖刺 30ms。      迁移 ZGC 并控制直接内存峰值，JDK17→21 开启 -XX:+ZGenerational。      结果：暂停 p99 约 1.2ms，尖刺消失；同时注意到读屏障开销，CPU 略增 4%。      11. 生产部署与容器注意事项  固定堆并预触达：-Xms = -Xmx、-XX:+AlwaysPreTouch，减少缺页与首次触达抖动。  容器配额：JDK8u191+ 或 JDK10+ 对 cgroup 友好；必要时 -XX:ActiveProcessorCount 显式指定。JDK8 老版本需 -XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap。  关闭透明大页（THP）、合理设置 NUMA（大型物理机）。  日志与剖析：GC 日志、JFR（-XX:StartFlightRecording=...）、async-profiler 定位分配热点。12. 快速“配方卡”  吞吐优先：          -XX:+UseParallelGC -Xms16g -Xmx16g -XX:ParallelGCThreads=&lt;cpu&gt;        稳定低延迟（通用在线服务）：          -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:InitiatingHeapOccupancyPercent=45 -XX:G1ReservePercent=20        极低暂停：          -XX:+UseZGC [-XX:+ZGenerational] -Xms/-Xmx 固定      13. 参考命令与工具# 统一 GC 日志（JDK9+）java -Xlog:gc*,gc+heap=debug,gc+age=trace:file=gc.log:time,uptime,level,tags ...# 在线触发与诊断jcmd &lt;pid&gt; GC.runjcmd &lt;pid&gt; GC.heap_infojcmd &lt;pid&gt; VM.uptime# 快速观测分配/晋升（JDK8 仍常用）jstat -gcutil &lt;pid&gt; 1000 20 | cat如果要把一件事做对：先测量，再改变。GC 调优亦然。优先明确 SLO 与约束，打开观测，建立基线，然后用一两条假设驱动的改动去验证。让数据告诉你应该选 Parallel、G1 还是 ZGC。"
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/mysql/2019/08/02/MySQL-Online-DDL%E6%9C%BA%E5%88%B6%E5%AF%BC%E8%87%B4Duplicate-entry%E9%94%99%E8%AF%AF.html",
    "title": "MySQL Online DDL机制导致",
    "content": "MySQL Online DDL机制导致”Duplicate entry”错误的分析问题场景精准定位您描述的场景非常典型：  手机号字段早已存在唯一索引  原表中该手机号记录早已存在（”很早以前就存在数据库中”）  应用程序正确使用INSERT ... ON DUPLICATE KEY UPDATE  问题发生在执行非唯一索引相关的DDL操作时（如修改其他字段）这正是阿里云文档中提到的第三种场景：”使用结构设计功能进行不涉及唯一约束或唯一索引组成字段调整的DDL操作”时出现的冲突。核心问题：Online DDL的row log重放机制1. MySQL Online DDL执行流程（关键阶段）当执行一个不涉及唯一索引的DDL操作（如修改其他字段）时，MySQL的Online DDL流程如下：T0: 开始DDL，创建中间表(#sql-ibxxx)T1: 将原表数据复制到中间表（此时中间表已包含phone='xxxxx'）T2: 开始记录DML变更到row logT3: 应用程序执行INSERT ... ON DUPLICATE KEY UPDATET4: 将row log中的变更应用到中间表T5: 原子替换原表与中间表2. 问题发生的精确技术原因关键点：row log记录的是原始SQL操作，而非实际执行的操作当应用程序执行：INSERT INTO users(phone, name) VALUES('xxxxx', '张三') ON DUPLICATE KEY UPDATE name = '张三';MySQL的处理流程：  检测到唯一键冲突（phone=’xxxxx’已存在）  将INSERT操作内部转换为UPDATE操作  执行UPDATE，成功完成但是，在Online DDL过程中：  MySQL的row log只记录原始SQL语句（INSERT…）  不记录MySQL内部将其转换为UPDATE的事实  当重放row log到中间表时，MySQL会直接执行原始的INSERT语句3. 冲突发生的具体时间线T0: 开始DDL，创建中间表T1: 中间表从原表复制数据（已包含phone='xxxxx'）T2: 开始记录row logT3: 应用程序执行INSERT ... ON DUPLICATE KEY UPDATE    - 原表：检测到冲突，自动转为UPDATE，成功    - row log记录：INSERT INTO ... VALUES('xxxxx', ...)T4: DDL尝试将row log应用到中间表    - 中间表：已从T1复制拥有phone='xxxxx'的记录    - 执行INSERT操作 → 触发Duplicate entry错误T5: DDL操作失败为什么INSERT … ON DUPLICATE KEY UPDATE在这种场景下失效？1. 执行环境差异            环境      处理方式      结果                  正常执行环境      MySQL解析并执行完整SQL，识别ON DUPLICATE子句      INSERT转为UPDATE，无错误              Online DDL row log重放      仅执行row log中记录的原始INSERT语句      直接尝试插入，忽略ON DUPLICATE逻辑      2. 技术本质：row log的局限性MySQL的row log机制设计用于高效记录和重放DML操作，但有重要限制：  只记录物理操作，不记录SQL语义  不保存执行上下文（如唯一键检查结果）  不考虑约束触发的隐式操作转换当MySQL执行INSERT ... ON DUPLICATE KEY UPDATE时，这是一个逻辑操作，会被转换为物理操作（UPDATE）。但row log只记录了最初的逻辑操作（INSERT），没有记录最终的物理操作（UPDATE）。3. 中间表状态与原表状态的差异在T1到T4期间，原表和中间表的状态可能不同步：  原表：通过ON DUPLICATE KEY机制成功处理了冲突  中间表：没有机会执行相同的逻辑转换  当直接应用原始INSERT时，中间表严格检查唯一约束，导致失败MySQL底层源码级分析在MySQL源码中，这一问题的根源在于：  sql/ha_innobase.cc中的row_log_apply函数：          处理row log重放时，直接执行记录的原始操作      不会重新解析SQL或应用任何约束转换逻辑        sql/sql_insert.cc中的mysql_insert函数：          在正常执行路径中，会调用handle_duplicates处理唯一键冲突      但在row log重放路径中，绕过了这一逻辑        row/row0log.cc中的row log机制：          仅记录最基础的行变更（INSERT/UPDATE/DELETE）      不记录高级SQL语句的语义信息      为什么高并发会加剧这个问题？  row log积压：高并发下，T1到T4之间会产生大量DML操作，row log变大  状态差异扩大：原表与中间表的状态差异随时间推移而增大  重放复杂度增加：更多操作需要重放，冲突概率呈指数级增长解决方案的技术本质1. 根本原因  MySQL Online DDL的row log机制无法正确处理ON DUPLICATE KEY语句  row log记录的是原始SQL，而非实际执行的物理操作2. 有效解决方案方案A：避免在业务高峰期执行DDL  选择低峰期执行DDL操作，减少row log积压  降低原表与中间表状态差异方案B：使用LOCK=EXCLUSIVEALTER TABLE users MODIFY COLUMN age INT COMMENT '年龄' LOCK=EXCLUSIVE;  完全阻塞DML操作，确保数据一致性  代价：DDL执行期间表不可写方案C：分阶段执行（最佳实践）  先添加新列（不修改原列）  应用程序双写新旧列  数据迁移完成后，再删除旧列          避免长时间Online DDL操作      减少冲突窗口期      3. 为什么”先查询再插入”无效？即使应用程序改为：SELECT * FROM users WHERE phone='xxxxx';-- 如果存在则UPDATE，否则INSERT在Online DDL期间：  SELECT可能在T1前执行，看到记录存在  但INSERT/UPDATE操作在T2后执行  row log重放时仍会尝试插入已存在的记录结论      技术本质：MySQL Online DDL的row log机制无法正确处理INSERT ... ON DUPLICATE KEY UPDATE语句，因为它只记录原始INSERT语句，不记录MySQL内部将其转换为UPDATE的事实。        问题根源：当row log中的原始INSERT语句被应用到中间表时，中间表已通过数据复制拥有相同唯一键的记录，导致严格唯一性检查失败。        这不是应用程序错误：即使应用程序正确使用了ON DUPLICATE KEY，在Online DDL过程中仍会失败，这是MySQL底层机制的限制。        解决方案：避免在高并发期间执行DDL操作，或使用LOCK=EXCLUSIVE强制串行化，或采用分阶段变更策略。  "
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/golang/2019/04/18/Go-%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html",
    "title": "Go 内存逃逸与性能优化",
    "content": "当我们谈「性能优化」时，内存管理几乎绕不开。Go 的自动内存管理（GC）为开发效率带来极大提升，但如果不理解「内存逃逸（Escape to heap）」的成因与代价，很容易在高并发与低时延场景中踩到性能坑。本文将从跨语言视角解释什么是内存逃逸、为什么会发生，进而深入 Go 编译器的逃逸分析机制与常见触发场景，最后从编码规范与并发实践两个维度，系统性地给出可落地的性能优化方法与检查清单。什么是内存逃逸（跨语言视角）直觉上，函数内创建的局部变量应当位于栈上，随着函数返回被回收；而当变量「逃离」了其创建点的栈帧生命周期，就必须被分配到堆上，由 GC 统一回收，这就是「内存逃逸」。  在 C/C++ 中，没有 GC 的语境里很少使用「逃逸」一词，但同样存在「对象是否必须在堆上分配」这个问题：例如 new 分配的对象需要显式 delete，而局部对象则在栈上自动销毁。现代 C++（尤其是返回值优化、移动语义）会尽可能消除不必要的堆分配。  在 Java/JVM 中，JIT 会做逃逸分析：若对象不逃出方法，则可进行「栈上分配」与「标量替换」，显著减少 GC 压力。  在 Rust 中，是否在堆上分配由类型与所有权显示决定（如 Box&lt;T&gt;, Vec&lt;T&gt;）；编译器借助借用检查器保证生命周期安全，从根上避免了「悬垂指针」问题，但并不等价于不存在堆分配。  在 Go 中，编译器在编译期做逃逸分析：如果变量需要在其创建的函数返回后继续存活，或其地址被泄露到不受控的地方，就会被放入堆中。这降低了手工管理内存的复杂度，但也意味着我们需要理解逃逸触发的典型路径，以降低堆分配次数和 GC 负担。小结：内存逃逸不是 Go 独有，而是带有自动内存管理或抽象分配策略的语言在优化时必须面对的问题。区别在于：Go 把决策放在编译期，Java 多在 JIT 运行期，C++ 则更多由程序员显式决定。为什么会发生逃逸（Go 编译器视角）Go 编译器会在 SSA 阶段做逃逸分析。下列典型场景会触发「escapes to heap」或「moved to heap」：1) 返回局部变量的地址或引用func foo() *int {    x := 10    return &amp;x // x 必须活到函数外 -&gt; 逃逸到堆}2) 闭包捕获需要在函数返回后仍被使用的变量func counter() func() int {    n := 0    return func() int { // 闭包引用 n，需在外层函数返回后继续存活        n++        return n    }}3) 接口装箱与多态边界将具体类型赋给空接口或接口参数本身不会必然导致堆分配，但若其生命周期跨越创建点的栈帧、或者被放入堆对象（如切片、map、channel）中，往往会引发逃逸。反射（reflect）、fmt 家族函数也常在热路径里触发不必要的分配。4) 容器增长与不确定大小切片、map 需要动态增长时会触发重新分配；若元素本身位于堆中，容器扩容后的复制也会扩大堆数据规模。容量估计不足是常见诱因。5) 栈空间不足或跨协程传递当对象过大、或其地址被跨 goroutine 传递时，编译器更倾向将其放入堆上，以降低栈拷贝与复杂度。6) 逃逸链条一个变量一旦被放入「可能在堆上存活」的结构中（如存入 map、作为指针返回、作为接口传递到外层），就会沿链条放大逃逸范围，形成连锁反应。你可以用如下命令观察编译器的判断依据：go build -gcflags='all=-m -m' ./...# 关注输出中的 \"escapes to heap\"、\"moved to heap\" 等提示如何在 Go 中避免或减少逃逸逃逸不是「错误」，而是权衡。目标不是绝对禁止堆分配，而是减少「无谓」分配，降低 GC 压力与尾延迟。以下是可落地的策略与取舍说明：  值语义优先，小对象传值，大对象传指针          对于小型不可变数据（如坐标点、短小结构体），优先使用值传递与值接收者方法，以提高栈亲和与缓存局部性。      对于大型结构体或需要在多处共享的对象，用指针避免大拷贝，但需意识到这更容易触发逃逸与共享修改。        避免将临时对象暴露到堆          尽量不要返回局部变量的地址；使用值返回或让调用方传入缓冲区。      尽量避免闭包捕获大的可变对象；可改为显式参数传递，或将所需值复制到闭包内部的临时变量中。        减少接口边界与反射          热路径上避免 interface{}、fmt.Sprintf、fmt.Fprintf、reflect.Value 等动态机制；      使用具体类型与 strconv/strings.Builder/bytes.Buffer 等零分配或低分配替代物。        容器与缓冲预分配          为切片/Map 估计容量：make([]T, 0, n)、make(map[K]V, n)；      对 strings.Builder/bytes.Buffer 预先 Grow(n)，减少扩容与拷贝。        字符串与字节切片的转换          []byte(s) 与 string(b) 都会产生分配；尽量在同一层内保持一种表示，或通过 API 设计减少往返转换。      极端场景可考虑零拷贝（unsafe.String / unsafe.Slice）但需严格边界与版本约束，否则引入未定义行为风险。        使用对象池 sync.Pool（谨慎）          适合「短生命周期、创建代价高、可复用」的临时对象（如编码缓冲、压缩器、正则器）。      注意：sync.Pool 在 GC 时会被清空，不能用于缓存业务关键数据；在延迟敏感路径上，过大的对象也可能因跨 P shard 迁移带来额外开销。        函数内避免不必要的临时字符串          日志/错误在热循环中避免格式化；复用 []byte 缓冲并在边界一次性格式化。      下面给出若干示例对比（仅示意）：// 1) 返回值 vs 返回指针type Point struct{ X, Y int }// 更易留在栈上func NewPoint(x, y int) Point {    return Point{X: x, Y: y}}// 更可能逃逸（取决于调用场景）func NewPointPtr(x, y int) *Point {    p := Point{X: x, Y: y}    return &amp;p}// 2) strings.Builder 预分配func JoinWithBuilder(parts []string) string {    var b strings.Builder    // 粗略估算容量，避免多次增长    total := 0    for _, s := range parts { total += len(s) }    b.Grow(total + len(parts))    for i, s := range parts {        if i &gt; 0 { b.WriteByte(',') }        b.WriteString(s)    }    return b.String()}// 3) sync.Pool 使用范式var bufPool = sync.Pool{New: func() any {    b := make([]byte, 0, 4096)    return &amp;b}}func useBuf() {    bptr := bufPool.Get().(*[]byte)    b := (*bptr)[:0]    // ... 使用 b 作为临时缓冲 ...    *bptr = b[:0]    bufPool.Put(bptr)}基准、剖析与观测工具  编译期逃逸诊断          go build -gcflags='all=-m -m' ./... 或 go test -c -gcflags='all=-m -m'      聚焦输出中的 escapes to heap 与触发位置。        微基准与分配计数          go test -bench=. -benchmem -run=^$：同时观察 allocs/op 与 B/op。      注意基准可靠性：固定 CPU 频率、关闭涡轮、Pin 进程、GOMAXPROCS 固定、预热与多次运行。        运行期分析          pprof：CPU/内存/阻塞/互斥；go tool pprof -http=:0 交互浏览。      runtime/metrics、runtime.ReadMemStats：观察 GC 周期、堆增长、NextGC、Pause 总量。        GC 调参（视版本）          GOGC：目标堆增长百分比；数值越大，GC 越少但内存占用更高。      Go 1.19+：GOMEMLIMIT/debug.SetMemoryLimit 限制进程可用内存上限，避免节点 OOM。      基准阶段可临时 GOGC=off 排除 GC 干扰，但务必仅用于测试。      并发实践中的性能优化并发是 Go 的强项，但不当使用同样会放大分配与竞争。  协程数量控制与复用          不要「为每个请求创建一个 goroutine」而无节制；使用 bounded worker pool 控制并发度。      避免 goroutine 泄漏：退出路径必须能被关闭或取消（context.Context）。        Channel 设计          合理缓冲：突发流量下少量缓冲可降低抖动；过大缓冲可能隐藏上游背压问题。      避免在热循环中频繁 select { case &lt;-time.After(...) }：优先复用 time.Timer 并 Stop()。      对热点广播/订阅场景，单通道可能成为瓶颈，可用分片/多播结构降低竞争。        锁策略与无锁化          在读多写少场景使用 RWMutex，但写存在时 RLock 依然会被阻塞，读占比不高时反而慢于 Mutex。      热点 Map 可做分片（sharding）降低锁竞争；或在高度写竞争时改为批量聚合（log-structured）。      对计数器之类的轻量共享变量，使用 atomic 并考虑缓存行填充避免 false sharing。        数据布局与缓存友好          「切片元素为值」通常比「切片元素为指针」更具局部性（SoA/AoS 需结合场景权衡）。      小对象紧凑存储、减少指针追逐，有助于 CPU 预取与分支预测。        I/O 合并与批处理          通过缓冲、批量写入/读取降低系统调用次数；上游聚合（如 Kafka 批量）可降低端到端成本。      编程原则与规范（面向性能）以下清单可作为 code review 的关注点：  API 设计：          明确输入输出的所有权与生命周期，尽量不在接口边界做 string/[]byte 互转。      提供「带 buffer」的变体（如 Encode(dst []byte)），让调用方控制分配。        错误与日志：          热路径下避免 fmt.Errorf 及字符串拼接；使用哨兵错误、errors.Join 在边界汇总。      日志加采样与速率限制，避免结构化日志在高 QPS 下产生大量临时对象。        集合与字符串：          预估容量；避免在循环内反复增长。      频繁拼接使用 strings.Builder 或 bytes.Buffer，并尽量 Grow。        反射与泛型：          反射仅用于初始化与非热路径；      泛型减少了 interface{} 带来的装箱，更易于编译期优化与内联。        局部优化与边界权衡：          不为微不足道的 allocs/op 牺牲可读性；只在性能可观且可证实时引入复杂技巧。      实战对比：基准示例// go test -bench=. -benchmem -run=^$package demoimport (    \"bytes\"    \"strconv\"    \"strings\"    \"testing\")func BenchmarkConcat_Plus(b *testing.B) {    s := \"\"    for i := 0; i &lt; b.N; i++ {        s += strconv.Itoa(i)    }    _ = s}func BenchmarkConcat_Buffer(b *testing.B) {    var buf bytes.Buffer    for i := 0; i &lt; b.N; i++ {        buf.WriteString(strconv.Itoa(i))    }    _ = buf.String()}func BenchmarkConcat_Builder(b *testing.B) {    var sb strings.Builder    for i := 0; i &lt; b.N; i++ {        sb.WriteString(strconv.Itoa(i))    }    _ = sb.String()}上例中，+ 拼接在循环中通常会产生较多分配；bytes.Buffer 与 strings.Builder 通常能将 allocs/op 降到更低（依输入规模不同）。再看一个逃逸分析的例子：// go build -gcflags='all=-m -m' ./...type big struct { buf [1024]byte }func retPtr() *big {    b := big{}    return &amp;b // 逃逸}func retVal() big {    b := big{}    return b // 值返回，更易栈分配（由编译器决定）}GC 与内存上限控制（生产视角）  结合业务峰值与节点内存，设置合理的 GOMEMLIMIT（Go 1.19+）保障进程不被 OOM killer 终止。  根据延迟/吞吐目标调节 GOGC：较高的 GOGC 降低 GC 频率但增大内存占用；低 GOGC 提升回收频率但可能带来更多暂停与 CPU 占用。  通过分层缓存（本地+远端）与对象复用，尽量减少短命堆垃圾生成速率（allocation rate），从源头降低 GC 压力。检查清单（Cheat Sheet）  逃逸分析输出是否干净？是否有异常的热点函数产生大量 escapes to heap？  热路径是否避免了接口装箱、反射与 fmt？  切片/Map 是否做了容量预估与 Grow？  是否将大对象指针在协程间广泛传递，能否改为值拷贝或 ID 引用？  是否引入了不必要的 []byte ↔ string 转换？  是否可以通过 API 设计改为「调用方提供缓冲」？  是否合适地使用了 sync.Pool，并在 GC 清空后能自愈？  并发是否存在锁热点、goroutine 泄漏、time.After 泄漏？  是否通过基准与 pprof 证实优化收益？结语Go 的语言特性鼓励以简单的编程模型解决复杂的并发问题，但要在高性能场景下保持可预期的尾延迟和资源占用，就必须理解编译器如何在「栈与堆」之间做选择。把握逃逸触发的典型路径，利用好 -gcflags='all=-m -m'、-benchmem 与 pprof 等工具，辅以面向性能的 API 设计与并发策略，往往能在不牺牲可读性的前提下获得数量级的性能提升。牢记：优化应以度量为锚，先测量，再设计，最后验证。"
  },

  {
    "url": "/web3/2019/04/07/Web3-%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9.html",
    "title": "Web3 的定义与特点：从愿景到工程落地",
    "content": "“Web3”不是一个单一产品，而是一组互相强化的理念与技术集合：密码学身份、开放协议、可组合金融/内容组件、链上可验证状态，以及逐步去平台化的组织与治理方式。本文从历史演进到工程落地，系统阐述 Web3 的核心特点、挑战与最佳实践，并给出可操作的架构与工具清单。1. 从 Web1 → Web2 → Web3：范式迁移  Web1（只读）：门户/个人主页，内容由站点生产，用户是“浏览者”；  Web2（读写）：用户生成内容（UGC）+ 平台算法分发，账号与数据由平台托管；  Web3（读写+拥有）：私钥拥有权与可验证规则，资产/身份与应用松耦合（可携带、可组合）。迁移的本质：从“中心化平台对数据与身份的控制”转向“用户用私钥控制身份与资产”，从“平台背书可信”转向“协议与加密保证可信”。2. Web3 的核心特征（工程视角）1) 去中心化身份（DID）：地址/公钥或 DID 文档作为标识，签名即授权；2) 合约化规则：规则公开、可验证、可复用，透明度优先；3) 可组合性（Money Legos）：协议接口标准化（ERC/EIP），上层快速组合创新；4) 开放互操作：跨链桥、消息传递与共享标准；5) 可验证与可追溯：状态在链上可校验、事件可重放，抗审查能力更强；6) 经济激励：代币与治理机制协调参与者行为。3. 用户体验的现实挑战  私钥与助记词管理门槛高；  Gas 与网络切换等概念复杂；  交易确认有延迟与不确定性；  欺诈与钓鱼风险（签名诱导、授权过大）。工程应对：账户抽象（代付/批量）、清晰签名提示（EIP-4361）、自动网络配置（EIP-3085/3326）、可回滚的 UI 设计。4. 参考架构graph LR  UI[dApp] -- EIP-1193 --&gt; Wallet  Wallet -- Tx/Sign --&gt; Chain[Blockchain]  Chain -- Logs --&gt; Indexer[(Subgraph/Indexer)]  UI -- Query --&gt; Indexer  UI -- Read --&gt; RPC  前端：与钱包交互、展示状态、触发交易；  合约：资产/规则中心；  索引器：对事件进行结构化，支撑列表/统计；  RPC：直接读取链上视图状态。5. 身份与资产：DID、VC 与 Token  DID（去中心化身份）：基于公私钥/文档解析；  VC（可验证凭证）：证明所有权/资格；  Token：Fungible（ERC-20）与 Non-Fungible（ERC-721/1155）；  授权：Permit（EIP-2612）减少批准交易；  治理：一币一票/权重委托。6. 互操作与扩容：L2 与跨链  Layer2（Rollup/Validium）提高吞吐并降低成本；  跨链桥风险管理：信任模型、消息证明与流动性桥；  数据可用性层（DA）：Celestia/以太坊 DA 提供可验证数据发布。7. 风险与监管  合约漏洞：重入、访问控制、数学错误；  经济攻击：预言机操纵、MEV；  法务合规：KYC/AML、证券属性判断；  隐私：链上透明与用户隐私的平衡（ZK/混币等）。8. 工具与生态清单  前端：viem、wagmi、ethers.js；  合约：Solidity、Foundry/Hardhat、OpenZeppelin；  索引器：The Graph、SubQuery、自建 ETL（ClickHouse/PostgreSQL）；  基础设施：Infura/Alchemy、自建 Erigon/Geth；  监控：Tenderly、Etherscan API、Prometheus/Grafana；  测试：本地链（anvil/hardhat），fork 主网验收。9. 经典案例剖析（简述）  DeFi 协议（Aave/Uniswap）：开放可组合与 LP 激励、风险参数治理；  NFT 市场：元数据与版税策略、跨市场可转移性；  DAO：资金透明、投票执行自动化。10. 最佳实践（工程落地）  信任最小化：后端仅做聚合/缓存；  可观测：交易/事件/索引延迟全链路指标；  文档化：签名提示清晰、错误码与引导页；  灰度发布：多网络/小流量上线；  安全上线流程：审计+Bug Bounty+多签开关。11. 小结Web3 的“拥有权”愿景并不与“良好体验”矛盾，关键在于以工程方法补齐体验鸿沟：钱包与账户抽象降低门槛、索引器与缓存支撑用户级响应、跨链与 L2 提供可用性。坚持“开放、互操作、可组合”的原则，才可能在复杂生态中保持长期生命力。"
  },

  {
    "url": "/%E6%88%90%E9%95%BF/2019/03/18/%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF%E4%B8%8D%E7%94%A8%E7%AD%89%E5%8D%81%E5%B9%B4%E6%8B%86%E5%A2%99%E5%BC%8F%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97.html",
    "title": "技术成长不用等十年拆墙式进阶指南",
    "content": "技术成长不用等十年：拆墙式进阶指南身边总有人问：“每天写 CRUD，能成大牛吗？”“下班累得只想躺，哪有时间学新技术？”“学了半年框架，感觉还是没进步……”技术成长的焦虑，往往源于把 “成为大牛” 当成了遥不可及的山顶。但真实的成长，从来不是闷头爬坡，而是像拆墙 —— 拆掉挡在眼前的认知墙、行动墙、业务墙。每拆一块砖，视野就开阔一分，3 年能抵别人 5 年，这才是接地气的进阶逻辑。一、先拆认知墙：别被 “一万小时” 吓住《异类》的一万小时理论火了之后，太多人盯着 “10 年” 这个数字焦虑。但没人告诉你：这一万小时，藏在每天的碎片里，甚至能和加班 “搭伙过日子”。1. 别算总帐，算 “零钱”刚工作时我也觉得 “每天 3 小时” 是天方夜谭 —— 早上挤地铁，晚上加完班快 10 点，哪来整块时间？后来发现，把 “3 小时” 拆成 “5 分钟 + 15 分钟 + 20 分钟” 的零钱，反而更容易坚持。以学习 Java 开发为例：      上班前 5 分钟：打开收藏的 Java 集合框架源码片段，看 ArrayList 的 add 方法实现，了解它如何动态扩容数组，增加元素。比如看到 add 方法里，当数组容量不足时，会创建一个新的更大的数组，并将原数组元素复制过去。        午休后 15 分钟：用公司测试环境跑一段昨天学的多线程代码示例。例如写一个简单的多线程任务，模拟多个线程同时访问共享资源，观察线程安全问题，再尝试用 synchronized 关键字去解决。        睡前 20 分钟：在手机备忘录写 “今日踩坑笔记”。比如今天在写数据库查询语句时，因为没有给某个字段加索引，导致查询速度极慢，通过给该字段添加索引，查询时间从十几秒缩短到了几百毫秒。  这样一天下来，40 分钟不算多，但每周就是 280 分钟，一年积累 14560 分钟 —— 差不多 242 小时，足够啃完一本像《Effective Java》这样的源码书。2. 警惕 “伪努力” 的自我感动有人囤了 50G 教程，却只看了前 3 集；有人 GitHub 星标了 200 个项目，从没克隆过一个。这种 “收藏即学会” 的假努力，比不学习更坑 —— 它会让你产生 “我在进步” 的错觉。真成长的两个标志：      能说出 “上周学会的东西，这周用到了”。例如上周学习了 Redis 缓存技术，这周在项目中给频繁查询的热点数据加上了 Redis 缓存，大大提高了系统响应速度。原本查询数据库需要几百毫秒的接口，现在通过 Redis 缓存，响应时间缩短到了几十毫秒。        能指出 “以前写的代码，现在看是错的”。比如发现半年前写的单例模式代码，在多线程环境下会出现创建多个实例的问题，现在明白要使用双重检查锁机制或者静态内部类的方式来确保单例的唯一性。  二、再拆行动墙：把 “大目标” 砸成 “手边事”“今年要吃透 JVM”“年底前搞定分布式系统”—— 这种目标喊完就忘，因为太像 “要吃一头大象”。真正能落地的行动，是把大象切成 “今天能吃一口” 的小块。1. 目标拆解的 “三阶落地法”以 “3 个月学好 MySQL” 为例，别一上来就说 “要懂索引原理”，按 “用→优→理” 三阶拆：      第 1 个月（用）：每天花 10 分钟，给写的 SQL 加 explain 分析。比如在写一个查询用户信息的 SQL 语句时，使用 explain 关键字查看执行计划，发现因为使用了 “select *”，没有明确指定需要的字段，导致全表扫描，查询效率低下。通过优化 SQL，只查询必要字段，速度得到了提升。        第 2 个月（优）：每周挑一个慢查询，试着改写成 join。例如原本有三次单表查询，分别查询用户表、订单表、商品表，通过分析业务逻辑，将其改写成一次联表查询，减少了数据库查询次数，大大提高了查询效率。原本需要多次查询数据库并在应用层进行数据组装，现在通过一次联表查询就获取到了所需的关联数据。        第 3 个月（理）：每周末花 1 小时，对着《高性能 MySQL》看一个索引类型。比如学习聚簇索引和非聚簇索引的区别，了解到聚簇索引按照数据行的物理存储顺序构建，适合范围查询；非聚簇索引则与数据行的物理存储顺序无关，适合等值查询。并通过在测试数据库中创建不同类型的索引，进行查询测试，加深理解。  每个阶段都能立刻用在工作里，成就感会推着你走。2. 加班党的 “偷时间” 技巧上周和一个大厂朋友聊天，他说 “我加班多，但两年升了高级，靠的是加班时‘顺手学’”：      改 bug 时多问一句：“这个报错的底层原因是什么？” 比如遇到 NullPointerException 空指针异常报错，在修复 bug 的同时，顺手查阅 JVM 的空指针检查机制。了解到 JVM 在执行字节码指令时，当访问一个空引用的对象实例的属性或方法时，就会抛出这个异常。通过深入理解，以后在编写代码时能更注重对象的判空处理，避免类似问题。        部署代码时多做一步：“加个监控指标行不行？” 例如在给接口部署上线时，顺便添加一个响应时间监控指标。通过使用 Prometheus 这样的监控工具，配置好相应的指标采集规则，就可以实时观察接口的响应时间变化。这不仅能帮助及时发现系统性能问题，还让自己学会了 Prometheus 的基础用法。        下班前花 5 分钟：“今天的代码里，哪个地方能再简化一行？” 比如把重复的判断逻辑抽成工具类，练习了设计模式。原本在多个地方都有判断用户是否登录的重复代码，通过创建一个 UserUtil 工具类，将判断逻辑封装在其中，其他地方只需调用该工具类的方法，代码变得更加简洁、易维护，同时也加深了对设计模式中封装思想的理解。  加班不是成长的敌人，关键是别当 “代码搬运工”。三、最后拆业务墙：CRUD 里藏着 “进阶密码”“天天写业务，哪有技术含量？” 这是最大的误解。业务代码就像土壤，能不能长出技术的苗，看你会不会 “深挖三铲”。1. 业务代码的三层深挖法拿最普通的 “用户注册” 功能举例：      第一层（功能）：完成表单校验、入库（这是基础）。在实现用户注册功能时，首先要对用户输入的用户名、密码、手机号等信息进行表单校验，确保格式正确且符合业务规则。例如用户名不能包含特殊字符，密码长度要在一定范围内等。校验通过后，将用户信息插入数据库的用户表中。        第二层（优化）：加个手机号格式缓存（不用每次查数据库），加个异步发送短信（不阻塞注册流程）—— 这就用到了缓存和多线程。可以使用 Redis 缓存来存储已经校验过的手机号格式，当下次有新用户注册输入手机号时，先从 Redis 中查询该手机号格式是否已经校验过，若已校验则直接通过，无需再进行复杂的格式校验逻辑，减少数据库查询压力。同时，为了避免发送注册成功短信时阻塞用户注册流程，可以使用多线程技术，将发送短信的任务放到一个新的线程中执行。例如在 Java 中，可以使用线程池来管理这些发送短信的线程，提高系统并发处理能力。        第三层（原理）：想想 “为什么用 Redis 存验证码？”“线程池参数怎么设才不炸？”—— 逼着自己关联底层知识。思考为什么选择 Redis 存储验证码，是因为 Redis 具有高性能、支持分布式、数据结构丰富等特点，适合存储验证码这种时效性强的数据。对于线程池参数设置，要考虑任务类型、并发量等因素。比如如果是 CPU 密集型任务，线程池大小不宜设置过大，防止过多线程竞争 CPU 资源；如果是 I/O 密集型任务，可以适当增大线程池大小，充分利用 CPU 空闲时间处理其他任务。通过这样深入思考，能将业务实现与底层技术原理紧密联系起来，提升技术深度。  我见过有人把注册功能写成 “分布式锁防重复提交”“消息队列削峰” 的案例，业务没变，但技术深度完全不同。2. 用 “业务问题” 当钥匙别总等着 “学完再用”，要学会 “用了再学”。比如：      发现 “订单查询慢”，就去学索引优化。在实际业务中，如果订单数据量较大，订单查询速度慢，通过分析发现是因为查询语句没有合理利用索引。这时就可以学习索引优化知识，比如为经常用于查询条件的字段创建合适的索引，选择合适的索引类型（如 B - Tree 索引、哈希索引等）。通过实际业务问题驱动学习，能更快掌握索引优化技巧，并应用到项目中，显著提升订单查询速度。        遇到 “并发下单超卖”，就去学分布式锁。当电商系统中出现高并发下单时，可能会出现商品超卖问题。为了解决这个问题，需要学习分布式锁知识。可以了解基于 Redis、Zookeeper 等实现分布式锁的原理和方式。例如使用 Redis 的 SETNX 命令（SET if Not eXists）来实现简单的分布式锁，通过设置锁的过期时间来避免死锁。在实际项目中应用分布式锁，解决并发下单超卖问题，同时也加深了对分布式系统一致性问题的理解。        老板说 “系统总崩”，就去学监控和高可用。如果系统经常崩溃，影响业务正常运行，此时就需要学习系统监控和高可用技术。可以使用如 Grafana + Prometheus 组合进行系统监控，实时监测系统的 CPU 使用率、内存使用率、磁盘 I/O、网络流量等指标，及时发现系统性能瓶颈。对于高可用架构，可以学习如何使用负载均衡、集群部署等技术，将系统部署到多个服务器上，当一台服务器出现故障时，其他服务器能继续提供服务，保证系统的高可用性。通过解决业务中的这些痛点问题，推动自己不断学习新的技术知识。  业务中的痛点，恰恰是最好的学习路标。去年有个同事，因为负责的后台总卡顿，硬着头皮学了 JVM 调优，现在成了团队里的 “性能优化专家”。四、拆墙工具包：3 个随时能用的小技巧1. 5 分钟碎片法      蹲坑时：刷一篇 “10 行代码讲透 ArrayList 扩容”。在手机上阅读相关技术文章，了解 ArrayList 在添加元素时，如果当前容量不足，是如何通过创建新数组、复制元素等步骤实现扩容的，加深对集合框架底层原理的理解。        等电梯时：在脑子里过一遍 “今天改的那个 bug，根本原因是什么？”。回顾今天修复的某个代码错误，思考是因为逻辑判断失误、语法错误，还是对某个 API 的使用不当导致的，强化对问题的分析和解决能力。        外卖到了还没开吃：打开 IDE，跑一遍昨天记的代码片段。比如昨天学习了一段关于文件读写的代码，利用这几分钟时间在 IDE 中运行一下，确保自己真正掌握了这段代码的功能和使用方法，同时也能加深记忆。  碎片时间不用学新知识，能复盘、能巩固就够了。2. 进步可视化找个笔记本，每天写三行：      今天解决了什么问题？（哪怕是 “搞定了一个乱码 bug”）。例如今天在处理用户上传文件时，文件内容出现乱码，通过排查发现是文件编码格式与系统默认编码格式不一致，通过修改编码设置解决了这个问题。        用到了什么知识点？（比如 “知道了 UTF - 8 和 GBK 的区别”）。在解决乱码问题过程中，了解到 UTF - 8 是一种变长编码，支持全球几乎所有字符集，而 GBK 是针对简体中文的编码，二者在编码范围、存储方式上有所不同。        明天想搞懂什么？（比如 “为什么 Postman 发请求会跨域”）。由于在测试接口时发现使用 Postman 发送请求出现跨域问题，明天计划深入学习跨域产生的原因（浏览器的同源策略限制）以及解决方案（如使用 CORS、JSONP 等）。  三个月后翻一翻，会发现自己不知不觉懂了这么多。3. 业务代码的 “找茬游戏”每次写完代码，问自己三个问题：      这行代码，换个写法能更快吗？（比如用 for 循环代替 Stream，在数据量大时更快）。在处理一个对集合进行遍历操作的需求时，对比使用传统 for 循环和 Java 8 的 Stream API 的性能。通过测试发现，当集合数据量较大时，for 循环的执行效率更高，因为 Stream API 在内部会进行一些封装和函数式编程操作，有一定的性能开销。        这段逻辑，加个日志能方便排错吗？（比如给支付流程加 “订单状态变更” 日志）。在实现支付功能时，为了便于后续排查问题，在订单状态发生变更的关键节点添加日志记录，如记录订单从 “待支付” 变为 “支付中”“支付成功”“支付失败” 等状态的时间、操作人等信息，方便在出现问题时快速定位和分析。        这个功能，未来可能会怎么变？（比如用户量涨 10 倍，数据库要不要分表）。考虑到业务的发展，如果未来用户量大幅增长，现有的数据库表结构可能无法满足性能需求。提前思考是否需要进行数据库分表操作，以及分表的策略（如按时间分表、按用户 ID 取模分表等），培养对系统扩展性的思考能力。  找茬多了，慢慢就有了 “架构思维”。结语：成长是 “今天比昨天多懂一点”没人能一口吃成胖子，技术成长也不用等十年。你不用每天学 3 小时，每天 20 分钟够了；你不用立刻搞定分布式，先把手里的 SQL 写明白；你不用羡慕别人懂源码，先搞懂自己项目里的框架怎么配置。就像拆墙，今天拆一块砖，明天拆一片瓦，突然有一天抬头，会发现自己已经站在以前仰望的高度。现在打开你的 IDE，从改好眼前的第一行代码开始吧。"
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/mysql/2018/11/22/MySQL-%E9%94%81%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%AD%BB%E9%94%81%E5%88%86%E6%9E%90%E6%89%8B%E5%86%8C.html",
    "title": "MySQL 锁监控与死锁分析手册",
    "content": "如何系统化监控行锁/间隙锁与快速定位死锁？本文提供可复现脚本、标准化视图与操作手册。1. 死锁复现（RR 下 Next-Key）CREATE TABLE t_lock(  id INT PRIMARY KEY,  k  INT,  KEY idx_k(k)) ENGINE=InnoDB;INSERT INTO t_lock VALUES (1,10),(2,20),(3,30);会话A：SET tx_isolation='REPEATABLE-READ'; START TRANSACTION;SELECT * FROM t_lock WHERE k BETWEEN 10 AND 30 FOR UPDATE; -- 锁住[10,30]会话B：SET tx_isolation='REPEATABLE-READ'; START TRANSACTION;UPDATE t_lock SET k=11 WHERE id=1; -- 等待A释放-- 回到会话A：UPDATE t_lock SET k=21 WHERE id=2; -- 互等 -&gt; 死锁2. 死锁日志解读SHOW ENGINE INNODB STATUS\\G关注：  LATEST DETECTED DEADLOCK 中 WE ROLL BACK TRANSACTION 指出被回滚事务；  lock_mode X locks rec but not gap / locks gap before rec 定位间隙锁；  index idx_k of table 对应的索引与范围。3. 在线监控  8.0：performance_schema.data_locks / data_lock_waits 关联 threads 得到阻塞链；  5.7：information_schema.innodb_locks / lock_waits（较旧）。4. 自动化抓取脚本（示意）SELECT l.*, w.*FROM performance_schema.data_lock_waits wJOIN performance_schema.data_locks l  ON w.BLOCKING_ENGINE_LOCK_ID = l.ENGINE_LOCK_ID;周期抓取 + 告警（阻塞&gt;5s）。5. 规避策略  精确索引，避免大范围扫描引发大量 gap 锁；  将写入拆分为更细粒度范围；  业务侧重试+幂等；  读写分离，长事务落只读副本。6. 死锁成因全景（结合 InnoDB 锁模型）死锁的四个必要条件：互斥使用、占有并等待、不可剥夺、循环等待。InnoDB 在行级与间隙级锁语义下，以下模式最易触发循环等待：  不一致的访问顺序：          事务A更新 A→B，事务B更新 B→A；或一个通过二级索引回表更新，另一个直接按主键更新，锁顺序不同。        范围更新引入 Next-Key/Gap Lock：          在 RR 下，SELECT ... FOR UPDATE/UPDATE/DELETE 会对命中记录及其间隙加锁，多个事务在相邻范围内插入/更新易互等。        唯一键检查 + 插入意向锁：          插入唯一键前需要在唯一索引区间做 Next-Key 检查；与并发范围更新/去重查询交错形成环路。        二级索引与回表：          一方以二级索引扫描并回表，另一方以主键路径进入，组合出的锁申请序列不一致。        外键检查：          父/子表在不同顺序读写，外键检查需要额外 S 锁/间隙锁，改变锁顺序。        自增锁与热点：          大并发插入时，旧模式下 AUTO-INC 锁可能放大等待链；热点值导致索引页竞争与页分裂叠加。        缺索引与大事务：          无索引范围扫描扩大锁集合；慢 SQL/长事务持锁时间长，死锁概率上升。      典型两会话交错示意：-- 场景1：访问顺序不一致-- 会话ASTART TRANSACTION;UPDATE t SET v=v+1 WHERE id=1; -- 锁 id=1UPDATE t SET v=v+1 WHERE id=2; -- 等待会话B释放-- 会话BSTART TRANSACTION;UPDATE t SET v=v+1 WHERE id=2; -- 锁 id=2UPDATE t SET v=v+1 WHERE id=1; -- 等待会话A释放 -&gt; 环-- 场景2：RR 下范围更新 + 插入唯一键-- 会话ASTART TRANSACTION;UPDATE t SET status=1 WHERE idx BETWEEN 10 AND 20; -- Next-Key 锁-- 会话BSTART TRANSACTION;INSERT INTO t(uq, idx, ...) VALUES('X', 15, ...); -- 唯一检查 + 插入意向-- 两边在唯一索引/二级索引与主键上的锁互等7. 事务隔离级别与锁行为（InnoDB 语义）  Read Uncommitted（读未提交）：几乎不用；当前读仍会加锁，允许脏读。  Read Committed（读已提交）：一致性读不加锁；大多数场景不使用 Gap Lock（外键/唯一检查仍可能使用），死锁概率低于 RR。  Repeatable Read（可重复读，默认）：一致性读用 MVCC；当前读采用 Next-Key Lock 防幻读，范围操作更易死锁。  Serializable（可串行化）：读也加锁，吞吐大降，除非强隔离需求。要点：  普通 SELECT（快照读）不加行锁；FOR UPDATE/LOCK IN SHARE MODE/UPDATE/DELETE 属于当前读会加锁。  RC 相比 RR 减少间隙锁；RR 下 Next-Key 是默认策略。  参数参考：innodb_autoinc_lock_mode=2 降低自增锁争用；innodb_deadlock_detect 控制检测器；innodb_lock_wait_timeout 控制等待上限。8. InnoDB 内部死锁处理机制（源码视角）InnoDB 锁与事务核心位于 storage/innobase：  锁子系统（lock_sys）：表锁 LOCK_TABLE、记录锁 LOCK_REC；模式 S/IS、X/IX、AUTO-INC、INSERT INTENTION；记录锁细分 Record/GAP/Next-Key。  事务结构（trx_t）：持有锁集合、等待中的锁 trx-&gt;lock.wait_lock、undo 信息。  锁入队：lock_rec_add_to_queue() / lock_table_add_to_queue() 将请求加入等待队列。  死锁检测：等待入队时，基于等待图进行环检测（lock0lock.cc 等）。从当前等待事务出发，遍历“阻塞我的锁→持锁事务→该事务正在等待的锁”，若回到起点即形成环。  牺牲者选择：按代价（已修改行数/undo 量/事务年龄/持有锁数量等）选择最小代价事务回滚，向其返回 1213，其余唤醒继续执行。  超时路径：未开检测器或无环，等待至 innodb_lock_wait_timeout 抛 1205。伪代码抽象：on_lock_wait(trx, lock_req):  if deadlock_detect_on and detect_cycle_from(trx):    victim = choose_lowest_cost_trx()    rollback(victim)    wake_up_waiters()  else:    wait_until_granted_or_timeout()诊断入口：SHOW ENGINE INNODB STATUS\\G 会输出最近一次死锁的等待链；设置 innodb_print_all_deadlocks=ON 可将所有死锁写入错误日志（生产谨慎）。9. 系统化诊断步骤（生产可用）1) 快速取证：  执行 SHOW ENGINE INNODB STATUS\\G，定位 LATEST DETECTED DEADLOCK。  抓取两个（或以上）事务的 SQL、索引名、锁模式（locks rec but not gap/locks gap before rec）。2) 在线视图：SELECT * FROM performance_schema.data_lock_waits; -- 等待边SELECT * FROM performance_schema.data_locks;      -- 锁明细SELECT * FROM sys.schema_lock_waits LIMIT 50;     -- 友好视图3) 执行计划核验：  对死锁 SQL 逐条 EXPLAIN，确认是否走了不同索引、是否回表、是否大范围扫描。4) 事务画像：  检查是否存在跨请求长事务、事务内外部 IO、批量扫描；确认提交点是否靠后。5) 复现与回归：  用最小化数据集在两个会话复现；将复现脚本纳入回归库。10. 工程实践：如何避免死锁  统一访问顺序（首要）：          规定跨表/跨索引的访问次序（如按主键升序 A→B→C），避免交叉顺序。        拆小事务，尽早提交：          批量更新分批提交；把只读校验前置；缩短持锁窗口。        索引到位，路径一致：          where 条件命中索引，尽量落到 Record Lock；必要时 FORCE INDEX 统一路径，减少“二级索引回表 vs 主键直达”的差异。        隔离级别策略：          OLTP 优先 RC（若业务允许），RR 场景要避免范围更新；或将“读→算→改”改为“精确定位→改”。        善用 8.0 特性：          FOR UPDATE SKIP LOCKED 跳过已锁行避免互等；NOWAIT 立即失败，应用快速重试。        热点打散与自增锁：          设计上分片热点键；配置 innodb_autoinc_lock_mode=2 减少 AUTO-INC 锁争用。        事务内禁止外部 IO：          避免 RPC/磁盘慢操作扩大持锁时间。        失败重试与幂等：          捕获 1213/1205 指数退避重试；以唯一键/业务幂等键确保多次提交安全。        代码层策略化：          收敛到统一 DAO/仓储层，内置锁序策略与“精确更新”模板；CR 强制检查。        监控预警与演练：          建立锁等待指标阈值；压测期开启 innodb_print_all_deadlocks，以现场日志反推 SQL 与索引设计。      11. 可复现实战案例案例A：二级索引范围更新 vs 主键更新CREATE TABLE t_a(  id BIGINT PRIMARY KEY,  k  INT,  KEY idx_k(k)) ENGINE=InnoDB;INSERT INTO t_a VALUES (1,10),(2,20),(3,30);-- 会话A（走二级索引）START TRANSACTION;UPDATE t_a SET k=k+1 WHERE k BETWEEN 10 AND 30; -- Next-Key + 回表-- 会话B（走主键）START TRANSACTION;UPDATE t_a SET k=25 WHERE id=2; -- Record Lock-- 两者在主键回表记录与二级索引范围上互相等待修复建议：  先用覆盖索引挑出主键集合，再按主键升序逐条精准 UPDATE；或在 RC 下改造范围操作；或对 B 强制走相同索引路径；或用 SKIP LOCKED 处理任务类更新。案例B：唯一键插入与范围更新CREATE TABLE t_b(  id BIGINT PRIMARY KEY,  uq VARCHAR(32) UNIQUE,  k  INT,  KEY idx_k(k)) ENGINE=InnoDB;-- 会话ASTART TRANSACTION;UPDATE t_b SET k=k+1 WHERE k BETWEEN 100 AND 200; -- Next-Key-- 会话BSTART TRANSACTION;INSERT INTO t_b(uq, k) VALUES('U-1', 150); -- 唯一检查 + 插入意向修复建议：  将范围更新拆小、改精确更新；或让插入避开竞争区间；或业务上统一顺序（先完成更新再插入）。12. 参数与配置建议  innodb_deadlock_detect=ON：可快速打断死锁；极端热点写场景可评估关闭并配合短超时+重试。  innodb_lock_wait_timeout：OLTP 建议 5–15s；务必配合应用层重试。  innodb_print_all_deadlocks=ON：压测/排障阶段开启，生产慎用。  innodb_autoinc_lock_mode=2：大并发插入友好。  隔离级别：OLTP 倾向 RC；需要 RR 时务必配合锁序策略与索引精确化。13. 上线前检查清单（Checklist）  是否定义并落地了“锁序白皮书”（跨表/跨索引）？  核心更新/删除是否命中索引并路径一致？  是否避免事务内外部 IO，定位了提交点？  是否为写操作设计幂等键并实现重试策略？  是否建立了锁等待/死锁指标与告警阈值？  是否准备了“死锁复现脚本”作为回归用例？14. 常用命令速查SHOW ENGINE INNODB STATUS\\G;SELECT * FROM performance_schema.data_lock_waits;SELECT * FROM sys.schema_lock_waits LIMIT 50;EXPLAIN FORMAT=JSON &lt;your SQL&gt;;  错误码：1213（Deadlock found）需重试；1205（Lock wait timeout）需优化或重试。"
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/mysql/2018/11/03/MySQL-MVCC-%E4%B8%8E%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB%E6%B7%B1%E5%85%A5.html",
    "title": "MySQL MVCC 与快照隔离深入",
    "content": "本文系统拆解 InnoDB MVCC 的实现细节：undo log、隐式列、Read View、可见性判断与二级索引回表的一致性，并给出可复现实验、源码走读与排错清单。1. MVCC 结构  隐式列：trx_id（最近一次修改事务ID）、roll_pointer（回滚指针）。  undo log：维护历史版本链；读已提交/可重复读通过 Read View 选择可见版本。2. Read View 生成与可见性  关键字段：creator_trx_id、活跃集合 m_ids、low_limit_id、up_limit_id。  判断规则：trx_id &lt; low_limit_id 可见；trx_id &gt;= up_limit_id 不可见；在集合内不可见。SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;START TRANSACTION;SELECT * FROM t WHERE id = 1; -- 固定 Read View3. 二级索引一致性  二级索引条目不含行可见性信息，需回表到聚簇索引判断；  覆盖索引可避免回表，但仍受 MVCC 可见性约束。4. 可复现实验：幻读与间隙锁准备数据：CREATE TABLE t(  id INT PRIMARY KEY,  k  INT,  KEY idx_k(k)) ENGINE=InnoDB;INSERT INTO t VALUES (1,10),(2,20),(3,30);事务 A（会话1）：SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;START TRANSACTION;SELECT * FROM t WHERE k BETWEEN 10 AND 30 FOR UPDATE; -- Next-Key Lock事务 B（会话2）：INSERT INTO t VALUES(4,25); -- 阻塞：被间隙锁拦截，避免幻读切换 RC：SET GLOBAL transaction_isolation='READ-COMMITTED';-- 重新测试，观察 gap 锁减少与并发插入的行为变化5. 实验：RR 下版本可见性-- 会话1START TRANSACTION; SELECT * FROM t WHERE id=1; -- 读到 v1-- 会话2UPDATE t SET k=k+1 WHERE id=1; COMMIT;          -- v2-- 会话1SELECT * FROM t WHERE id=1; -- 仍读到 v1（同一 Read View）COMMIT;6. 源码走读要点（8.0）  read0read.cc：一致性读实现，基于 Read View 的可见性检查；  trx0trx.cc：事务生命周期与 ReadView 构建；  lock0lock.cc：Next-Key Lock 组合与冲突检测。关注点：m_ids 计算的边界、长事务导致的 purge 延迟对可见性的影响。7. 典型排错清单  长事务导致 history list length 过大，undo 堆积：          排查 information_schema.innodb_trx，定位阻塞的只读/未提交事务；        幻读与行锁升级：          检查是否遗漏索引导致范围扩大、或 RC 下并发写放大；        覆盖索引未生效：          EXPLAIN ANALYZE 对比 using index；确认选择列是否完全被索引覆盖。      8. 最佳实践  将批量只读分析放到只读副本，避免长事务阻塞主库 purge；  范围更新尽量精确，必要时逻辑分片降低锁冲突；  定期巡检长事务、undo 使用、innodb_purge_threads 与 IO 限流。"
  },

  {
    "url": "/web3/2018/03/12/%E6%AF%94%E7%89%B9%E5%B8%81-%E8%B5%B7%E6%BA%90%E4%B8%8E%E5%A5%96%E5%8A%B1%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90.html",
    "title": "比特币的起源与奖励机制：底层逻辑与演进",
    "content": "比特币不是突然出现的一段代码，而是密码学、经济学与分布式系统三股力量长期积累后的工程综合体。本文从历史动机、共识与难度、奖励与费用市场、安全预算与长期可持续性等角度，对比特币的激励机制进行系统拆解，并给出工程视角的观察指标与常见误区澄清。1. 起源与设计动机  金融危机背景：2008 年全球金融危机后，中心化信用机制的脆弱性暴露。中本聪在创世区块留言 “Chancellor on brink of second bailout for banks”。  技术积累：工作量证明（Hashcash）、梅克尔树（Merkle Tree）、公钥密码学（ECDSA）、点对点网络（P2P）。  目标画像：无需许可的电子现金系统，任何人都可加入/退出，用计算工作替代机构信用，规则写入协议与代码而非人治。2. 创世区块与初始参数  区块间隔：目标 10 分钟（通过难度调整逼近）。  难度重算：每 2016 个区块（约两周）按实际出块时间调整难度；调整幅度被限制在目标时长的 1/4 到 4 倍之间，避免剧烈震荡。  奖励初始值：50 BTC/区块，约每 210,000 个区块减半一次（≈ 4 年）。  货币上限：几何级数收敛于约 2100 万枚（见下节推导）。3. POW 与难度调整的底层逻辑  工作量证明：矿工需找到使区块头哈希小于目标阈值的随机数（Nonce），概率与算力成正比。  难度与目标：难度越高，目标阈值越低，满足条件的哈希更稀有，从而拉长期望出块时间至约 10 分钟。  经济含义：算力越多，单位时间内期望产出的区块数不变（仍然约 6 个/小时），因此矿工的边际收益取决于自身算力在全网算力中的占比，而非绝对算力。4. 区块奖励与减半曲线（总量 2100 万如何得出）  每个减半周期的新区块奖励总量：50 × 210,000、25 × 210,000、12.5 × 210,000 …  这是公比为 1/2 的几何级数，极限总量：          210,000 × 50 × (1 + 1/2 + 1/4 + …) = 210,000 × 50 × 2 = 21,000,000。        工程注意：受早期客户端精度与奖励规则边界影响，实际铸币量略低于理论极限，约 20999999.9769 BTC，通常近似为 2100 万。5. 手续费市场：从补充到主角  收入结构：矿工收入 = 区块补贴（新币）+ 交易费（手续费）。  演进趋势：补贴随时间指数级衰减，长期安全预算需更多依赖费用市场。  费用形成机制：区块空间稀缺（区块尺寸与出块频率受限），用户以更高费用竞争打包优先级，形成“第一价格拍卖”近似的市场。  事件冲击：牛市高峰、铭文/Ordinals、L2 结算拥堵均会显著提高费率并提升矿工收入占比。6. 激励相容与博弈简析  诚实路径：遵守最长链/最多累计难度链规则、及时传播区块，获得稳定的期望奖励。  偏离代价：自私挖矿、双花尝试在高算力占比与网络延迟条件下才有正期望，且面临孤块风险、信誉受损、合规风险。  协议设计：通过难度调整与费用市场，使“诚实挖矿”成为占优策略（或近似占优）。7. 安全预算与长期可持续性  概念：网络抵御攻击的经济门槛 ≈ 攻击者需要的算力成本与机会成本之和。  趋势担忧：减半后补贴下降，若费用市场不足，理论上可能降低攻击门槛。  现实缓解：          成熟的 ASIC 产业链与能源合作降低单位算力成本，提高退出壁垒；      交易批量化与 LN/rollup 结算带来高峰期费用；      市场周期与叙事（如“数字黄金”）扩张链上结算需求。        工程应对：          观测“手续费/区块补贴”之比的长期趋势；      观察孤块率、难度带宽利用率、内存池深度分布；      评估减半窗口前后矿工哈希迁移与地理分布集中度。      8. 常见误区  误区 1：算力翻倍 → 价格必涨。事实：发行速率由协议决定，算力主要反映成本曲线与矿工对未来价格的预期。  误区 2：手续费永远会回到低位。事实：区块空间供给刚性，需求波动会形成有记忆的费率结构。  误区 3：减半一定推高价格。事实：供给收缩是必要但非充分条件，价格还取决于需求、流动性与宏观环境。9. 工程实践与观测指标  全节点运维：          同步模式（全量/修剪）、磁盘与带宽规划、快照校验；      指标：区块传播延迟、孤块率、mempool 尾部延迟（p95/p99）。        矿工/矿池侧：          收益分布（补贴 vs 手续费）与难度变化的弹性；      交易选择策略（费率/字节、Child-Pays-For-Parent、RBF）。        分析与风控：          监控大额未确认交易对费率的扰动；      减半窗口的区块时间方差与难度调整幅度。      10. 小结比特币用“可验证的工作”替代“中心化信用”，并以“递减补贴 + 费用市场”的双机制为网络安全买单。其长期健康取决于费用市场的成熟度与需求侧的持续性。对工程与研究从业者而言，理解难度调整、费用形成与矿工博弈，是评估网络安全预算与经济稳态的基础功夫。"
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/php/2018/01/26/PHP-%E5%8D%8F%E7%A8%8BSwoole-%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5.html",
    "title": "PHP 协程 Swoole 高并发实践",
    "content": "Swoole 将 PHP 带入常驻内存 + 协程并发时代。本文聚焦调度、Hook、协程上下文与与 MySQL/Redis 客户端协作细节，并提供压测脚本与避坑指南。1. 协程 Hook  Swoole\\Runtime::enableCoroutine() 对常见 IO 进行 Hook；  注意与第三方扩展兼容性（cURL、多进程）。2. 连接池示例class MySQLPool { /* ... 维护 Channel 与 连接对象 ... */ }// 请求开始从池获取，结束归还；确保协程安全3. 压测wrk -t8 -c200 -d60s http://127.0.0.1:9501/观察 QPS、P95、net.core.somaxconn、ulimit -n。4. 常见坑  全局单例污染：请求间状态泄漏；  异常处理：协程内抛出的异常要汇聚到日志与告警；  Composer 热更新失效：常驻进程需手动 reload。"
  },

  {
    "url": "/web3/2017/09/11/%E5%AF%86%E7%A0%81%E5%AD%A6-%E5%8F%91%E5%B1%95%E5%8F%B2%E4%B8%8E%E5%BD%93%E4%BB%A3%E7%BB%8F%E6%B5%8E%E5%BD%B1%E5%93%8D.html",
    "title": "密码学-发展史与当代经济影响",
    "content": "密码学不仅是保密术，更是现代经济的底层信任机器。从古典替换法到公钥革命，从TLS到区块链与零知识证明，密码学已成为互联网与数字经济的基础设施。本文按时间脉络梳理密码学主要里程碑，并分析其对金融、支付、数据市场与监管的深远影响。1. 古典密码学：对称“保密术”的时代  早期方法：凯撒移位、维吉尼亚表、一次性密码本（理论上不可破）。  工业化破解：二战期间的机械与电机加密（恩尼格玛、紫密），由统计分析与计算机器（图灵机）推动破解技术跃迁。2. 公钥密码学革命（1970s）  基本思想：将加密密钥与解密密钥分离，解决密钥分发难题。  代表算法：RSA（整数分解困难）、Diffie–Hellman（离散对数）、椭圆曲线 ECDSA/ECDH（以更短密钥提供相当安全性）。  重要配套：数字签名、消息认证码（MAC）、哈希函数（SHA 系列）、随机数生成器（CSPRNG）。3. 互联网与密码协议（1990s–）  TLS/SSL：为网页、支付与 API 提供端到端加密与身份认证；证书与 PKI 形成“信任锚”。  存储与传输：AES 成为对称加密事实标准，GCM/ChaCha20-Poly1305 提供高效认证加密。  典型应用：磁条到 EMV 的演进、FIDO 无密码认证、端到端即时通讯（Signal/WhatsApp）。4. 区块链与可验证计算  比特币：用工作量证明将经济激励与加密结构结合，形成无需许可的结算层。  以太坊与智能合约：在可验证状态机上运行通用逻辑，扩展到金融、游戏与治理。  零知识证明：SNARK/STARK 让“在不暴露数据的前提下证明计算正确”成为可能，支持隐私与扩容（Rollup）。5. 经济影响：密码学如何塑造现代经济  支付与清算：端到端加密与签名降低欺诈率，缩短清算周期，推动线上商业全球化。  金融市场：          交易所与托管：HSM、多签与 MPC 提升资产安全；      衍生品与预言机：签名与可验证数据输入降低对手方风险；      监管科技（RegTech）：可验证日志与选择性披露支持合规审计。        数据要素：          同态加密与多方安全计算（MPC）实现“可用不可见”，构建数据交易信任；      零知识 KYC/AML：证明“满足规则而不暴露隐私”，平衡隐私与合规。        实体经济：物联网与供应链使用硬件根信任（TPM/TEE）、签名与时间戳追溯真伪与责任。6. 风险与误区  脆弱实现：随机数偏差、侧信道攻击、时间侧道、重放与降级攻击。  过度依赖：密码学保证计算层可信，但无法替代法律治理与物理世界的安全控制。  算法寿命：量子威胁下的后量子密码（PQC）迁移成本不可忽视（NIST 标准化进行中）。7. 工程与治理建议  工程侧：          使用经过审计与广泛部署的库（OpenSSL、libsodium、BoringSSL），禁止自研原语；      默认启用 AEAD 与前向保密（ECDHE）；      秘密管理采用 HSM、KMS 或至少硬件隔离，轮换与分权控制。        治理侧：          建立数据最小化与零知识披露策略；      引入“加密账本 + 传统审计”混合治理，提升可追溯与合规性；      制定 PQC 迁移路线图与兼容测试。      8. 小结密码学已经从“保密术”成长为经济基础设施：它定义了我们如何签名、结算、定价风险与进行跨主体协同。在 Web3 语境下，密码学进一步承担了“可验证规则”的角色。理解其历史、原语与应用边界，是构建可靠数字经济系统的前提。"
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/java/2017/05/21/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E4%BB%8ELock%E5%88%B0AQS.html",
    "title": "Java 并发编程：从 Lock 到 AQS",
    "content": "并发编程里，“锁”是跨线程协调和内存可见性的核心抽象。本文从 Java 对象头与锁位开始，系统梳理锁信息的存放位置、synchronized 与 Lock/AQS 的实现原理、CAS 的内存语义与常见陷阱，并从 x86/ARM 的汇编视角出发，解释 HotSpot 在不同平台上的底层逻辑。最后给出工程实践的选型建议与调优要点。1. Java 对象、对象头与锁位HotSpot 中对象的内存布局通常包含三段：  对象头（Header）：包含 Mark Word 和 Klass Pointer；数组对象还包含数组长度。  实例数据（Instance Data）：各字段的实际存储。  对齐填充（Padding）：保证对象按 8 字节对齐。1.1 Mark Word 与锁信息Mark Word 是一个会随对象状态复用的位段（32/64 位 JVM 分别是 32/64 位；在 64 位下如果启用指针压缩，Klass Pointer 为 32 位）：  无锁：存放对象哈希（identity hash code）、GC Age 等。  偏向锁：存放偏向线程 ID、Epoch、Age 等。  轻量级锁：存放指向线程栈上“锁记录（Lock Record）”的指针（Displaced Header）。  重量级锁：存放指向 Monitor（对象监视器）的指针。锁标志位（lock bits）与偏向标志位（biased bit）共同决定 Mark Word 当前的语义。需要注意：  一旦对象计算过 identity hash code（如调用过 System.identityHashCode，或对象参与了基于哈希的容器），Mark Word 需要存放 hash，偏向锁将无法使用（会导致偏向撤销或直接进入轻量级/重量级路径）。  锁状态是“可升级、不可降级”的：无锁 → 偏向 → 轻量级 → 重量级。1.2 JDK 版本对偏向锁的影响  JDK 6～8：偏向锁默认启用（可通过 -XX:-UseBiasedLocking 关闭）。  JDK 15：根据 JEP 374，偏向锁被默认禁用并标记为废弃。  JDK 18 起：HotSpot 中移除了偏向锁实现（仅保留语义历史说明）。工程上撰写面向“现代 JDK（11/17/21 LTS 及以上）”的代码时，可不再依赖偏向锁的收益模型，更多关注轻量级/重量级路径与锁粗细粒度的取舍。2. synchronized 的状态流转与 Monitorsynchronized 基于对象监视器（Monitor）实现。HotSpot 会根据竞争情况在不同状态间切换：1) 无锁：进入同步块首次尝试；2) 轻量级锁：线程在自己的栈帧创建“锁记录”，用 CAS 将对象头替换为指向锁记录的指针；3) 自旋：竞争不重时短暂自旋等待可避免阻塞开销；4) 重量级锁：自旋失败或竞争激烈时膨胀为 Monitor，失败线程进入阻塞，等待 unpark/notify 唤醒。Monitor 内部有两个队列概念：  入口队列（EntryList）：在 synchronized 入口处等待获取锁的线程。  WaitSet：调用 Object.wait() 释放锁并等待条件的线程集合，被 notify/notifyAll 转移回 EntryList。现代 HotSpot 中，阻塞/唤醒通常经由 Unsafe.park/unpark 实现，底层在 Linux 使用 futex，在 macOS 使用 pthread 条件变量等原语。2.1 轻量级锁细节（Lock Record）轻量级锁是“乐观地假设不存在并发”。流程：1) 将对象头的 Mark Word 复制到线程栈的锁记录。2) 使用 CAS 将对象头替换为指向锁记录的指针。3) 成功即获得锁；失败说明存在竞争，进入自旋或膨胀。4) 解锁时尝试用 CAS 将对象头还原为锁记录中保存的 Displaced Header；失败则说明发生竞争，转重量级解锁路径。轻量级锁的优势是在“短临界区、低冲突”场景下显著减少阻塞/唤醒的系统开销。3. 从 CAS 谈起：原理、内存语义与陷阱CAS（Compare-And-Swap/Exchange）是硬件提供的原子读-改-写指令族。以三元组 (V, A, B) 描述：当且仅当 V==A 时，将 V 置为 B；否则失败。Java 中的 CAS 主要通过 Unsafe/VarHandle 暴露：// Java 9+ VarHandle 示例class Counter {  private volatile int value;  private static final VarHandle VH;  static {    try {      VH = MethodHandles.lookup()          .in(Counter.class)          .findVarHandle(Counter.class, \"value\", int.class);    } catch (Exception e) { throw new Error(e); }  }  public int increment() {    int prev;    do {      prev = (int) VH.getVolatile(this);    } while (!VH.compareAndSet(this, prev, prev + 1));    return prev + 1;  }}3.1 内存语义不同于“互斥”，CAS 主要提供“原子性 + 指定的有序性”。HotSpot 在不同平台下映射为：  x86（TSO）：天然提供较强顺序性，LOCK CMPXCHG 隐含 acquire-release 语义；必要时配合 LFENCE/SFENCE/MFENCE。  ARMv8：使用 LL/SC 族指令 LDAXR/STLXR（带 acquire/release 语义）与 DMB ish 栅栏保证有序性。Java 语言层面，volatile 写具有“release”语义，读具有“acquire”语义；CAS 通常等价于“读-改-写的原子性 + acquire-release”。这保证了临界区内写入对随后持有同一变量可见。3.2 ABA 问题与对策CAS 的经典陷阱是 ABA：值从 A→B→A，单次 CAS 无法察觉变化。对策包括：  版本戳（如 AtomicStampedReference）、标记指针（AtomicMarkableReference）。  结构性约束（避免重用节点）、配合 GC 的安全点检查降低风险。3.3 多变量一致性CAS 天然只能覆盖单内存位置。多字段一致性可用：  粗粒度互斥（单锁包裹），简单可靠；  组合状态编码（如将两字段打包到 64 位 long）；  STM/事务日志（较重，工程中少见）。4. Lock 与 AQS：CLH 队列、独占/共享与条件队列AQS（AbstractQueuedSynchronizer）是 ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock、StampedLock（部分实现）等的基础设施。其核心是：  一个 int state 表示同步状态（独占/共享语义由子类定义）；  一个基于 CLH 的双向 FIFO 同步队列，失败线程入队并 park；  成功释放时按队头顺序 unpark，维持有界公平性。4.1 独占与共享  独占（Exclusive）：如 ReentrantLock。tryAcquire/tryRelease 由子类实现；重入通过把 state 作为重入计数。  共享（Shared）：如 Semaphore、CountDownLatch。共享获取可同时唤醒多个等待者。4.2 公平 vs 非公平Lock fair = new ReentrantLock(true);Lock unf  = new ReentrantLock(false);  公平：严格遵循队列顺序，等待时间方差小，但吞吐稍低；  非公平：允许插队（tryAcquire 先试一次），吞吐更高，极端情况下存在饥饿风险。4.3 条件队列（Condition）ConditionObject 为每个条件维护独立等待队列：  await()：原子地释放主锁、入条件队列并 park；  signal()：将条件队列的首节点转移回同步队列，等待重新竞争主锁。4.4 AQS 获取/释放（独占）骨架1) 快路径：CAS 修改 state 成功直接获得；2) 失败入队：按 CLH 入同步队列，park 自己；3) 被前驱释放 unpark 后，竞争重试；4) 释放：tryRelease 成功则唤醒后继。5. 平台与汇编视角：x86 与 ARM 的差异5.1 x86（TSO）  原子指令：LOCK XCHG/CMPXCHG/ADD 等，LOCK 前缀保证跨核原子性与缓存一致性协议的正确传播。  自旋优化：热点代码会插入 PAUSE（rep; nop）降低功耗与总线竞争。  内存模型：TSO 比 Java 的 JMM 更强，编译器仍需在 volatile/CAS 周边插入恰当屏障以维持 JMM 语义。5.2 ARMv8（弱内存序）  LL/SC：LDXR/STXR，带 acquire/release 版本 LDAXR/STLXR；失败返回标志，需循环重试。  内存屏障：DMB ish/DSB/ISB 控制可见性与排序。  Java 映射：VarHandle 的 acquire/release 泛化到上述指令与屏障组合。6. 不同锁形态的应用场景与选型  synchronized：          优点：语法简单，异常安全，JIT 内联友好；JDK 近年大量优化，开销显著下降。      适用：绝大多数互斥场景，特别是短临界区、低到中等竞争强度。        ReentrantLock：          优点：可中断、可定时、可选公平，配 Condition 多条件队列，诊断性更强。      适用：                  需要可中断获取（避免死等 IO）；          需要定时超时放弃；          需要多个条件队列；          需要公平策略限制尾延时。                      ReentrantReadWriteLock：          读多写少、读路径可并行；注意“读锁降级、写锁升级”的语义与死锁风险。        StampedLock：          乐观读避免锁竞态下的写者阻塞；需要二次校验，且不支持重入/条件队列，使用门槛更高。        CAS/无锁结构：          原子类（Atomic*）、LongAdder/LongAccumulator（热点分散）在高并发计数上优于单点 CAS；      适用读多写少或对延迟极敏感的路径；需警惕 ABA 与活锁，必要时退避回退或限次自旋转阻塞。      7. 性能与可见性：几个常见问题  自旋与阻塞的取舍：          临界区短、竞争偶发：倾向自旋（轻量级锁）；      临界区长、竞争激烈：尽快阻塞，减少 CPU 浪费与抖动（重量级路径/AQS 直接 park）。        假共享（False Sharing）：          计数热点应使用 LongAdder 或通过 @jdk.internal.vm.annotation.Contended（或手工填充）隔离写热点，避免不同核心在同一 cache line 争用。        粗细粒度：          业务上首先拆分为“无共享”的并行单元；无法拆分时，优先读写分离、分段锁/哈希分片；确需全局一致时再集中化。        可见性与发布：          共享数据通过 volatile/CAS/锁保护发布；避免未初始化对象逸出；      使用 final 字段保证构造后安全发布的不可变性。      8. 代码片段与基准示例8.1 synchronized 与 ReentrantLock 对比// synchronized 版class CounterS {  private int x;  public synchronized void inc() { x++; }  public synchronized int get() { return x; }}// ReentrantLock 版（可中断/可定时）class CounterL {  private final ReentrantLock lock = new ReentrantLock();  private int x;  public void inc() {    lock.lock();    try { x++; } finally { lock.unlock(); }  }  public int get() {    lock.lock();    try { return x; } finally { lock.unlock(); }  }}8.2 LongAdder 抗热点计数LongAdder adder = new LongAdder();// 并发线程直接 add，内部分片累加，读时汇总adder.add(1);long sum = adder.sum();8.3 读写锁与条件队列class RWCache&lt;K,V&gt; {  private final ReentrantReadWriteLock rw = new ReentrantReadWriteLock();  private final Map&lt;K,V&gt; map = new HashMap&lt;&gt;();  public V get(K k){    rw.readLock().lock();    try { return map.get(k);} finally { rw.readLock().unlock(); }  }  public void put(K k, V v){    rw.writeLock().lock();    try { map.put(k, v);} finally { rw.writeLock().unlock(); }  }}9. 调优与诊断建议  观测与基准：          JFR（Java Flight Recorder）采集阻塞/等待事件（Java Monitor Blocked、Thread Park）。      Async-profiler 观察 CPU 自旋热点、Unsafe.park 栈分布。      微基准使用 JMH，控制预热、线程数与绑定策略（pin 线程）。        编译与运行参数（按需验证，不做一刀切）：          -XX:+UseSpinWait：在部分 CPU 上更友好的自旋指令（如插入 PAUSE）。      -XX:PreBlockSpin（旧参数，现代 JDK 多已调整）：阻塞前自旋次数。      公平锁仅在尾延迟敏感时启用，常规吞吐优先用非公平。        架构相关注意：          x86 上一般更容易获得稳定低抖动的 CAS 行为；      ARM 上注意弱内存序引入的可见性问题，尽量通过 volatile/VarHandle 语义化实现并行算法。      10. 关键要点回顾  锁信息存放在对象头的 Mark Word 中，随状态复用位段：无锁/轻量级/重量级（偏向锁在新 JDK 中已禁用/移除）。  CAS 是无锁算法基石，提供原子性与 acquire-release 有序性，但需防范 ABA、活锁与高冲突热点。  AQS 以 CLH 队列串联失败线程，统一提供独占/共享与条件队列，支撑 ReentrantLock/Semaphore/CountDownLatch 等。  x86 与 ARM 的实现差异主要体现在原子指令与内存屏障上，JVM 屏蔽了差异以兑现 JMM 语义。  工程选型优先简单与稳定：能用 synchronized 就别过早引入复杂锁；计数热点用 LongAdder；高争用尽量结构化拆分，而不是盲目自旋。附：进一步阅读  Java Language Specification（JLS）与 Java Memory Model（JMM）章节  Doug Lea：AQS 源码与论文  OpenJDK JEP 374：Disable and deprecate biased locking（JDK 15）  Java Concurrency in Practice（JCIP）11. JIT 与锁优化：逃逸分析、锁消除、锁粗化  逃逸分析（Escape Analysis）：JIT 判断对象是否只在当前线程可见。若“未逃逸”，可进行标量替换、栈上分配，并消除不必要的同步。  锁消除（Lock Elision）：当 JIT 确认同步对象只在单线程上下文使用时，移除 synchronized/轻量级锁操作。  锁粗化（Lock Coarsening）：当热点循环中频繁短暂加解锁时，JIT 会把多次锁合并到更外层，降低加解锁频率与内存屏障开销。  自适应自旋（Adaptive Spinning）：JVM 依据历史竞争状况与持锁线程运行状态动态调整自旋时长（结合 park 切换），避免盲目自旋或过早阻塞。工程建议：  不要刻意将很多微小操作拆成多个极短的同步块，给 JIT 锁粗化留下空间；  热路径上的锁对象尽量局部化，利于逃逸分析与消除。12. AQS 的 Node 与 waitStatus 详解AQS 同步队列是双向链表（近似 CLH 的变体），核心节点字段：static final class Node {  // 等待状态：  //  1 CANCELLED（已取消）  // -1 SIGNAL（前驱释放时需要唤醒本节点）  // -2 CONDITION（在条件队列中）  // -3 PROPAGATE（共享模式传播）  volatile int waitStatus;  volatile Node prev, next;  volatile Thread thread;  // 标记独占/共享模式  static final Node SHARED = new Node();  static final Node EXCLUSIVE = null;}关键机制：  失败线程 CAS 入队，前驱的 waitStatus 置为 SIGNAL，当前驱释放时 unpark 后继；  取消（超时/中断）节点会被链路跳过，保持队列健康；  共享模式释放时使用 PROPAGATE 以继续唤醒后继共享获取者（如 Semaphore）。13. JMM 内存屏障与 happens-before 速查  程序次序规则：同一线程内，语句按程序顺序 hb。  监视器锁：解锁 hb 于后续对同一锁的加锁。  volatile：对同一变量的写 hb 于后续读。  线程启动：Thread.start() 之前的操作 hb 于 run() 内。  线程终止：线程内操作 hb 于检测到其终止（join/isAlive 返回 false）。  中断：interrupt() 先行于被中断线程检测到中断（isInterrupted/InterruptedException）。  final 字段：构造函数对 final 字段的写 hb 于其他线程看到该对象引用后的读。内存屏障类别（抽象到硬件）：  LoadLoad, LoadStore, StoreStore, StoreLoad（其中 StoreLoad 最强，常在释放-获取边界上出现）。14. 常见并发坑与对策  双重检查锁（DCL）缺 volatile：实例引用未发布完全可见，务必对实例引用使用 volatile 或改用静态初始化。  锁顺序不一致导致死锁：为多资源加锁规定全局顺序，或使用 tryLock 带超时与回退策略。  条件丢失与虚假唤醒：await() 后必须用 while 重新检查条件，不要用 if。  吞掉中断：捕获 InterruptedException 后应恢复中断位或按语义处理，避免“中断失效”。  读写混用容器：高并发下不要在无保护的 ArrayList/HashMap 上写入；使用并发容器或外部锁。  误用 notify()：多条件/多消费者模型优先用 Condition，或使用 notifyAll() 的同时配合条件判断。15. 基准与测试建议  JMH 微基准：          使用 @State 控制共享程度；      充分预热（@Warmup）与多次迭代（@Measurement）；      使用 Blackhole 消除 DCE；      设定不同的并发度（@Threads）和绑定策略（避免线程迁移）。        生产观测：          打开 JFR 事件（Monitor Blocked、Thread Park、Java Monitor Wait）；      使用 async-profiler 结合 -e lock/-e cpu 观察竞争与自旋热点；      采集等待时间分布（P50/P95/P99）而非仅均值。      16. OS 原语映射与实现细节  Linux：park/unpark → futex(FUTEX_WAIT/FUTEX_WAKE)；内核调度与优先级反转可能影响尾延迟（Java 层无优先级继承）。  macOS：基于 pthread 互斥量/条件变量；休眠/唤醒路径与时钟源会影响超时精度。  Windows：现代实现可映射到 WaitOnAddress/Slim Reader-Writer（SRW）等原语。结论：不同 OS 的调度策略与时钟、唤醒延迟差异会影响 AQS/Monitor 的尾延迟特征，服务端 SLO 设计需留冗余。17. 选型与落地清单（Checklist）  同步原语选择：          首选 synchronized，需要可中断/多条件/定时再用 ReentrantLock；      读多写少：ReentrantReadWriteLock 或 StampedLock（谨慎使用）；      计数热点：LongAdder 优于单点 AtomicLong；      信号量/门闩：Semaphore/CountDownLatch，或升级 Phaser。        结构性优化：          尽量无共享或分片（sharding）；      降低持锁时间（IO/阻塞移出临界区）；      缓存与批处理减少锁竞争频率。        诊断运维：          监控阻塞时长与争用次数；      采集线程栈与锁持有者；      压测覆盖极端并发与抖动场景。      "
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/java/2017/04/09/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8ESPI%E6%9C%BA%E5%88%B6%E5%AE%9E%E8%B7%B5.html",
    "title": "Java 类加载器与 SPI 机制实践",
    "content": "本文系统梳理 Java 虚拟机的类加载流程、双亲委派模型与命名空间隔离，深入解析 SPI（Service Provider Interface）在容器与插件化架构中的使用要点与常见坑，并结合字节码增强与 Java Agent 的实践串联起类加载与运行期增强这一条主线，帮助你在工程中进行正确的架构取舍与问题诊断。0. 你为什么需要关心类加载与 SPI  定位复杂 ClassNotFoundException / NoSuchMethodError / LinkageError：多数与类加载边界和版本冲突相关。  搭建插件化平台与多租户隔离：自定义 ClassLoader 能在一进程内提供清晰的依赖边界与热插拔能力。  正确使用 SPI、JDBC、JNDI、日志门面：都依赖 ServiceLoader + 线程上下文类加载器（TCCL）。  运行期增强与诊断：AOP、性能探针、日志埋点、线上热修复都离不开字节码增强与 Java Agent。1. JVM 类加载全流程与命名空间JVM 将一个 .class 从“字节序列”变为可执行的类元数据，经历如下阶段：1) 加载（Loading）  读取字节流，形成 Class 对象的初始结构，确定其“定义加载器”（Defining ClassLoader）。2) 链接（Linking）  验证（Verification）：字节码结构合法性与安全检查。  准备（Preparation）：为静态字段分配内存并设零值。  解析（Resolution）：将符号引用解析为直接引用（可能懒解析）。3) 初始化（Initialization）  执行 &lt;clinit&gt; 静态初始化块，真正赋初值，保证线程安全一次性执行。类由某个 ClassLoader 定义后会进入该加载器的“命名空间”。同名类在不同命名空间是“不同的类”，这也是很多跨 ClassLoader 转型失败、方法找不到的根源。1.1 双亲委派模型（Parent Delegation）标准的类加载器层次：  Bootstrap ClassLoader（C/C++ 实现，加载核心类库）  Platform/Extension ClassLoader（加载平台扩展）  Application ClassLoader（加载应用 classpath）  自定义 ClassLoader（可作为子层）委派过程：loadClass 先委派给父加载器；父找不到（抛 ClassNotFoundException）才回落到子加载器自己加载。优势：  安全：防止用户代码伪造 java.lang.* 等核心类。  共享：上层定义一次，全局共享，减少重复加载与内存浪费。什么时候“打破”或“变形”委派：  容器隔离与热部署：如 Tomcat、OSGi、插件化框架会采用“先本地后父类”或双亲/并行策略以实现隔离与覆盖。  SPI 与 TCCL：JDK 某些 API 通过“线程上下文类加载器”来绕过严格的父委派边界。1.2 Class 等价性与常见异常  同名类如果由不同 ClassLoader 定义，则 clazzA != clazzB，即使字节码完全相同。  典型异常：          ClassCastException: X cannot be cast to X（两个 X 来自不同加载器）；      NoSuchMethodError/NoSuchFieldError（版本不一致）；      LinkageError: loader constraint violation（同名类被不同加载器以不同版本解析）。      工程建议：跨边界交互使用稳定的“数据结构或接口”包由公共上层加载器定义；不同插件内部类不外泄。2. 自定义 ClassLoader：隔离、覆盖与热插拔典型目标：  为每个业务域/插件创建独立的依赖边界（避免 jar 冲突）。  支持插件卸载与升级（释放旧 ClassLoader，让类与资源可被 GC 回收）。最小可用实现思路：public class IsolatedClassLoader extends ClassLoader {  private final Map&lt;String, byte[]&gt; classNameToBytes;  public IsolatedClassLoader(Map&lt;String, byte[]&gt; classNameToBytes, ClassLoader parent) {    super(parent);    this.classNameToBytes = classNameToBytes;  }  @Override  protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {    byte[] bytes = classNameToBytes.get(name);    if (bytes == null) throw new ClassNotFoundException(name);    return defineClass(name, bytes, 0, bytes.length);  }}说明：  仅覆盖 findClass，仍保留“父优先”委派，以保证核心类安全。  需要自管资源获取与依赖链；若要“先本地后父类”，可在 loadClass 中调整策略，但务必限制可覆盖的包前缀（如只允许 com.example.plugins.*）。释放资源：卸载插件时断开对 ClassLoader 的所有强引用（包括线程、定时器、缓存、ThreadLocal、JNI 句柄等），否则类与字节码无法回收。3. SPI（Service Provider Interface）原理与实战SPI 的核心在于“调用方依赖接口，运行期按需装配实现”。JDK 提供 java.util.ServiceLoader，通过读取 META-INF/services/&lt;接口全名&gt; 文件完成发现。3.1 基本使用文件布局：  接口：com.example.spi.Storage  实现类：com.example.spi.impl.LocalStorage, com.example.spi.impl.S3Storage  声明文件：META-INF/services/com.example.spi.Storage          内容：                  com.example.spi.impl.LocalStorage          com.example.spi.impl.S3Storage                    代码：public interface Storage { void write(String key, byte[] data); }ServiceLoader&lt;Storage&gt; loader = ServiceLoader.load(Storage.class);for (Storage s : loader) {  s.write(\"k\", new byte[0]);}工作机制：  ServiceLoader 默认使用当前线程的 TCCL（Thread.currentThread().getContextClassLoader()）读取 META-INF/services。  若 TCCL 为空，则回退到 ServiceLoader 自身的加载器。3.2 容器与多 ClassLoader 环境的坑  在应用服务器、微服务框架、插件系统中，接口与实现往往位于不同加载器。若 TCCL 未指向“实现所在加载器”，会出现找不到实现的情况。  解决：在调用前设置合适的 TCCL，或使用 ServiceLoader.load(接口, 实现所在的ClassLoader) 显式指定。ClassLoader implLoader = pluginClassLoader; // 实现所在加载器ServiceLoader&lt;Storage&gt; loader = ServiceLoader.load(Storage.class, implLoader);常见依赖 SPI 的组件：JDBC 驱动加载、JUL Logging, JAXP, JSON-B/JSON-P、JCA、JDBC-URL 自动发现、SLF4J 的服务桥接等。排查相关问题时优先检查 TCCL 与 META-INF/services。3.3 与模块化（JPMS/OSGi）的关系  JPMS：在 module-info.java 中通过 uses/provides ... with ... 显式声明服务使用与提供；跨模块访问受导出规则约束。  OSGi：每个 Bundle 本质是独立 ClassLoader，导出/导入包决定可见性。SPI 文件通常需要打包到导出的资源路径，并确保上下文加载器在正确的 Bundle。工程建议：  为公共接口单独建“API 模块”由上层加载器加载；实现各自打包并在需要时通过 SPI 或容器注册方式装配。  避免将实现类泄漏到 API 包或公共加载器，减少“二义性解析”。4. 从 AOP 到字节码增强：把“加载时”与“运行时”串起来动态代理与 AOP 是“增强”的入口：  JDK 代理基于接口；CGLIB 基于子类；都属于“对象层”的拦截。  字节码增强则直接在“类定义层”改写方法体或插桩，覆盖更广（无接口限制）且可零侵入接入现有代码。增强的时间点：  编译期：借助 javac 插件或 Gradle/Maven 插件处理字节码（如 Lombok、MapStruct）。  加载期：通过 Instrumentation 的 ClassFileTransformer 在类被 JVM 定义前改写；  运行期：Attach 到目标 JVM，retransform/redefine 已加载类。常用类库与对比：  ASM：指令级 API，最灵活也最底层，性能最好，学习曲线陡峭。  Javassist：以“源码字符串/表达式”方式组装，易用性高，适合快速原型。  Byte Buddy：类型安全的 Fluent API，生态完善（与 Agent、Mockito、Android 兼容性好）。5. Java Agent 实战速览（加载期与运行期）5.1 预主代理（premain）：随进程启动MANIFEST.MF：Premain-Class: com.example.agent.DemoAgentCan-Redefine-Classes: trueCan-Retransform-Classes: trueAgent：public class DemoAgent {  public static void premain(String args, Instrumentation inst) {    inst.addTransformer(new TimingTransformer(), true);  }}Transformer（以 Byte Buddy 为例）：public class TimingTransformer implements ClassFileTransformer {  @Override  public byte[] transform(Module module, ClassLoader loader, String className,                          Class&lt;?&gt; classBeingRedefined, ProtectionDomain pd,                          byte[] classfileBuffer) {    if (className == null || !className.startsWith(\"com/example/service/\")) return null;    // 使用 ASM/Javassist/Byte Buddy 改写方法体，插入计时代码    // 返回新的字节码；返回 null 表示不改写    return enhance(classfileBuffer);  }}启动：java -javaagent:demo-agent.jar -jar app.jar5.2 运行期 Attach：无重启注入MANIFEST.MF：Agent-Class: com.example.agent.DemoAgentCan-Redefine-Classes: trueCan-Retransform-Classes: trueAgent：public class DemoAgent {  public static void agentmain(String args, Instrumentation inst) {    inst.addTransformer(new TimingTransformer(), true);    for (Class&lt;?&gt; c : inst.getAllLoadedClasses()) {      if (c.getName().startsWith(\"com.example.service\")) {        try { inst.retransformClasses(c); } catch (Exception ignore) {}      }    }  }}Attach 到目标进程：VirtualMachine vm = VirtualMachine.attach(\"&lt;pid&gt;\");vm.loadAgent(\"/path/demo-agent.jar\");vm.detach();要点与限制：  redefine/retransform 不能随意更改已加载类的结构（如新增/删除字段、方法签名变化），通常仅能改写方法体。  性能与稳定性优先：过滤目标类与方法范围；避免在 Transformer 中做 I/O 或重计算。  安全与合规：生产注入需严格审批与审计；避免收集敏感数据；为回滚预留“撤销增强”的能力。实践场景：  无侵入埋点与链路追踪、慢调用采样、SQL/HTTP 出入口观测。  线上紧急诊断（打印入参/返回值/堆栈）、热点修复（谨慎使用）。  框架级特性（如 Spring AOP、ORM 懒加载）背后常用到字节码增强。6. 将类加载、SPI 与 Agent 串成一条“工程实践链”面对实际系统时，可以按以下 checklist 设计与排错：  类加载边界          定义“API 包”（接口与 DTO）由上层加载器加载；实现各自位于独立 ClassLoader；      插件只暴露接口，避免对外泄漏实现类；      谨慎采用“先本地后父类”的策略，并限制可覆盖包前缀；        SPI 装配          确保 META-INF/services/&lt;接口全名&gt; 存在且内容正确；      在容器/插件环境中使用正确的 TCCL 或显式传入实现加载器；      对多实现场景，建立可配置的选择策略（优先级、条件加载）；        诊断与增强          开发态：使用 Byte Buddy/Javassist 快速验证增强点；      生产态：以 Agent 注入，限定类集合，提供开关与回滚；      记录增强带来的额外开销，建立 SLO 告警；      7. 常见问题速查  为什么 ServiceLoader 在本地能找到实现，部署到容器后找不到？          检查 TCCL 是否指向实现所在加载器；容器可能切换线程或包裹执行；显式使用 ServiceLoader.load(接口, 加载器)。        X cannot be cast to X 但类名完全相同？          两个 X 分别由不同 ClassLoader 定义。收敛公共类型到 API 包；跨边界仅传递接口或数据类。        引入 Agent 后偶发死锁/卡顿？          Transformer 中做了 I/O/日志锁争用；或改写引入了同步膨胀。减少锁、避开热点方法、加采样率。        能否在运行期给类“加字段/加方法”？          受限于 JVM 的 redefinition 能力，一般不可以；需通过“旁路存储”（ConcurrentHashMap&lt;Class&lt;?&gt;, Data&gt;）、invokedynamic 或“代理包装”规避。      8. 结语类加载与 SPI 决定了“模块如何被看见与装配”，字节码增强与 Agent 决定了“模块在运行期如何被观测与改变”。把二者打通，既能写出可演化、可观测的系统，也能在复杂运行环境中快速定位问题、降低故障恢复时间（MTTR）。参考与延伸阅读  The Java Virtual Machine Specification（ClassFile 与指令集）  Byte Buddy、ASM、Javassist 官方文档  JDK java.util.ServiceLoader 源码与 META-INF/services 约定"
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/nginx/2017/02/13/Nginx-%E8%BF%9E%E6%8E%A5%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html",
    "title": "Nginx 连接复用与四层负载均衡",
    "content": "对比四层（stream）与七层（http）转发，从操作系统并发与 I/O 机制出发系统性说明：Nginx 的网络设计、连接复用原理与 Linux 内核调优，并附可执行配置与观测建议。1. 从操作系统角度看网络并发模型高并发网络服务的核心是“如何在有限 CPU/内存下同时处理大量连接”。关键是并发模型与 I/O 机制：  进程/线程模型：每连接一个进程/线程，易编程，但上下文切换与栈内存开销在 1k～10k 连接下迅速放大。  事件驱动模型（Reactor/Proactor）：少量线程管理海量非阻塞 fd，依赖内核事件通知。内核 I/O 通知机制：  select/poll：线性扫描，fd 数/开销受限，不适合高并发。  epoll（Linux）：O(1) 监听大量 fd，边缘/水平触发，EPOLLEXCLUSIVE 降低惊群。  kqueue（BSD/macOS）：高效通用事件队列。  IO_uring（Linux 新）：提交/完成队列，绕过部分系统调用开销；Nginx 主线仍以 epoll 为主。Reactor vs Proactor：Nginx 采用 Reactor（事件到来再发起 read/write），Windows 下的 IOCP 更接近 Proactor。常见瓶颈点：  fd 限制（ulimit -n、worker_rlimit_nofile、fs.file-max）。  监听/握手队列（somaxconn、tcp_max_syn_backlog、SYN flood）。  收发队列与网卡（netdev_max_backlog、RPS/RFS/XPS、队列/中断亲和）。  拥塞控制与队列管理（BBR、fq、TFO）。2. Nginx 的网络设计模型Nginx 采用 master + 多 worker 的事件驱动架构：  master：管理配置、热重载、worker 生命周期。  worker：每个 worker 一个事件循环，使用 epoll/kqueue 管理大量非阻塞连接；worker_processes auto; 通常与 CPU 核数一致。  连接与请求分离：一个连接可承载多个请求（HTTP/1.1 keepalive、HTTP/2 多路复用）。  accept 协调：accept_mutex 避免惊群；或 reuseport 让每个 worker 拥有独立监听套接字。  零拷贝与发送优化：sendfile、tcp_nopush、tcp_nodelay、aio threads。事件与监听示例：worker_processes  auto;worker_rlimit_nofile  1048576;events {  use epoll;               # Linux 下优先 epoll；macOS/FreeBSD 为 kqueue  worker_connections 65535;  multi_accept on;  # accept_mutex on;      # 与 reuseport 二选一}server {  listen 80 reuseport backlog=65535;  # listen 443 ssl http2 reuseport fastopen=512;}3. 连接复用：客户端、Nginx 与上游目标：减少握手与 TLS 开销、降低 TIME_WAIT 与端口消耗、提升吞吐。  客户端-&gt;Nginx：          HTTP/1.1 keepalive 串行复用      HTTP/2 多路复用并发流      HTTP/3（QUIC）在 UDP 上实现多路复用与 0-RTT        Nginx-&gt;上游：          upstream keepalive 将代理到上游的连接复用，显著降低后端握手压力      连接池为“每 worker 独立”，容量需乘以 worker 数      HTTP/1.1 与上游 keepalive：http {  upstream api_backend {    server 10.0.0.2:8080 max_fails=2 fail_timeout=10s;    keepalive 256;  # 每 worker 空闲长连接上限  }  server {    listen 80 reuseport backlog=65535;    keepalive_requests 10000;    keepalive_timeout  75s;    location / {      proxy_http_version 1.1;      proxy_set_header Connection \"\";      proxy_set_header Host $host;      proxy_connect_timeout 5s;      proxy_send_timeout    30s;      proxy_read_timeout    30s;      proxy_pass http://api_backend;    }  }}四层（stream）与上游：stream {  upstream mysql_backend {    server 10.0.0.1:3306 max_fails=2 fail_timeout=10s;  }  server {    listen 3306 reuseport backlog=32768;    proxy_connect_timeout 3s;    proxy_timeout        30s;    proxy_pass mysql_backend;  }}取舍提示：  上游存在会话亲和或连接态时，需配合一致性哈希/粘性策略，避免跨请求状态泄漏。  短连接/突发场景不宜给过大 keepalive 池，避免端口/内存占用。  数据库协议建议交由专业代理（ProxySQL、pgbouncer）做更精细的连接池与语句复用。    stream {upstream mysql_backend { server 10.0.0.1:3306 max_fails=2 fail_timeout=10s; }server { listen 3306; proxy_pass mysql_backend; }}      4. Linux 内核网络优化推荐基线（按环境渐进验证）：# /etc/sysctl.d/99-nginx-tuning.confnet.core.somaxconn = 65535net.core.netdev_max_backlog = 250000net.ipv4.tcp_max_syn_backlog = 65535net.ipv4.tcp_synack_retries = 2net.ipv4.tcp_syncookies = 1net.ipv4.ip_local_port_range = 10000 65000fs.file-max = 2097152net.ipv4.tcp_fin_timeout = 15net.ipv4.tcp_keepalive_time = 600net.ipv4.tcp_keepalive_intvl = 30net.ipv4.tcp_keepalive_probes = 5net.core.rmem_max = 134217728net.core.wmem_max = 134217728net.ipv4.tcp_rmem = 4096 87380 134217728net.ipv4.tcp_wmem = 4096 65536 134217728net.core.default_qdisc = fqnet.ipv4.tcp_congestion_control = bbrnet.ipv4.tcp_fastopen = 3Nginx 侧连接与 fd：worker_rlimit_nofile 1048576;events { worker_connections 65535; }注意事项：  tcp_tw_recycle 已移除，勿用；tcp_tw_reuse 收益有限，勿过度依赖。  过度缩短 tcp_fin_timeout 可致异常断流；以观测为准。  reuseport 与 accept_mutex 二选一；多核下普遍优先 reuseport。  网卡队列/中断亲和等需要硬件与驱动配合，谨慎变更。5. 观测与压测  Nginx：stub_status、$upstream_response_time 分位数、active/reading/writing 分布。  系统：ss -s、ss -ti、sar -n TCP,DEV、ethtool -S、/proc/net/netstat。  压测：wrk（HTTP/1.x）、h2load（HTTP/2/3）、iperf3（链路）。示例：wrk -t8 -c1024 -d60s --latency http://127.0.0.1/h2load -n 100000 -c 200 -m 100 https://127.0.0.1:443/6. 常用配置快照http {  sendfile on;  tcp_nopush on;  tcp_nodelay on;  keepalive_timeout 75s;  keepalive_requests 10000;  upstream api_backend { server 10.0.0.2:8080; keepalive 256; }  server {    listen 80 reuseport backlog=65535;    location / {      proxy_http_version 1.1;      proxy_set_header Connection \"\";      proxy_set_header Host $host;      proxy_pass http://api_backend;    }  }}7. 排错 Checklist  5xx 或 upstream timed out：核查后端与上游连接池、proxy_*_timeout、网络丢包。  连接拒绝或超时：检查 somaxconn/backlog、worker_connections、ss -lnt 中队列与监听状态。  TIME_WAIT/端口耗尽：扩大 ip_local_port_range 与上游 keepalive，排查异常关闭。  吞吐增长受限：核查 sendfile、tcp_nopush、NIC 队列、CPU 亲和与磁盘 I/O。"
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/php/2016/08/17/PHP-FPM-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%8C%87%E5%8D%97.html",
    "title": "PHP-FPM 性能调优指南",
    "content": "本文系统性梳理 PHP-FPM 在高并发与高性能场景下的完整优化路径：从 Linux 操作系统内核与网络栈、到 Nginx 与 PHP-FPM 的通讯方式与参数调优，再到 PHP 运行时与业务代码层面的最佳实践，并给出生产可落地的配置示例与故障排查清单。目标读者为正在建设或运营中大型 PHP Web 服务的工程师与架构师。读者收益  清晰的容量规划方法与关键监控口径（QPS、P95/P99、错误率、队列长度）；  一套可复用的 Linux 内核与网络栈调优清单；  PHP-FPM pm 模式与核心参数的取舍建议与安全边界；  OPcache/JIT、realpath cache、Composer 自动加载与 APCu 等在生产中的最佳实践；  业务代码性能“十项准则”与常见反模式清单；  标准化配置样例：sysctl、systemd、Nginx、FPM pool 与 OPcache。一、性能目标与测量口径在优化之前，先把“好”的定义固定下来。  指标分层：          应用端：QPS、TP95/TP99 响应时间、错误率、超时率；      资源端：CPU 使用率、上下文切换、内存使用与 page faults、网络丢包/重传、磁盘延时；      PHP-FPM 专属：/status 的 accepted conn、listen queue、idle/active processes、max children reached。        容量评估：          峰值并发估算：通过压测或生产监控得到单位请求平均 CPU 时间与内存峰值；      Little’s Law：( L = \\lambda \\times W )，队列长度与延迟直接相关；      过载保护：在上游（Nginx 或网关）设置合理的连接与请求排队上限，宁可快速失败，避免雪崩。      二、Linux 系统层调优（以现代 Linux 为主）面向 PHP-FPM 的系统调优主要围绕“文件句柄/进程数量”“网络连接队列与吞吐”“内存与 I/O”三个方面展开。2.1 文件句柄与进程限制  系统级：          fs.file-max 与 fs.nr_open 调高总句柄上限；      结合进程数量与连接数，预留 2～3 倍余量。        服务级：使用 systemd 覆盖 PHP-FPM 单元，设置 LimitNOFILE，并确保 TasksMax 足够大。# /etc/systemd/system/php-fpm.service.d/override.conf[Service]LimitNOFILE=1048576TasksMax=infinityDelegate=yessudo systemctl daemon-reloadsudo systemctl restart php-fpm2.2 CPU 与调度  保持 irqbalance 开启，避免中断集中到单核。  大流量场景可考虑为 Nginx 绑定少量核心、FPM 绑定其余核心，减少争用：# /etc/systemd/system/nginx.service.d/cpu.conf[Service]CPUAffinity=0-1# /etc/systemd/system/php-fpm.service.d/cpu.conf[Service]CPUAffinity=2-152.3 内存、THP 与 Swap  关闭或降低 Transparent Huge Pages（THP），避免不可预期的停顿：    echo never | sudo tee /sys/kernel/mm/transparent_hugepage/enabled        减小 Swap 干预：    sysctl -w vm.swappiness=10        关注 vm.overcommit_memory 与 OOM Killer 行为，容器化场景优先通过 cgroup/容器限制。2.4 网络栈与连接队列  增大 listen backlog 与队列，减少瞬时拥塞丢包：    sysctl -w net.core.somaxconn=65535sysctl -w net.core.netdev_max_backlog=250000sysctl -w net.ipv4.tcp_max_syn_backlog=262144        发送/接收缓冲区与窗口扩展：    sysctl -w net.ipv4.tcp_rmem=\"4096 87380 134217728\"sysctl -w net.ipv4.tcp_wmem=\"4096 65536 134217728\"sysctl -w net.core.rmem_max=134217728sysctl -w net.core.wmem_max=134217728        TIME_WAIT 管理：服务端配合长连接降低 TIME_WAIT 产生；谨慎使用 tcp_tw_reuse（新内核对服务端无效），不要依赖 tcp_tw_recycle（已移除）。  连接安全：确保 net.ipv4.tcp_syncookies=1 开启以应对 SYN flood。建议汇总到 /etc/sysctl.d/99-tuning.conf 并持久化。2.5 磁盘与 I/O  SSD 场景优先 mq-deadline 或 none 调度器；日志分区与数据分区独立；  调整 vm.dirty_background_ratio 与 vm.dirty_ratio 限制脏页冲刷对尾延迟影响。三、Nginx 与 PHP-FPM 通讯拓扑3.1 Unix Socket vs TCP  同机通讯优先 Unix Socket（更低开销），配置更简单；  跨机或容器网络必须使用 TCP；  配置 listen.backlog 与 Nginx fastcgi_connect_timeout/fastcgi_read_timeout 对齐，避免误判超时。3.2 Nginx FastCGI 关键项upstream php_backend {    server unix:/run/php-fpm/www.sock;    # TCP 场景可配置 keepalive，Socket 不需要}server {    location ~ \\.php$ {        include fastcgi_params;        fastcgi_pass   php_backend;        fastcgi_keep_conn on;           # 与 FPM 维持长连接        fastcgi_connect_timeout 1s;        fastcgi_send_timeout 5s;        fastcgi_read_timeout  5s;       # 视业务复杂度调整        fastcgi_buffers 32 32k;        fastcgi_buffer_size 64k;    }}四、PHP-FPM 关键参数与策略FPM 通过 Pool 管理工作进程。核心在 pm 模式与并发容量控制。4.1 pm 模式如何选  pm = static：固定进程数，最可预期，适合高负载稳定流量；  pm = dynamic：基于空闲/繁忙动态伸缩，线上最常见；  pm = ondemand：按请求惰性创建，适合低频/突发场景，冷启动成本较高。4.2 并发容量与内存估算  经验公式：pm.max_children = floor(可用内存 / 单进程RSS峰值)；  实测方法：          开启压测后观察 ps -o pid,rss,cmd -C php-fpm 或 /proc/&lt;pid&gt;/status；      以 P95 RSS 作为保守估计，并预留 15% 以上系统余量；      关注 max children reached，出现即表示进程池耗尽，需要增大 max_children 或优化单请求资源占用。      4.3 池配置示例（www.conf）[www]user = www-datagroup = www-datalisten = /run/php-fpm/www.socklisten.owner = www-datalisten.group = www-datalisten.mode = 0660listen.backlog = 65535pm = dynamicpm.max_children = 128pm.start_servers = 16pm.min_spare_servers = 16pm.max_spare_servers = 64pm.max_requests = 2000          ; 防止内存泄漏或碎片长期累积process_control_timeout = 10srequest_terminate_timeout = 10s ; 兜底中断超时请求request_slowlog_timeout = 3sslowlog = /var/log/php-fpm/slow.logcatch_workers_output = yesphp_admin_value[memory_limit] = 256Mphp_admin_value[error_log] = /var/log/php-fpm/www-error.logphp_admin_flag[log_errors] = on说明：  pm.max_requests 过小会增加进程重启开销，过大难以及时回收泄漏；  合理设置 request_terminate_timeout 与 request_slowlog_timeout，协同 Nginx fastcgi_read_timeout，保证故障可恢复；  多业务隔离：按应用拆分 pool，避免相互影响。4.4 状态页与健康检查pm.status_path = /statusping.path = /pingping.response = pong结合 Nginx 暴露只读管理端点，并以 Prometheus/StatsD 抓取指标。五、PHP 运行时：OPcache、JIT 与路径缓存5.1 OPcache 必备配置（生产）; /etc/php.d/10-opcache.iniopcache.enable=1opcache.enable_cli=0opcache.memory_consumption=256opcache.interned_strings_buffer=16opcache.max_accelerated_files=100000opcache.validate_timestamps=0        ; 生产禁用文件变更检查opcache.revalidate_freq=0opcache.save_comments=1opcache.fast_shutdown=1; 可选：文件缓存，容器内频繁重启时有价值; opcache.file_cache=/var/cache/php-opcache部署发布后务必 reload FPM 或使缓存失效，以加载新字节码。5.2 PHP 8 JIT（谨慎评估）Web I/O 密集型负载对 JIT 的收益有限。若要启用，建议：opcache.jit_buffer_size=64Mopcache.jit=1205   ; tracing JIT，适度激进上线前请通过基准压测与业务真实场景对比，确认稳定性与收益。5.3 realpath 与 include 优化realpath_cache_size=4096krealpath_cache_ttl=600避免在热路径做大量 file_exists()/is_file()，并减少动态 include。生产禁用 allow_url_fopen，降低 I/O 风险。六、业务代码性能最佳实践（FPM 模式）6.1 缓存分层  进程内缓存：APCu 存储热点小对象，适合只读配置/路由表。注意 FPM 进程间不共享；  分布式缓存：Redis/Memcached 缓存热点数据，设置合理过期与一致性策略；  页面与片段缓存：结合 Nginx proxy_cache 或应用内缓存，命中率优先。// APCu 示例：仅适合单进程内命中$key = 'hot_config_v1';$val = apcu_fetch($key, $ok);if (!$ok) {    $val = load_config_from_db();    apcu_store($key, $val, 300);}6.2 数据库与外部依赖  谨慎使用持久连接（PDO persistent），评估连接复用与连接泄漏风险；  统一定义客户端超时、重试与熔断策略，避免阻塞放大；  通过批量查询/写入降低往返（N+1 是性能天敌）。6.3 自动加载与 Composer  生产构建使用 composer dump-autoload -o -a，减少运行时扫描；  避免在热路径中动态组合类名或路径，提升 OPcache 命中效率；  若使用 APCu 优化 Composer autoload，可开启 apcu-autoloader：{  \"config\": {\"apcu-autoloader\": true}}6.4 代码层微优化与反模式  使用 isset($arr['k']) 替代 array_key_exists('k', $arr)；  循环中缓存 count($arr)；  字符串拼接优先 . 而非频繁 sprintf；  避免在热路径调用正则，改用更轻量的字符串函数；  控制异常用作流程分支的频度；  会话：使用 Redis Session，并开启 session.lazy_write=1、session.use_strict_mode=1；  降低全局状态与单例滥用，利于并发安全与测试。6.5 超时、降级与排队  为外部依赖设置严格超时（连接/读写）与预算；  为不可用下游提供读降级或本地兜底；  对突发流量采用限流与排队，保护 FPM 进程池。七、容量规划与发布策略  预估 pm.max_children 依据 P95 RSS 与可用内存，预留系统与 page cache 空间；  滚动发布：先下线流量（Nginx drain/权重降为 0），再 reload FPM，避免中断连接；  弹性扩缩：容器或虚机水平扩展往往优于单机“顶配”。八、监控、压测与故障排查8.1 监控建议  Nginx：请求率、状态码分布、upstream_response_time、队列/连接数；  FPM：/status 指标、max children reached 告警、慢日志采样；  系统：CPU 利用、软中断、上下文切换、TCP 重传/丢包、磁盘延迟；  应用：关键函数耗时分布与火焰图（XHProf/Blackfire/eBPF）。8.2 压测要点  区分冷/热缓存表现；  启用与生产一致的 OPcache/realpath/composer 优化；  采用阶段性压力递增与稳态长跑，观察尾延迟与 GC/重启行为。8.3 常用排查命令ss -lntp | grep php-fpmps -o pid,ppid,rss,pcpu,cmd -C php-fpmtail -f /var/log/php-fpm/www-error.logtail -f /var/log/php-fpm/slow.logjournalctl -u php-fpm -n 200 -fdmesg | egrep -i 'oom|killed'慢日志与火焰图结合能快速定位热点：先用慢日志发现可疑入口，再以火焰图拆解 CPU 时间。九、标准化配置样例9.1 sysctl（/etc/sysctl.d/99-tuning.conf）fs.file-max=2097152net.core.somaxconn=65535net.core.netdev_max_backlog=250000net.ipv4.tcp_max_syn_backlog=262144net.core.rmem_max=134217728net.core.wmem_max=134217728net.ipv4.tcp_rmem=4096 87380 134217728net.ipv4.tcp_wmem=4096 65536 134217728net.ipv4.tcp_syncookies=1vm.swappiness=109.2 systemd（Limit 与 CPU 绑定）[Service]LimitNOFILE=1048576TasksMax=infinityCPUAffinity=2-159.3 Nginx FastCGI 片段fastcgi_connect_timeout 1s;fastcgi_send_timeout 5s;fastcgi_read_timeout 5s;fastcgi_buffers 32 32k;fastcgi_buffer_size 64k;fastcgi_keep_conn on;9.4 FPM Pool 片段pm = dynamicpm.max_children = 128pm.max_requests = 2000request_terminate_timeout = 10srequest_slowlog_timeout = 3sslowlog = /var/log/php-fpm/slow.log9.5 OPcache 建议opcache.enable=1opcache.memory_consumption=256opcache.max_accelerated_files=100000opcache.validate_timestamps=0十、Checklist（上线前自查）  sysctl 已落盘，网络 backlog 与缓冲区放开；  systemd LimitNOFILE/TasksMax 生效；  Nginx 与 FPM backlog、超时与 keepalive 一致；  OPcache 命中率与内存占用达标；  FPM /status 指标健康、无 max children reached 持续告警；  慢日志与火焰图能力就绪；  压测覆盖冷/热缓存，尾延迟达标；  发布采用灰度/滚动，具备快速回滚。结语性能优化从来不是单点参数的“魔法值”，而是一条端到端的工程链路：系统内核提供足够的资源与稳态，Nginx 与 FPM 协同对齐超时与队列，OPcache/自动加载与路径缓存确保运行时轻量，业务代码以缓存为中心并控制外部依赖的不可控性。循着本文的方法论与配置清单，结合你们的业务负载画像与监控数据，才能得到真正可复制、可演进的高性能 PHP-FPM 生产实践。"
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/mysql/2016/04/12/MySQL-%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%83%AD%E7%82%B9%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8FID%E5%AE%9E%E8%B7%B5.html",
    "title": "MySQL 自增主键热点与分布式 ID 实践",
    "content": "在高并发写入场景下，InnoDB 的自增主键（AUTO_INCREMENT）会在聚簇索引上形成尾部写热点，导致插入抖动与间歇性锁等待。本文从 InnoDB 聚簇索引结构、插入缓冲、间隙锁协同等维度拆解热点成因，并给出分布式 ID 的落地实践与权衡。1. 聚簇索引与尾部写热点  InnoDB 的聚簇索引以主键排序存储，AUTO_INCREMENT 会将新记录追加到 B+Tree 右侧叶子。  高并发插入时，右侧叶子页存在锁竞争与页分裂放大，表现为插入 TPS 下降与 P95/P99 波动。CREATE TABLE orders (  id BIGINT PRIMARY KEY AUTO_INCREMENT,  user_id BIGINT NOT NULL,  amount DECIMAL(10,2) NOT NULL,  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,  KEY idx_user (user_id)) ENGINE=InnoDB;2. AUTO_INCREMENT 锁与并发  MySQL 5.7 之前，AUTO_INCREMENT 使用表级锁（不同模式）；8.0 之后改进为持久化计数器与更细粒度控制，但热点依旧存在。  插入批量提交（group commit）可缓解 WAL 压力，但右边界叶子页仍是竞争点。3. 方案对比  雪花算法（Snowflake）：时间戳 + 机房ID + 机器ID + 自增序列，单机内有序，跨机整体趋势递增。  数据库号段（Segment）：业务方一次申请号段，内存发号，落库更新游标，吞吐高但需要容灾与幂等。  Redis INCR：实现简单，单点需高可用（主从/哨兵/集群），序列漂移与冷启动需评估。            方案      顺序性      吞吐      复杂度      依赖                  AUTO_INCREMENT      强      中      低      MySQL              Snowflake      趋势递增      高      中      时钟、节点元数据              号段      趋势递增      极高      中      DB 持久游标              Redis INCR      强      高      低      Redis 可用性      4. 索引与二级索引代价  主键变长（如雪花 ID）会放大二级索引的指针大小（leaf 指向 PK），读放大明显。  建议：保持主键定长 BIGINT，避免 UUID(36) 直接做 PK，可用 BINARY(16) 存储 UUIDv1/v7。5. 可复现实验（sysbench + 尾部热点）# 1) 准备数据与表结构mysql -e \"DROP DATABASE IF EXISTS demo; CREATE DATABASE demo;\"mysql demo &lt; &lt;(cat &lt;&lt;SQLCREATE TABLE t_hot (  id BIGINT PRIMARY KEY AUTO_INCREMENT,  k  BIGINT NOT NULL,  v  VARCHAR(64) NOT NULL,  KEY idx_k(k)) ENGINE=InnoDB;SQL)# 2) 并发插入压测（64 线程，持续 120s）sysbench oltp_insert --mysql-db=demo --table-size=0 \\  --threads=64 --time=120 run# 3) 观察：# - performance_schema.events_waits_summary_global_by_event_name 中的锁等待# - information_schema.INNODB_METRICS 中的页分裂、btr_node_split对照改为雪花 ID（应用侧生成）并将 id 定长 BIGINT，重复压测，观察 TPS 与 P95 改善幅度。6. 源码走读要点（InnoDB）  btr0cur.cc：B+Tree 游标在右侧页插入与分裂路径；  trx0i_s.cc：自增计数器的持久化与并发控制；  log0write.cc：group commit 对日志刷盘合并的影响。关注点：右侧叶子页 latch 竞争、页分裂代价、secondary index 指针放大。7. 生产变更与回滚手册1) 灰度：在影子表启用新 ID 策略，双写比对一致性（ID 单调、越界、重复）。2) 切换：将业务写流量按 5%/20%/50%/100% 提升；监控写延迟、死锁、页分裂。3) 回滚：保留开关，出现异常立即退回 AUTO_INCREMENT；影子表数据对账。8. 观测指标基线  写延迟 P95/P99、QPS、redo fsync 次数；  btr_page_split、lock_time、待提交事务数；  二级索引大小增幅（变长 PK 带来的指针放大）。9. FAQ  雪花 ID 时钟回拨怎么办？          NTP + 单调时钟守护；回拨检测时暂停发号并降级到号段。        二级索引变大影响查询？          评估热点查询是否可走覆盖索引/缩短选择列；必要时引入只读副本。      "
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/golang/2015/11/02/Go-goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86GMP.html",
    "title": "Go goroutine 调度器原理：GMP",
    "content": "这篇文章不只是“是什么”，而是从语言设计动机与系统实现细节出发，系统性拆解 Go 调度器的三元模型：G（goroutine）、M（OS thread）、P（processor）。围绕“为什么要引入 GMP”“GMP 解决了什么问题”“有哪些代价与权衡”“如何直观理解并用实验证明”，我们给出多维度、可操作的深度解读。一、动机：Go 想解决什么问题？如果回到 2007–2009 年 Go 诞生的背景，Google 内部已经在大规模分布式系统中挣扎：  需要写高并发服务，却要在复杂的回调、线程与锁之间艰难取舍；  线程创建与上下文切换成本高，每个线程动辄 MB 级别栈内存；  I/O 与 CPU 混合型负载让“要么阻塞、要么回调”的模型两头不讨好；  C/C++ 缺少一等公民的并发原语，异步代码可读性差而且脆弱。Go 的答案可以浓缩为三点：  基于 CSP 的并发观：以 goroutine 与 channel 为一等公民，用“看起来可阻塞”的直观代码描述并发；  用户态调度器：把大量 goroutine 以 M:N 方式复用到少量 OS 线程上，降低成本并提升可伸缩性；  面向工程实战：自动栈增长、抢占、网络 poller、分配器与 GC 协同，提供“默认高效、按需可调”的体验。GMP 模型正是在这样的目标约束下诞生：既要“写起来像同步”，又要“跑起来像高性能异步”，还要“在多核机器上自然扩展”。二、设计思想：从 1:1 到 M:N，再到 P 的引入线程模型的历史谱系大致有三类：  1:1（每个用户线程映射一个 OS 线程）：实现简单，但创建/销毁、上下文切换和栈内存都昂贵；  N:1（绿色线程，全在用户态）：切换快，但无法利用多核，遇到系统调用就会整体阻塞；  M:N（用户态与内核态混合）：折中路线，但实现复杂，边界条件众多。Go 选择 M:N，但早期只存在 G 和 M，很快遭遇扩展性与缓存局部性问题：多个 M 抢同一把全局锁从全局 run queue 取任务，导致抖动。Go 1.1 引入 P（processor）作为“执行 goroutine 的逻辑 CPU 配额与本地 run queue”，解决两个核心痛点：  把就绪 G 分散到 P 的本地队列，提升缓存命中并减少锁竞争；  通过 work stealing 在 P 之间均衡负载，避免个别 P 饥饿。因此，GMP 的真实目标不是“多一个字母”，而是让“可伸缩的用户态调度”成为现实。三、模型总览：G、M、P 分工与数量关系  G（goroutine）：用户态轻量执行单元，拥有栈（可动态增长）、状态（就绪/运行/阻塞/等待）与入口函数。  M（machine/OS thread）：真实的内核线程，负责执行 G 的载体。M 必须绑定一个 P 才能运行 Go 代码；无 P 的 M 只能执行 syscalls 或处于空闲。  P（processor）：调度器中的“核”和本地运行队列，数量等于 GOMAXPROCS。每个 P 维护 run queue、runnext 插槽、定时器等。典型约束：  同一时刻最多有 GOMAXPROCS 个 M 持有 P 并并行执行 Go 代码；  G 的创建很廉价，调度器倾向把新 G 放入当前 P 的 run queue；  无事可做的 P 会从全局队列或其他 P 窃取 G（work stealing）。四、调度循环：一条 G 的旅程1) 创建/就绪：go f() 创建 G，优先放进当前 P 的本地队列；2) 取出与执行：持有该 P 的 M 从 run queue 取 G，放到寄存器与栈上开始执行；3) 阻塞分流：  如果 G 调用 syscall/cgo 进入内核阻塞，M 也会阻塞；调度器把“被困”的 P 转借给其他空闲的 M，以保证 GOMAXPROCS 并行度；  如果 G 因 channel/锁/I/O 等用户态阻塞，M 让出当前 G，切回调度器，从本地队列或其他 P 继续取活；  网络 I/O 由 netpoller（epoll/kqueue/IOCP）负责等待并唤醒相关 G；4) 抢占与让出：  协作式：函数 prologue 设置安全点，允许在调用边界被切走；  异步抢占（Go 1.14 起）：runtime 可向线程注入信号，在抢占安全点强制把 G 让出，避免大计算长期独占；5) 完成与回收：G 正常返回或 panic 结束后，M 继续从队列取下一个 G。五、关键机制详解5.1 本地队列、全局队列与 runnext  本地队列：每个 P 维护一个环形队列，push/pop 均无锁或轻锁；  全局队列：系统级备用队列，多个 P 在饥饿时会从中批量拉取；  runnext：为提升缓存命中，调度器保留“下一个立刻运行”的插槽（如 go ready 刚唤醒的 G）。5.2 Work Stealing当某个 P 的队列耗尽，会从全局队列或随机挑选另一个 P 窃取一半任务（按块移动），在保持均衡的同时减少锁冲突。该策略在大规模 goroutine 场景下显著降低尾延迟。5.3 系统调用与 M/P 解耦对于可能长时间阻塞的内核调用：  进入 syscall 前记录状态；  M 进入内核后若长时间不返回，调度器将其 P 迁出给其他可运行的 M；  当 syscall 返回，若原 P 已被转移，则尝试从全局获取 P 或把 G 放回队列等待调度。5.4 NetpollerGo 的网络库用平台相关的 poller 将“看似阻塞的 Read/Write”转为“注册事件 + 等待唤醒”。当事件就绪，poller 把对应 G 标记为 runnable，放回某个 P 的队列。这是“看似同步、实则异步”的关键一环。5.5 抢占：从协作到异步早期 Go 主要依赖协作式抢占，即在函数调用边界（safe point）让出。对于紧密循环或内联后的长计算，可能长时间不让出，导致延迟抖动。Go 1.14 引入异步抢占：  runtime 向执行线程注入抢占信号；  在线程到达可抢占的安全点（如栈检查、轮询点）时挂起 G，切回调度器；  减少“计算型 goroutine”对系统的拖滞，提升吞吐与 P99 延迟。5.6 栈管理goroutine 使用“连续可增长栈”，初始很小（KB 级），随着深度增长按需扩容（拷贝并修正栈指针）。这使得创建百万 goroutine 成为可能，也与调度器的轻量切换协同增效。5.7 与 GC 的协作调度器与 GC 紧密耦合：  标记辅助（mutator assist）在分配压力大时让运行的 G 协助标记；  写屏障保证并发标记期正确性；  STW 窗口尽量缩小，但仍需要在世界停止时统一栈扫描与根收集；  抢占点也服务于 GC 对“尽快看到所有栈”的诉求。5.8 系统监控线程（sysmon）后台监控 goroutine/线程状态、定时器、抢占信号、垃圾回收触发等，是调度系统“保安 + 协调员”。六、GMP 解决了哪些实际问题？  低成本并发原语：创建/销毁 goroutine 成本远低于线程，栈按需增长；  多核可伸缩：GOMAXPROCS 决定并发执行 goroutine 的上限，通过 P 的本地队列与 stealing 在多核扩展；  同步代码风格的高性能 I/O：netpoller 让“看起来阻塞”的 API 拥有“异步性能”；  更好地处理混合负载：系统调用阻塞与用户态阻塞分流，保持整体吞吐；  可观测性与可调优：pprof、trace、schedtrace 等工具帮助定位性能瓶颈与调度异常。七、权衡与潜在弊端  实现复杂度高：调度器、GC、分配器、netpoller 的耦合提升了 runtime 复杂性与维护难度；  尾延迟与公平性：尽管有抢占与 stealing，极端负载下仍可能出现饥饿或抖动；  syscall/cgo 交互成本：频繁进入内核或调用 C 代码，会触发 P 迁移/线程增减，影响稳定性与预测性；  G 泄漏更隐蔽：看似阻塞的 goroutine 更容易“被遗忘”，如未消费的 time.After、无界 channel；  调参误区：盲目调大 GOMAXPROCS 可能加剧锁竞争与切换开销，未必提升吞吐；  平台细节差异：netpoller 依赖 epoll/kqueue/IOCP，不同平台边界行为可能不同。八、如何直观理解：一个工厂的类比把 P 想象成“装配线”，M 是“工人”，G 是“待加工的零件”：  每条装配线（P）有自己的待加工队列（本地 run queue），减少不同线之间的争抢；  工人（M）必须绑定一条装配线才能干活；  如果某条线不饱和，工人会去别的线“偷”一半零件回来（work stealing）；  遇到需要外部检验（syscall）时，工人要暂时离开车间，但这条线会很快分配给另一名工人，保证机器不停；  车间主任（sysmon）偶尔会打断某个工人，防止他在一个零件上磨蹭太久（异步抢占）。一个近似的 ASCII 示意：P0(runq) ←→ M0  执行 G...P1(runq) ←→ M1  执行 G...P2(runq) ←→ M2  执行 G...       ↖ stealing ↗   全局队列 / netpoller 唤醒九、实验：观察 GOMAXPROCS 与调度行为下面的程序用递归 fib 制造 CPU 压力，观察不同 GOMAXPROCS 的吞吐变化（实际结果取决于机器核数与调度器负载）。package mainimport (  \"runtime\"  \"sync\"  \"time\"  \"fmt\")func fib(n int) int { if n &lt; 2 { return n }; return fib(n-1)+fib(n-2) }func main() {  for _, p := range []int{1,2,4,8} {    runtime.GOMAXPROCS(p)    var wg sync.WaitGroup    start := time.Now()    for i := 0; i &lt; 100000; i++ {      wg.Add(1)      go func(){ _ = fib(20); wg.Done() }()    }    wg.Wait()    fmt.Println(\"P=\", p, \"cost=\", time.Since(start))  }}观察调度轨迹：GODEBUG=schedtrace=1000,scheddetail=1 ./app# 也可打开 pprof：# go tool pprof -http=:0 http://localhost:6060/debug/pprof/profile示例：对“长计算不让出”的可观测性（Go 1.14 前后对比思路）：// 紧密循环若无函数调用，旧版本更难被协作式抢占，// 新版的异步抢占可显著改善系统整体延迟。func busyLoop(deadline time.Time) {  for time.Now().Before(deadline) {    // 做一些计算  }}十、可观测性：trace/pprof/schedtrace 看什么  schedtrace：周期打印 P/M/G 的数量、全局/本地队列长度、spinning 线程数，快速判断是否存在饥饿或过度抢占；  pprof：          CPU profile 看热点函数与调度器开销；      Block profile 观察 channel/互斥等待；      Mutex profile 关注 runtime 锁与业务锁竞争；        go tool trace：时间轴上展示 G 的生命周期变化、网络事件与 syscalls，更直观地定位抖动来源。十一、实战建议与反模式  合理设置 GOMAXPROCS：通常默认即可。CPU 密集场景接近物理核心数；过大只会带来锁竞争与切换成本；  避免无界 goroutine：对输入做限流，用 worker pool 或 errgroup；  小心 time.After 泄漏：未读取的计时器会保留 G；可改用 time.NewTimer 并 Stop；  处理 syscall/cgo：尽量缩短阻塞时间，必要时隔离到专用池或进程；  使用 context 超时/取消：避免永久阻塞 goroutine；  明确选择 channel 与 mutex：小临界区用锁更直白，复杂编排用 channel 更可靠；  对热点路径保持函数边界：协作式抢占仍依赖安全点，过度内联与紧密循环要谨慎；  善用 pprof/trace：在压测环境下先度量再优化，避免拍脑袋调参。十二、常见问答  为什么不是 1:1？线程创建/栈成本与上下文切换太高，难以支撑数十万并发；  为什么不是 N:1？无法用多核并行，一次 syscall 可能阻塞整个进程；  P 的存在感是什么？减少全局争用、提升局部性，并成为并发度的“配额器”；  抢占是否 100% 及时？不是。异步抢占已大幅改善，但仍依赖安全点；  goroutine 真的“无限便宜”吗？不是。内存、调度、GC 都付成本；设计时要有边界与限流。十三、小结GMP 模型是 Go“以工程为中心”的体现：  以 goroutine/channel 的直观抽象降低并发编程的心智负担；  以用户态调度与 P 的本地队列/work stealing 实现高伸缩；  以 netpoller 与异步抢占保证 I/O 与计算的双向友好；  以完善的可观测性工具支撑“先度量再优化”的最佳实践。它并不完美，但在“简单可用”与“高性能可伸缩”之间给出了极佳的工程折中。这也是 Go 在云原生时代持续流行的底层原因之一。附：命令速查# 调度打印（每秒一次）GODEBUG=schedtrace=1000,scheddetail=1 ./app# 运行时剖析（HTTP pprof）go run main.go &amp;go tool pprof -http=:0 http://localhost:6060/debug/pprof/profile# 时间轴跟踪go test -run=NONE -bench=BenchmarkX -trace trace.out ./...go tool trace trace.out"
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/java/2015/09/08/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8F%AF%E8%A7%81%E6%80%A7%E5%AE%9E%E8%B7%B5.html",
    "title": "Java 内存模型与可见性实践",
    "content": "JMM（Java Memory Model）定义了线程间可见性、原子性与有序性。本文通过可复现案例解释 volatile、happens-before、指令重排与发布/逃逸，并给出 JIT 层面的观测方法。1. 可见性问题复现public class StopFlagDemo {  // 去掉 volatile 观察现象  static /*volatile*/ boolean stop = false;  public static void main(String[] args) throws Exception {    new Thread(() -&gt; { while (!stop) { } }).start();    Thread.sleep(100);    stop = true;  }}无 volatile 时，JIT 可能将 stop 缓存至寄存器，循环无法观察到主线程写入。2. JIT 观测（hsdis/PrintAssembly）启动参数：-XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:+PrintAssembly观察 volatile 写前后的屏障指令（如 x86 的 lock 前缀原子指令 / mfence）。3. 指令重排与双检锁class LazySingleton {  private static volatile LazySingleton INSTANCE;  static LazySingleton get() {    if (INSTANCE == null) {      synchronized (LazySingleton.class) {        if (INSTANCE == null) INSTANCE = new LazySingleton();      }    }    return INSTANCE;  }}volatile 避免构造重排导致的“引用可见但对象未完成初始化”。4. Happens-Before 速查  程序次序、监视器锁、volatile、线程启动/终止、传递性。5. 排错清单  自旋等待变量需 volatile 或原子类；  不要在锁外读写与锁内读写混用同一状态；  使用 jcmd VM.print_touched_methods、jfr 观测热点与锁竞争。6. JMM 与内存屏障的演进（JSR-133）  JDK 5 以前（JSR-133 之前），内存模型对 volatile 与 final 的约束较弱，双检锁（DCL）可能失效。  自 JDK 5（JSR-133）起：          volatile 写建立 Store-Store 与 Store-Load 语义；volatile 读建立 Load-Load 与 Load-Store 语义（等价于写的释放、读的获取）。      final 字段发布语义明确：构造完成后对其它线程可见，避免“半初始化”。        抽象屏障分类（便于理解，具体实现依赖平台）：          LoadLoad, LoadStore, StoreStore, StoreLoad      一般而言：volatile 写 ~ Release（StoreStore + StoreLoad），volatile 读 ~ Acquire（LoadLoad + LoadStore）。      7. HotSpot 在不同硬件上的实现（概览）不同平台的内存一致性与可用指令不同，HotSpot 会在 C1/C2 后端针对性插入屏障/选用原子指令。7.1 x86/x64（TSO）  天然较强（Total Store Order）：已保证 LoadLoad / LoadStore，有风险的是 StoreLoad。  常见映射（HotSpot 版本与编译后端可能差异）：          volatile 写：使用带 lock 前缀的原子指令（如 lock xchg、lock add 0），或显式 mfence，以形成 Full Fence，确保写-读不可越过。      volatile 读：通常普通 mov 即可满足 Acquire 语义（TSO 已保证读的顺序），必要时可能配合轻量栅栏。        CAS/原子操作：lock cmpxchg，天然携带全栅栏语义。示例（节选，不同 JDK/编译器可能略有不同，仅供识别思路）：; volatile store 之前/之后的栅栏lock addl $0x0, (%rsp)   ; 作为全栅栏（或使用 mfence）mov DWORD PTR [field], eax ; 实际写入7.2 AArch64（ARMv8）  指令级提供获取/释放语义：          LDAR（acquire load）/ STLR（release store）      显式全栅栏：DMB ish        常见映射：          volatile 读：LDAR      volatile 写：STLR      VarHandle.fullFence() / Unsafe.fullFence()：DMB ish      7.3 其它（简述）  ARMv7：ldrex/strex + dmb 组合；  PPC：lwsync（轻量栅栏）、sync（全栅栏）。  关键点：JMM 语义是上层抽象，HotSpot 在不同平台选用“能满足该语义的最弱指令组合”，以减少开销。8. VarHandle 与 Unsafe 的屏障对应现代 JDK 推荐使用 VarHandle 指定精确的内存语义：  访问语义：getAcquire / setRelease / getOpaque / setOpaque / getVolatile / setVolatile  栅栏语义：VarHandle.acquireFence()、releaseFence()、fullFence()大致映射关系：  Acquire/Release -&gt; 对应硬件 acquire/release（如 AArch64 的 LDAR/STLR）；  Volatile -&gt; acquire + release（按点位插入栅栏，或选用更强指令）；  FullFence -&gt; 全序列栅栏（x86 可用 mfence 或 lock 原子操作；AArch64 用 dmb ish）。Unsafe（不推荐新代码使用）也提供：storeFence()、loadFence()、fullFence()，与 VarHandle 栅栏语义对应。9. hsdis 观测指引（示例）以 volatile 写为例，打开 -XX:+PrintAssembly 后，在输出中搜索目标方法：; ...; 关键位置常见：lock addl $0x0,(%rsp)   ; 或 mfence，形成 StoreLoad 屏障mov    %eax,0xNN(%rbx)  ; 写入 volatile 字段; ...在 AArch64：stlr    w0, [x1]        ; release store 到 volatile 字段说明：不同 JDK/编译器（C1/C2）、优化级别与 CPU 平台会有差异，识别“是否具备 acquire/release/全栅栏”语义是核心。10. 实战建议（落地）  选择合适语义：          只需要“发布事件/状态位”的写：setRelease；对应读取用 getAcquire。      必须与既有 volatile 交互且要求最强语义：使用 getVolatile/setVolatile。      仅跨线程传递“可能乱序但最终一致”的值：getOpaque/setOpaque（更弱，开销小）。        避免无谓全栅栏：全栅栏成本高，在热点路径优先 acquire/release 组合。  发布对象：          使字段 final，或在构造完毕后通过 volatile/release 语义发布；      避免“逃逸未完成初始化”的引用外泄。        诊断与基线：          用 JFR 观测锁竞争/线程状态；      用 hsdis 验证关键点的指令是否达成预期语义（仅在关键问题排查时使用）。      "
  }

]


