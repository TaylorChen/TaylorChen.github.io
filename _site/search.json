[

  {
    "url": "/ai/2025/08/02/%E5%85%B3%E4%BA%8EAI%E5%BA%94%E7%94%A8%E7%9A%84%E6%80%9D%E8%80%83.html",
    "title": "关于AI应用的思考",
    "content": "关于AI应用的思考与IA共创1. 梯人纵发展目前的速度AI工具及应用层出不穷，几乎每天都会有新的style出来，从应用的角度来看有点应接不暇。从单纯的chat聊天模式开始，会发现有一部分的内容AI其实处理的不是很好，即使用到了一些先进的prompt词也不一定会有效果。这个可以想象AI技术能力的提升也是依赖于海量的知识数据，如果现行互联网的数据维持在一个相对静态的状态下，单纯靠AI在此基础上升华创造，不是说不肯能，只是需要的时间会更长。其实反过来如果在AI的加持下，通过人类的思维创造出更高维度的知识或者解决问题的思路，把这些方式公开到网络上，让AI进行提取学习，可能这种发展离真正的“智能”会更近一步。这种模式就是左脚踩右脚的模式，一步步靠近终极目标方向。2. 企业应用AI Accessibility现在AI应用无处不在，日常文案的优化、生活和工作中遇到问题会先用AI进行科普扫盲、AI Coding、代码review、调研报告等。但是可以看看真正企业与AI的结合程度如何？按照目前阶段来说还在初级阶段，目前使用的模型都是基于现有公开的网络的数据进行训练的，那么对于企业本身的数据在公网是..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/nginx/2025/07/01/Nginx-Ingress-%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5.html",
    "title": "Nginx Ingress 高并发场景优化实践",
    "content": "在高并发/高吞吐场景下，Ingress-Nginx 的瓶颈往往在四处：连接与端口、文件句柄、握手与 TIME_WAIT、日志 I/O。本文给出值可直接落地的 Helm values.yaml 片段、Linux 内核参数、日志轮转 sidecar、压测与观测清单。1. 云负载均衡（CLB/NLB）容量  选择性能容量型/增强型实例，并调高带宽上限；入口成为系统上限的概率远高于后端。  自建 CLB 后通过注解/固定 loadBalancerIP 复用为 Ingress 入口。2. Linux 内核参数（容器内以 initContainer 动态设置）Helm values.yaml：controller:  extraInitContainers:    - name: sysctl      image: busybox      imagePullPolicy: IfNotPresent      securityContext:        privileged: true      command:        - sh        - -c        - |  ..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/nginx/2025/06/28/Nginx-%E9%9B%B6%E5%81%9C%E6%9C%BA%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E4%B8%8E%E5%9B%9E%E6%BB%9A%E7%AD%96%E7%95%A5.html",
    "title": "Nginx 零停机灰度发布与回滚策略",
    "content": "从运维架构视角，结合 Nginx 的多种路由能力（权重、Header/Cookie、子域名、子路径）与容器编排（Docker/Kubernetes），构建“低风险、可审计、可回滚”的上线流程。本文给出平滑发布步骤、生产级配置、容器化集成与回滚预案。0. 目标与原则  不中断：对外 0 失败率、0 连接重置；  可回滚：故障秒级回退；  可观测：全链路指标与日志可追溯；  可审计：变更有记录，可复现。1. 平滑发布（通用步骤）1) 版本准备：构建 v2 镜像（含健康检查、版本信息接口），在 v1 旁路启动；2) 预热：v2 只接入探活与预热流量（本地缓存、JIT、连接池预连接）；3) 小流量灰度：按 1%/5%/10%/20%/50%/100% 切流，每步 5-15 分钟观察 SLI；4) 监控门禁：4xx/5xx、P95/P99、错误率、特定业务 KPI（下单/支付成功率）；5) 扩展面：流量达到 100% 后保持观察窗口（30-60 分钟）；6) 收尾：下线 v1 或保留一段时间作为热备用。  SLI/SLO 建议：错误率 &amp;lt; 0.1%，P95 &amp;lt; 目标阈值（如 3..."
  },

  {
    "url": "/%E5%B7%A5%E5%85%B7/2025/05/13/%E5%85%85%E5%88%86%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E4%B9%8Bgithub.html",
    "title": "定期追更的项目",
    "content": "定期追更的项目：1. Weekly（科技爱好者周刊）2. 《HelloGitHub》月刊无边界的学习资料库1. Librarian-pku 北大全套课程资料2. 清华大学计算机系课程攻略3. BiliBili公开课目录4. 从小学到高中所有教材5. 各教育机构学习资源6. 感觉把中医的知识全放进去了，推拿针灸啥的，几十T，应有尽有7. 各种各种资料，影视、学习、读书、自媒体神仙设计资源库1. design-resource2. Awesome Design Tools3. 中国色彩4. 字体[得意黑]Smiley Sans5. 白情包博物馆 ChineseBQB不只用来学习的GitHub1. 程序员做饭指南2. 996.ICU3. 各种资料、知识、影视、记录片、音乐、书籍、媒体聚集地，持续整理中GitHub依然固执地生长着最开放的互联网精神。"
  },

  {
    "url": "/ai/2025/05/04/AI%E8%BE%85%E5%8A%A9%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84LLM%E9%80%89%E6%8B%A9%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html",
    "title": "AI 辅助编程中的 LLM 选择最佳实践",
    "content": "AI 辅助编程中的 LLM 选择最佳实践看开发阶段、试不同模型、管好成本，最终找到最适合自己的方案软件开发有不同阶段，每个阶段需要 AI 的不同能力。开发分成四个阶段，并给出如何选择模型的建议：1. 设计与架构阶段      需求：这个阶段你需要一个能深度思考、有丰富知识的模型，帮助理解业务需求并设计架构。        推荐模型：OpenAI o1、Gemini 2.5 Pro、DeepSeek R1        为什么选这些：这些模型推理能力强，能帮你做出清晰的早期决策        成本建议：这里值得用高级模型，因为好的架构能省下后期改动的麻烦  2. 开发阶段      需求：写代码时，需要模型能理解代码模式、建议补全、解释实现        推荐模型：Gemini 2.5 Pro、GPT-4o、Grok 3        额外亮点：Claude 3.7 Sonnet 虽然基准测试分数不最高，但很多开发者喜欢，建议多试试        成本建议：简单编码用中档模型就够，复杂任务再用高级模型  3. 测试阶段      需求：写测试时，模型要能发现边缘情况、写出可靠的测试..."
  },

  {
    "url": "/%E6%80%9D%E8%80%83/2025/05/03/%E5%AE%9E%E6%97%B6%E5%8F%8D%E6%80%9D%E4%BC%98%E5%8C%96%E7%AE%A1%E7%90%86%E8%83%BD%E5%8A%9B.html",
    "title": "实时反思优化管理能力",
    "content": "实时反思，优化管理能力回顾工作这么多年，从开始的基本的coding工作开始，一线资深研发到后来的技术决策者，再到后来的创业。这些工作过程中我体会到在技术管理方面有很多道理在人生道路上也一样。总结归纳为用三个词来形容：父母心、为人真诚、反思精进，这些也是我一直再坚守执行的。1. 父母心在最近两年家里有了小朋友，在照顾小朋友的同时会去学习如何照顾、怎么哄睡、怎么做辅食、对于一些游戏怎么交小朋友去做、平时在互动的过程中如何用精简的指令让小朋友明白你的表达是什么(特别是在还不太会说话阶段)，这些都是从书中去学习，过程中越觉得其中的理念跟管理相同。书里面所讲的不是数理化，而是一个人最根本的东西：好奇心、同理心、韧性、乐观、与遇到问题用不放弃。这里面也会谈到一个话题就是作为家长对于子女的期待是什么？是出人头地吗？放到现在这个时代背景下，大部分父母应该都不会是这个答案。我的答案也很简单就是有积极向上的价值观，长大了有自己独立思考的能力，即便没有大人的依靠，依然能够很好的过自己的生活。2. 为人真诚为人真诚，众多的管理方法都更像是术，而在这些技术之上是道的层面。这个真诚既是我们对自己真诚，也是我..."
  },

  {
    "url": "/%E6%80%9D%E8%80%83/2024/08/25/%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B.html",
    "title": "你需要知道的事情",
    "content": "你需要知道的事情最近“黑神话悟空”游戏比较火热，看到有一句话就是直面天命，能量满满。想到游戏中角色扮演，想到生活中每个人也是一种角色，我们不也是在“扮演”吗？以下是近期的一些思考。1. 商业熟悉所有行业的底层逻辑，冷静的思考每一个行业(特别是作为商业投资者)。任何一个商业模式再变，商业底层逻辑万变不离其宗。日常生活中就有一些类似的场景，当你在一家餐饮店吃完饭后，老板说我们现在有个活动就是充值1000元，当前这顿饭免费(例如这顿饭价值200)，这个看似划算，可能当时一心动就充值了。理解本质的话这个顿饭并不是免费的，800/1000 = 0.8，相当于8折，就是用800充值抵1000。直接打折容易产生“产品价值被贬低”等副作用，而隐形打折却让人感觉占到了便宜又不容易产生“该产品质量有问题”等等的认知问题。类似的还有骗子的诈骗电话，你接到一个电话，对方操着很奇怪的口音对你说：“我是你领导，明天到我办公室来一趟。”，你一听就知道他是骗子，你甚至会觉得你不是在被骗而是在被羞辱。或许你会想：骗子现在也太不专业了吧，接受过培训吗？有成功率的考核吗？如果你有这样的想法，那你是在是多虑了。蹩脚的骗..."
  },

  {
    "url": "/%E6%80%9D%E8%80%83/2024/08/18/%E6%95%B0%E5%AD%A6%E6%80%9D%E7%BB%B4%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F.html",
    "title": "日常思考问题的5种数学思维思维模式",
    "content": "日常思考问题的5种数学思维思维模式1. 从不确定性中找到确定性第一种数学思维源于概率论，叫作“从不确定性中找到确定性”。假如一件事情的成功概率是20%，是不是意味着我重复做这件事5次就一定能成功呢?很多人会这样想，但事实并不是这样。如果我们把95%的概率定义为成功，那么，这件20%成功概率的事，你需要重复做14次才能成功。换句话说，你只要把这件20%成功概率的事重复做14次，你就有95%的概率能做成。计算过程如下，对公式头疼的朋友可以直接略过。做1次失败的概率为:1-20%=80%=0.8重复做n次都失败的概率是:80%”=1-95%=5%=0.05(重复做n次至少有1次成功的概率是95%，就相当于重复做 n次、每一次都不成功的概率是5%)  n = log0.08^0.05≈13.42所以，重复做14次，你成功的概率能达到 95%。如果你要达到99%的成功概率，那么你需要重复做21次。虽然这个世界上没有100%的成功概率，但是只要重复做大概率成功的事情，你成功的概率就能够接近100%。这就是从不确定性中找到确定性，这是概率论交给我们最重要的思维2. 用动态的眼光看问题第二种数学..."
  },

  {
    "url": "/%E6%80%9D%E8%80%83/2024/08/11/%E5%91%A8%E6%9C%AB%E6%80%9D%E8%80%83%E8%AE%B0%E5%BD%95.html",
    "title": "周末思考记录20240811",
    "content": "周末思考记录202408111. 找到知识的盲点在小时候记得映像比较深刻的就是，就是在课堂上背诵九九乘法表，背不过放学后还不让回家（天快黑了，还是会放的）。包括现在一些简单的乘法算术在计算的时候也会采用乘法表进行，当时以为乘法只有一种计算方式，其实后来才了解到乘法在不同的国家则计算方式不一样，在俄罗斯采用的是“俄罗斯农夫乘法”，在古埃及通过垒石头的方式进行计算，叫做“古埃及乘法”，类似的还有“印度乘法”。同样的还有10进制、12进制、60进制、生肖等，这些是如何进行计数的，到目前知道的是，这些进制就跟人类的双手和脚趾有关，10个手指头，直接计数比较简单这就是10进制，12进制就是把一个人的的单手除大拇指之外的，其它每一根手指分为3节，所以一只手除开大拇指就是12节，类似的还有60进制，无非是用上双手等。其实想想这些定义和发明都是源于事物本身，如果当时学习的时候能知道这些，那么学习的时候是否兴趣会更大一些。2. 把手弄脏的理解回顾过往的工作经历中，在职场中有意或者无意的会去把一件事情整的明明白白、或者是对于业务来说那块是难点就会花时间去啃、在团队中会时不时出现救火场面。其实这些成长..."
  },

  {
    "url": "/%E6%88%90%E9%95%BF/2024/05/19/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%9A%84%E7%90%86%E8%A7%A3.html",
    "title": "最佳实践的理解",
    "content": "最佳实践的理解最近因为家里的事情，有一段时间没有更新了。刚在整理近期的工作和生活中的事情，想到一个词是“最佳实践“这个词。这个词也不陌生，经常在软件研发领域会说这个方案是最佳实践或者不是、在其他行业有时后会说应该这么做才是最好的、在生活中回顾做的一些决策和操作之后，在现在看来可能部分决策不是最佳实践。1. 概率在生活和工作中处处面临选择，每种选择其实可能都会伴随着不同的结果，其实这就产生了概率问题。只是现实社会中往往大家可能会总结经验，让好的结果尽可能发生，那么从概率的角度讲就是正向概率增大，那么这就是最佳实践的叠加效应。回想最早的机器学习(监督和无监督)、当前生成式AI(GAI)、金融行业的量化交易等，这些其实最终追求的就是概率问题，在量化交易行业中这个就是胜率问题。那么最佳实践本质上来说就是做选择，既然做选择就会存在概率问题，在实际生活中会发现最佳实践多了，那么就会形成叠加效应，胜率会增大，就会直接或间接带来一定的收益。2. 学习既然面临选择，那么当时不是盲目选择，这里也需要基于一定的事实客观规律，那就是学习。选择要建立在一定的理论基础和方法论，这里有很多关于这方面的文章。我..."
  },

  {
    "url": "/web3/2024/04/16/Web3-%E6%B8%B8%E6%88%8F-%E9%93%BE%E4%B8%8A%E8%B5%84%E4%BA%A7%E4%B8%8E%E7%BB%8F%E6%B5%8E%E5%B9%B3%E8%A1%A1.html",
    "title": "Web3 游戏：链上资产、可组合性与经济平衡",
    "content": "Web3 游戏并非“把游戏搬上链”，而是利用“链上可验证资产 + 可组合协议 + 开放市场”构建新型经济系统：资产可流通、玩法可叠加、内容可共建。工程落地的关键是资产与经济的严谨设计、反作弊与反女巫、链上/链下分工与可观测体系。本文给出一套可直接实操的参考方案。1. 资产设计：ERC-721/1155 与可组合  角色/装备：稀有度、属性、成长路径；  可组合：装备作为组件装配到角色（EIP-998/可组合规范），或在外部合约读取“装备映射”；  动态属性：升级/附魔/修复，链上存储核心属性，链下计算细节；  元数据：图素与动画通过 IPFS/Arweave 存储，链上记录 CID。2. 经济平衡（产出/消耗闭环）  产出：打怪/任务/挖矿 掉落；  消耗：修理/强化/合成/门票；  通胀控制：掉率衰减、合成概率、消耗品设计；  市场：玩家间自由交易（AMM/订单簿），平台抽取少量手续费回流金库；  预言机：如涉及法币锚定，采用时间加权价格，规避闪崩影响。3. 反脚本与反女巫  行为指纹：节奏/移动/时序统计识别自动化；  风控阈值：异常收益、频繁交易、深夜高频；  DID/VC..."
  },

  {
    "url": "/%E6%80%9D%E8%80%83/2024/03/25/%E4%BA%8C%E5%85%AB%E6%B3%95%E5%88%99%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83.html",
    "title": "二八法则的一些思考",
    "content": "关于二八法则的另外一种叫法是80/20法则，或者叫关键少数法则。在生活工作方各方面都有体现：在经济学领域，全球最富有的20%的人口，控制着世界收入的82.7%。在软件领域，可以应用于优化软件工作，通过修复报告最多的错误的前20%，给定系统中80%的相关错误将被消除。在运动锻炼上，20%的练习和习惯影响着80%的结果，受训者不应该专注于多种训练。将二八法则落实到行动上，简单整理了如下方法做有复利积累的事情复利特别在经济学领域比较常用，例如做量化一般也会评估复利的长期收益(常说的利滚利)。最常见的复利即资产，即可以自行为持有人带来收益的东西，资产本身是固化的劳动，而靠其赚到的钱又可以固化为资产，从而以指数增长的方式增殖。当然，任何可以积累的东西都是具有复利效应：知识是可以积累下来的，积累的知识帮助做出更高概率正确的决策，带来更大的视野，从而有需求及动力学习更多知识；个人IP影响力是可以积累的，更高的影响力带来更大的曝光，接触更多优秀的人，有更多合作机会，反过来又增强个人的影响力。极致聚焦，做减法现实中每个人的精力有限，不太可能可以做所有的事情，要通过分析和评估来确定哪些是产生最大价值..."
  },

  {
    "url": "/%E5%B7%A5%E5%85%B7/2023/12/19/%E5%AE%9E%E7%94%A8Mac%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E5%88%97%E8%A1%A8.html",
    "title": "实用Mac软件推荐列表",
    "content": "Apps日常使用ClashX Pro：科学上网只有先科学上网，才能装后面的Notion：笔记输入 + 博客输出的工具Chrome：浏览器Xnip：截图工具1password 7：密码管理工具其它的也用过，还是这个原生 App 比较流畅CleanMyMac X：Mac优化清理工具Warp WindTerm iTerm2：终端Alfred：本地搜索、应用启动、剪贴板 📋MarkEdit: Mac上开源markdown编辑器效率神器Karabiner-Elements：键盘键位修改神器一些配置 karabiner.json ，主要是改 HHKB 和 Apple Keyboard滴答清单 ：任务和规划时间（GTD）的应用flomo ：快速记录一些想法Bob 社区版 ：划词翻译和截图翻译工具支持多个翻译聚合还挺方便的Input Source Pro ：不同应用、不同网站自动切换输入法QQ Music ：网络音乐服务产品百度五笔输入法试过 Mac 上各类的五笔输入，还是这个好用NetNewsWire ：开源、免费、全平台的 RSS 订阅、阅读订阅 index.opmlBartender 4 ..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/nginx/2023/12/05/Nginx-Ingress-%E5%9C%A8Kubernetes%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E9%85%8D%E7%BD%AE.html",
    "title": "Nginx Ingress 在 Kubernetes 的高可用配置",
    "content": "在 K8s 中落地 Ingress-Nginx 时，如何配置高可用、弹性与灰度？本文给出实操 YAML、金丝雀流量与压测/演练手册。1. 基础部署（示例）apiVersion: networking.k8s.io/v1kind: Ingressmetadata:  name: web  annotations:    kubernetes.io/ingress.class: nginxspec:  rules:  - host: demo.example.com    http:      paths:      - path: /        pathType: Prefix        backend:          service:            name: web-svc            port:              number: 802. 金丝雀灰度metadata:  annotations:    nginx.ingress.kubernetes.io/canary: &quot;true&quot;    nginx.ingress.kubernete..."
  },

  {
    "url": "/web3/2023/08/09/Web3-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E9%92%B1%E5%8C%85%E6%B3%A8%E5%85%A5%E6%A0%87%E5%87%86.html",
    "title": "Web3 浏览器与钱包注入：EIP-1193/6963 与隐私实践",
    "content": "Web3 浏览器的要义是“让网页安全地调用用户的加密身份与链上资源”。核心落在 Provider 标准（EIP-1193）、多钱包发现（EIP-6963）与网络切换（EIP-3085/3326），同时还要面对隐私合规、反钓鱼、兼容性与多链适配等现实问题。本文从标准到工程实践，系统讲解如何构建“安全、可靠、好用”的 Web3 浏览器/前端。1. EIP 标准速查  EIP-1193：Provider 请求/事件接口；  EIP-6963：多钱包发现与选择；  EIP-3085：向钱包添加链配置；  EIP-3326：请求钱包切换链；  EIP-155（签名交易链ID）、EIP-712（结构化签名）。常用调用：await provider.request({ method: &#39;eth_requestAccounts&#39; })await provider.request({ method: &#39;wallet_addEthereumChain&#39;, params: [{ chainId:&#39;0x1&#39;, rpcUrls:[&#39;...&#39;], chainName:&#39;Ethereum&#39;, nativeCu..."
  },

  {
    "url": "/web3/2023/03/22/Web3-DAO-%E6%B2%BB%E7%90%86%E4%B8%8E%E5%8D%8F%E5%90%8C%E5%AE%9E%E8%B7%B5.html",
    "title": "DAO：治理、金库与协同实践",
    "content": "DAO（Decentralized Autonomous Organization）强调“公开规则 + 透明资产 + 社区协作”。要把 DAO 从“概念”落地为可持续运作的“组织”，需要同时构建规则（合约/章程）、流程（提案/投票/执行）、工具（多签/投票/论坛/工单）与度量（金库/参与度/交付）。本文从治理模型到金库运营、从合约到日常协同，给出可直接落地的实践手册与脚本示例。1. 治理模型概览  Token-based：一币一票，参与门槛低但易受“鲸鱼”影响；  Delegated（委托制）：将投票权委托给代表，兼顾广泛参与与专业决策；  二次方投票（Quadratic）：缓解大户垄断影响，但需反女巫措施；  基于声誉/贡献积分：非金融化权重，强调长期贡献；  混合模型：不同领域/金额使用不同门槛与投票机制（如技术提案 vs. 市场预算）。2. 提案生命周期（从草案到执行）1) 草案（RFC）：论坛/Discord 讨论，明确动机、方案、预算、风险；2) 影子投票/温度测试（Snapshot 温度计）：收集倾向；3) 正式提案（SIP/DAOIP 等）：链上/链下同步发布；4)..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/mysql/2023/02/27/MySQL-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E4%BB%8E-explain-%E5%88%B0%E7%81%AB%E7%84%B0%E5%9B%BE.html",
    "title": "MySQL-慢查询优化-从-explain-到火焰图",
    "content": "在大多数互联网业务中，性能问题往往集中在查询侧（读多写少、读写比常见为 10:1），而慢查询占据了主要矛盾的“C 位”。要系统性地把慢查询优化好，必须同时理解数据库的底层原理（磁盘 IO、B+ 树、优化器）、索引设计的工程原则、可落地的重写与调参手法，以及边界条件——哪些场景即便你用尽 SQL 和索引也很难救。本文在高技术细节的基础上，结合一线经验进行结构化扩展与工程化整理，以期给出一份可直接借鉴的优化指南。一、底层原理速览：为什么索引有效、为什么会慢  磁盘 vs 内存的数量级鸿沟          随机磁盘 IO 的代价远高于内存访问。一次随机 IO 需要经历寻道、旋转延迟、传输时间，数量级毫秒；CPU 指令数量级纳秒。我们优化的核心目标，是让“每次查询落盘的随机 IO”尽量变少甚至可控。        InnoDB 与 B+ 树          InnoDB 二级索引和聚簇索引（主键索引）均是 B+ 树。B+ 树扇出高、树高低（常见 2～4 层），单次定位数据通常 2～3 次 IO 即可。二级索引叶子节点只存被索引列和主键值，真实行数据在聚簇索引上，因此“二级索引命中但需..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/golang/2022/10/07/Go-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-Channel%E4%B8%8EContext%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html",
    "title": "Go 并发模型：Channel 与 Context 最佳实践",
    "content": "如何用 Channel 建模生产者-消费者、扇入扇出、超时与取消？Context 在线程间传递取消与元数据，避免协程泄漏。1. 扇入扇出func fanOut(in &amp;lt;-chan T, n int) []&amp;lt;-chan T { /* ... */ }func fanIn(cs ...&amp;lt;-chan T) &amp;lt;-chan T { /* ... */ }2. 超时select {case &amp;lt;-time.After(200*time.Millisecond): /* timeout */case v := &amp;lt;-ch: _ = v}3. 泄漏排查  goroutine 泄漏：未读的 channel 阻塞；  使用 pprof 的 goroutine profile 与阻塞分析。"
  },

  {
    "url": "/web3/2022/10/01/Web3-NFT-%E6%A0%87%E5%87%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5.html",
    "title": "NFT 标准与应用实践：ERC-721/1155、元数据与版税",
    "content": "NFT（Non-Fungible Token）不是“把图片放上链”，而是在链上记录“不可替代的资产凭证”，其核心在于可验证的所有权、可组合的协议接口和链上/链下协作的系统工程。本文从标准、元数据与存储、铸造与交易、版税争议、动态 NFT、跨链、索引与运维全方位实战讲解。1. 标准概览与对比  ERC-721：一物一权，每个 tokenId 独立；适合独特资产（艺术品、门票）。  ERC-1155：同一合约内可发行“半同质/多类型”资产，节省 Gas；适合游戏道具/批量空投。  EIP-2981（版税建议）：提供 royaltyInfo(tokenId, salePrice) 接口，市场可选择是否尊重。  元数据 URI：tokenURI(tokenId) -&amp;gt; string，可返回 HTTP/IPFS/Arweave 等。接口最小集合：interface IERC721 {  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);  function ownerOf..."
  },

  {
    "url": "/web3/2022/05/18/Web3-%E4%BB%A3%E5%B8%81%E7%BB%8F%E6%B5%8E%E5%AD%A6-%E4%BB%8E%E8%AE%BE%E8%AE%A1%E5%88%B0%E5%AE%9E%E6%93%8D.html",
    "title": "加密货币与代币经济：从模型设计到实操监控",
    "content": "代币经济（Tokenomics）是协议可持续的核心约束。成功的设计既要有工程严谨性（参数/代码/可观测）也要有博弈论直觉（激励一致性/抗攻击）。本文从“发行→释放→流动性→治理→风控→监控看板”构建一套可落地的代币经济方法论，附上可复用的合约与脚本片段。1. 发行与释放（Token Generation &amp;amp; Emission）  初始分配：团队/顾问/投资人/社区/金库比例；  释放曲线：线性/阶梯/里程碑触发，避免短期砸盘；  锁仓与归属（vesting）：可撤回与不可撤回的权衡；  二级市场前的“冷启动”：空投/任务/白名单+反女巫。合约片段（Vesting）：contract Vesting {  IERC20 public token; mapping(address=&amp;gt;uint256) public total; mapping(address=&amp;gt;uint256) public claimed; uint64 public start; uint64 public cliff; uint64 public duration;  function cl..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/java/2022/03/30/Java-Spring-%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E9%99%B7%E9%98%B1.html",
    "title": "Java Spring 事务传播与隔离级别陷阱",
    "content": "事务机制在软件开发中扮演举足轻重的角色。本文系统介绍数据库与分布式事务的原理与应用、隔离级别与典型并发现象示例，并结合 Spring 的传播机制与实现原理，最后从 CAP 视角给出大型系统中确保“相对一致性”的工程方案与实战蓝本。一、为何需要事务  目标：在并发与故障条件下，保证数据正确性与可预期性。  ACID：原子性、一致性、隔离性、持久性；工程上需在性能、可用性与一致性间权衡。二、数据库事务与隔离级别（含示例）  常见隔离级别与现象          Read Uncommitted：可能脏读；几乎不用。      Read Committed (RC)：避免脏读；仍有不可重复读与幻读（PostgreSQL 默认）。      Repeatable Read (RR)：同一事务内多次读取结果一致；InnoDB 的 RR 基于 MVCC + Next-Key Lock，普通一致性读看到“快照”，更新扫描加间隙锁抑制幻行（MySQL 默认）。      Serializable：最强隔离；性能代价大，通常依赖锁或乐观并发控制。        并发现象最小示例          ..."
  },

  {
    "url": "/web3/2021/11/06/Web3-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E5%AE%89%E5%85%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html",
    "title": "智能合约工程与安全最佳实践：Solidity/Foundry 上手到上线",
    "content": "智能合约是 Web3 应用的“规则中枢”。它一经部署即“公开、自动、可验证”，带来强信任的同时也几乎没有运维回旋空间。要在生产环境长期稳定运行，必须以工程化与安全为第一原则：标准化目录结构、完善测试与审计流程、上线策略与紧急预案、可观测与变更留痕。本文体系化给出从 0 到 1 的落地路径与可直接复用的清单。1. 工程化目录与依赖管理  目录结构建议：    contracts/       # 合约源码└── modules/     # 复用模块（库、接口）src/             # 或 contracts/（Foundry 惯例为 src/）scripts/         # 部署与迁移脚本lib/             # 依赖（OpenZeppelin 等）test/            # 单元/属性/模糊测试out/             # 构建产物（abi、bin）        依赖：锁定版本，尽量固定到 commit（forge install OpenZeppelin/openzeppelin-contracts@v5.0.1）。  约定：..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/php/2021/06/10/PHP-%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E4%B8%8E%E9%9B%86%E4%B8%AD%E5%8C%96.html",
    "title": "PHP 实时日志采集与集中化",
    "content": "如何在 PHP 体系下实现实时日志采集、清洗、聚合与检索？本文结合物理机与 Kubernetes 两种运行环境，给出分阶段演进路线、最佳实践与可落地配置（EFK/PLG/ClickHouse/OTel），并附带 PHP 端具体实现建议。架构概览物理机 / VM 拓扑flowchart TD  A[&quot;微服务 (物理机/VM)&quot;] --&amp;gt; B[&quot;应用日志: JSON 文件 / journald&quot;]  B --&amp;gt; C[&quot;宿主机 Agent: Fluent Bit / Vector / OTel Collector&quot;]  C --&amp;gt;|&quot;TLS+重试+背压&quot;| D[&quot;Kafka (可选缓冲)&quot;]  C --&amp;gt; E[&quot;处理/路由: Logstash / OTel Collector / Vector&quot;]  D --&amp;gt; E  E --&amp;gt; F[&quot;Elasticsearch / OpenSearch&quot;]  E --&amp;gt; G[&quot;ClickHouse&quot;]  E --&amp;gt; H[&quot;Loki&quot;]  F --&amp;gt; I[&quot;可视化: Kibana / Grafana..."
  },

  {
    "url": "/web3/2021/03/12/Web3-%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E5%BA%94%E7%94%A8DApps%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98.html",
    "title": "去中心化应用（DApps）架构实战：钱包、签名与读写分层",
    "content": "在 Web3 语境下，“应用”与传统 Web2 的差异并不只是是否使用区块链，而是信任模型从“平台背书”转向“代码即法律（Code is Law）”与“加密签名即授权”。DApp 的工程化落地，归根结底是围绕三件事：身份与授权（钱包）、状态与规则（智能合约）、读写与观测（RPC/索引器）。本文从体系结构到实战细节，带你搭建一个可上线的 DApp，并覆盖常见错误与运维要点。1. 架构概览与信任边界  前端（dApp）：运行在用户浏览器或移动端，负责连接钱包、发起签名、调用合约、渲染数据；  钱包（Provider/Signer）：保存私钥，EIP-1193 暴露统一接口，EVM 链上用 eth_* JSON-RPC；  合约（EVM Solidity）：在链上保存规则与资产，事件（logs）作为“事实来源”；  后端/索引器：尽量“最小信任”。使用 The Graph/SubQuery/自建 ETL，将事件抽取到可查询存储以供前端检索；  节点与网关：Infura/Alchemy/自建 Geth/Erigon；选择稳定 RPC 与指数退避策略；  可观测与告警：交易成功率、确认时间..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/nginx/2020/09/22/Nginx-%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E4%B8%8E%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E5%AE%9E%E8%B7%B5.html",
    "title": "Nginx 缓存策略与动静分离实践",
    "content": "CDN 前移与边缘缓存固然重要，源站 Nginx 的缓存与动静分离同样关键。本文给出缓存键、缓存层级与缓存失效策略。1. CDN 的概念与原理CDN（Content Delivery Network，内容分发网络）通过在全球各地部署边缘节点，将内容缓存并就近分发给用户，以缩短 RTT、降低回源压力和抖动。其核心机制包括：  路由调度：基于 Anycast、DNS 或 HTTP 重定向，将用户引导到就近/最优节点。  边缘缓存：边缘节点依据源站响应头（如 Cache-Control、Expires、ETag、Last-Modified、Vary、Surrogate-Control、s-maxage 等）决定存储与回源策略。  回源与验证：命中失败或过期后，边缘向源站回源；支持条件请求（If-None-Match/If-Modified-Since）。  失效与刷新：通过 API 触发 URL/PATH/Tag 维度的失效（Soft/Hard Purge），或自然到期。实践上，合理设计缓存层级（浏览器 → CDN 边缘/中间层 → 源站 Nginx）与一致的缓存语义，是稳定与性能的关..."
  },

  {
    "url": "/web3/2020/08/19/Web3-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%A0%88.html",
    "title": "Web3 的链上基础：共识、状态机与扩容栈",
    "content": "区块链是“可验证状态机复制”（Replicated State Machine）。要把 DApp 做稳，必须理解状态如何被转换、共识如何达成、数据如何被持久化与对外可读。本文从状态机、共识、存储与扩容（L2/DA）出发，构建一条可实践的技术路径，并附带节点与索引的工程建议。1. 状态机与区块  交易（Tx）是对状态的变更请求；  区块是时间窗口内的交易集合；  状态机：state_{n+1} = transition(state_n, block_txs)，其中 transition 由虚拟机（EVM/WASM）与合约逻辑决定；  真实性：通过 Merkle/Patricia Trie/Verkle commitment，为状态/交易/收据生成可校验根。2. 共识算法与容错  PoW：算力竞争，安全性来源于经济成本与难度调节；  PoS：权益质押 + 随机选举/委员会 BFT；  BFT 家族（Tendermint/HotStuff）：低延迟、确定性最终性，容忍 f 个拜占庭节点需总数 ≥ 3f+1；  最终性（Finality）：概率型（PoW） vs. 确定性（BFT/PoS..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/mysql/2020/07/19/MySQL-%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%9B%9E%E8%A1%A8%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html",
    "title": "MySQL 索引设计与回表优化实战",
    "content": "索引，是 MySQL 性能工程的地基。设计得当，查询如行云流水；设计不当，慢查询、锁等待、CPU 飙高全都找上门。本文在原“回表优化实战”的基础上，系统扩展到索引必要性、InnoDB B+ 树底层原理、索引大小对性能的影响、工程化建索引方法论与排障清单，给出一套可直接落地的完整方案。1. 为什么需要索引：必要性与代价的平衡没有索引时，只能全表扫描，I/O 与 CPU 成本随数据量线性增长。索引将“查找”从 O(N) 降为 O(log_f N)，其中 f 为 B+ 树扇出（可达数百至上千），并提供有序访问能力，显著优化范围扫描、排序与分组。同时必须正视代价：  写放大：DML 需要维护主键与二级索引，伴随页分裂/合并；  存储膨胀：索引页占用 Buffer Pool，命中率受影响；  计划风险：索引过多/质量差会让优化器选择困难，出现计划抖动。结论：索引不是越多越好，而是“必要且刚好”。2. 底层原理：为什么是 B+ 树？InnoDB 采用 B+ 树组织数据与索引（聚簇索引与二级索引），核心动机：  磁盘/页友好：节点存大量键指针，扇出大、树高低（亿级数据常 3~4 层）；  顺序..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/java/2019/12/14/Java-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98-%E4%BB%8EG1%E5%88%B0ZGC.html",
    "title": "Java 垃圾回收调优：从 G1 到 ZGC",
    "content": "延迟敏感系统如何选择 GC？如何系统地读懂 GC 日志并做出有效调优？本文从 JVM 基础、STW 机制、垃圾回收算法、收集器演进到实战调优，给出可落地的方法与示例。1. JVM 内存模型与 STW/Safepoint 基础在 HotSpot 下，内存大体分为：  Java 堆（年轻代/老年代，G1/ZGC 采用 Region/分页结构）  线程栈（每线程独立）  元空间（Metaspace，用于类元数据）  本地内存（如直接缓冲区、JIT 代码缓存等）两个重要的分配/复制概念：  TLAB（Thread-Local Allocation Buffer）：线程本地的堆分配缓冲，减少分配锁竞争。  PLAB（Parallel/Promotion LAB）：年轻代向老年代晋升时的并行复制缓冲。Stop-The-World（STW）是 GC 暂停所有 Java 线程的时刻。JVM 通过 Safepoint 实现可停位置控制（比如方法调用边界、循环回边、异常处理器等），在进入关键阶段（如初始标记、重新标记、对象移动/重定位）时触发短暂停顿。理解 STW 有助于判断“为什么延迟尖刺发生在这..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/mysql/2019/08/02/MySQL-Online-DDL%E6%9C%BA%E5%88%B6%E5%AF%BC%E8%87%B4Duplicate-entry%E9%94%99%E8%AF%AF.html",
    "title": "MySQL Online DDL机制导致",
    "content": "MySQL Online DDL机制导致”Duplicate entry”错误的分析问题场景精准定位您描述的场景非常典型：  手机号字段早已存在唯一索引  原表中该手机号记录早已存在（”很早以前就存在数据库中”）  应用程序正确使用INSERT ... ON DUPLICATE KEY UPDATE  问题发生在执行非唯一索引相关的DDL操作时（如修改其他字段）这正是阿里云文档中提到的第三种场景：”使用结构设计功能进行不涉及唯一约束或唯一索引组成字段调整的DDL操作”时出现的冲突。核心问题：Online DDL的row log重放机制1. MySQL Online DDL执行流程（关键阶段）当执行一个不涉及唯一索引的DDL操作（如修改其他字段）时，MySQL的Online DDL流程如下：T0: 开始DDL，创建中间表(#sql-ibxxx)T1: 将原表数据复制到中间表（此时中间表已包含phone=&#39;xxxxx&#39;）T2: 开始记录DML变更到row logT3: 应用程序执行INSERT ... ON DUPLICATE KEY UPDATET4: 将row log中的变更应用..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/golang/2019/04/18/Go-%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html",
    "title": "Go 内存逃逸与性能优化",
    "content": "当我们谈「性能优化」时，内存管理几乎绕不开。Go 的自动内存管理（GC）为开发效率带来极大提升，但如果不理解「内存逃逸（Escape to heap）」的成因与代价，很容易在高并发与低时延场景中踩到性能坑。本文将从跨语言视角解释什么是内存逃逸、为什么会发生，进而深入 Go 编译器的逃逸分析机制与常见触发场景，最后从编码规范与并发实践两个维度，系统性地给出可落地的性能优化方法与检查清单。什么是内存逃逸（跨语言视角）直觉上，函数内创建的局部变量应当位于栈上，随着函数返回被回收；而当变量「逃离」了其创建点的栈帧生命周期，就必须被分配到堆上，由 GC 统一回收，这就是「内存逃逸」。  在 C/C++ 中，没有 GC 的语境里很少使用「逃逸」一词，但同样存在「对象是否必须在堆上分配」这个问题：例如 new 分配的对象需要显式 delete，而局部对象则在栈上自动销毁。现代 C++（尤其是返回值优化、移动语义）会尽可能消除不必要的堆分配。  在 Java/JVM 中，JIT 会做逃逸分析：若对象不逃出方法，则可进行「栈上分配」与「标量替换」，显著减少 GC 压力。  在 Rust 中，是否在..."
  },

  {
    "url": "/web3/2019/04/07/Web3-%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9.html",
    "title": "Web3 的定义与特点：从愿景到工程落地",
    "content": "“Web3”不是一个单一产品，而是一组互相强化的理念与技术集合：密码学身份、开放协议、可组合金融/内容组件、链上可验证状态，以及逐步去平台化的组织与治理方式。本文从历史演进到工程落地，系统阐述 Web3 的核心特点、挑战与最佳实践，并给出可操作的架构与工具清单。1. 从 Web1 → Web2 → Web3：范式迁移  Web1（只读）：门户/个人主页，内容由站点生产，用户是“浏览者”；  Web2（读写）：用户生成内容（UGC）+ 平台算法分发，账号与数据由平台托管；  Web3（读写+拥有）：私钥拥有权与可验证规则，资产/身份与应用松耦合（可携带、可组合）。迁移的本质：从“中心化平台对数据与身份的控制”转向“用户用私钥控制身份与资产”，从“平台背书可信”转向“协议与加密保证可信”。2. Web3 的核心特征（工程视角）1) 去中心化身份（DID）：地址/公钥或 DID 文档作为标识，签名即授权；2) 合约化规则：规则公开、可验证、可复用，透明度优先；3) 可组合性（Money Legos）：协议接口标准化（ERC/EIP），上层快速组合创新；4) 开放互操作：跨链桥、消息传递..."
  },

  {
    "url": "/%E6%88%90%E9%95%BF/2019/03/18/%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF%E4%B8%8D%E7%94%A8%E7%AD%89%E5%8D%81%E5%B9%B4%E6%8B%86%E5%A2%99%E5%BC%8F%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97.html",
    "title": "技术成长不用等十年拆墙式进阶指南",
    "content": "技术成长不用等十年：拆墙式进阶指南身边总有人问：“每天写 CRUD，能成大牛吗？”“下班累得只想躺，哪有时间学新技术？”“学了半年框架，感觉还是没进步……”技术成长的焦虑，往往源于把 “成为大牛” 当成了遥不可及的山顶。但真实的成长，从来不是闷头爬坡，而是像拆墙 —— 拆掉挡在眼前的认知墙、行动墙、业务墙。每拆一块砖，视野就开阔一分，3 年能抵别人 5 年，这才是接地气的进阶逻辑。一、先拆认知墙：别被 “一万小时” 吓住《异类》的一万小时理论火了之后，太多人盯着 “10 年” 这个数字焦虑。但没人告诉你：这一万小时，藏在每天的碎片里，甚至能和加班 “搭伙过日子”。1. 别算总帐，算 “零钱”刚工作时我也觉得 “每天 3 小时” 是天方夜谭 —— 早上挤地铁，晚上加完班快 10 点，哪来整块时间？后来发现，把 “3 小时” 拆成 “5 分钟 + 15 分钟 + 20 分钟” 的零钱，反而更容易坚持。以学习 Java 开发为例：      上班前 5 分钟：打开收藏的 Java 集合框架源码片段，看 ArrayList 的 add 方法实现，了解它如何动态扩容数组，增加元素。比如看到..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/mysql/2018/11/22/MySQL-%E9%94%81%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%AD%BB%E9%94%81%E5%88%86%E6%9E%90%E6%89%8B%E5%86%8C.html",
    "title": "MySQL 锁监控与死锁分析手册",
    "content": "如何系统化监控行锁/间隙锁与快速定位死锁？本文提供可复现脚本、标准化视图与操作手册。1. 死锁复现（RR 下 Next-Key）CREATE TABLE t_lock(  id INT PRIMARY KEY,  k  INT,  KEY idx_k(k)) ENGINE=InnoDB;INSERT INTO t_lock VALUES (1,10),(2,20),(3,30);会话A：SET tx_isolation=&#39;REPEATABLE-READ&#39;; START TRANSACTION;SELECT * FROM t_lock WHERE k BETWEEN 10 AND 30 FOR UPDATE; -- 锁住[10,30]会话B：SET tx_isolation=&#39;REPEATABLE-READ&#39;; START TRANSACTION;UPDATE t_lock SET k=11 WHERE id=1; -- 等待A释放-- 回到会话A：UPDATE t_lock SET k=21 WHERE id=2; -- 互等 -&amp;gt; 死锁2. 死锁日志解读SHOW ENGI..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/mysql/2018/11/03/MySQL-MVCC-%E4%B8%8E%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB%E6%B7%B1%E5%85%A5.html",
    "title": "MySQL MVCC 与快照隔离深入",
    "content": "本文系统拆解 InnoDB MVCC 的实现细节：undo log、隐式列、Read View、可见性判断与二级索引回表的一致性，并给出可复现实验、源码走读与排错清单。1. MVCC 结构  隐式列：trx_id（最近一次修改事务ID）、roll_pointer（回滚指针）。  undo log：维护历史版本链；读已提交/可重复读通过 Read View 选择可见版本。2. Read View 生成与可见性  关键字段：creator_trx_id、活跃集合 m_ids、low_limit_id、up_limit_id。  判断规则：trx_id &amp;lt; low_limit_id 可见；trx_id &amp;gt;= up_limit_id 不可见；在集合内不可见。SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;START TRANSACTION;SELECT * FROM t WHERE id = 1; -- 固定 Read View3. 二级索引一致性  二级索引条目不含行可见性信息，需回表到聚簇索引判断；  覆盖索..."
  },

  {
    "url": "/web3/2018/03/12/%E6%AF%94%E7%89%B9%E5%B8%81-%E8%B5%B7%E6%BA%90%E4%B8%8E%E5%A5%96%E5%8A%B1%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90.html",
    "title": "比特币的起源与奖励机制：底层逻辑与演进",
    "content": "比特币不是突然出现的一段代码，而是密码学、经济学与分布式系统三股力量长期积累后的工程综合体。本文从历史动机、共识与难度、奖励与费用市场、安全预算与长期可持续性等角度，对比特币的激励机制进行系统拆解，并给出工程视角的观察指标与常见误区澄清。1. 起源与设计动机  金融危机背景：2008 年全球金融危机后，中心化信用机制的脆弱性暴露。中本聪在创世区块留言 “Chancellor on brink of second bailout for banks”。  技术积累：工作量证明（Hashcash）、梅克尔树（Merkle Tree）、公钥密码学（ECDSA）、点对点网络（P2P）。  目标画像：无需许可的电子现金系统，任何人都可加入/退出，用计算工作替代机构信用，规则写入协议与代码而非人治。2. 创世区块与初始参数  区块间隔：目标 10 分钟（通过难度调整逼近）。  难度重算：每 2016 个区块（约两周）按实际出块时间调整难度；调整幅度被限制在目标时长的 1/4 到 4 倍之间，避免剧烈震荡。  奖励初始值：50 BTC/区块，约每 210,000 个区块减半一次（≈ 4 年）。..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/php/2018/01/26/PHP-%E5%8D%8F%E7%A8%8BSwoole-%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5.html",
    "title": "PHP 协程 Swoole 高并发实践",
    "content": "Swoole 将 PHP 带入常驻内存 + 协程并发时代。本文聚焦调度、Hook、协程上下文与与 MySQL/Redis 客户端协作细节，并提供压测脚本与避坑指南。1. 协程 Hook  Swoole\Runtime::enableCoroutine() 对常见 IO 进行 Hook；  注意与第三方扩展兼容性（cURL、多进程）。2. 连接池示例class MySQLPool { /* ... 维护 Channel 与 连接对象 ... */ }// 请求开始从池获取，结束归还；确保协程安全3. 压测wrk -t8 -c200 -d60s http://127.0.0.1:9501/观察 QPS、P95、net.core.somaxconn、ulimit -n。4. 常见坑  全局单例污染：请求间状态泄漏；  异常处理：协程内抛出的异常要汇聚到日志与告警；  Composer 热更新失效：常驻进程需手动 reload。"
  },

  {
    "url": "/web3/2017/09/11/%E5%AF%86%E7%A0%81%E5%AD%A6-%E5%8F%91%E5%B1%95%E5%8F%B2%E4%B8%8E%E5%BD%93%E4%BB%A3%E7%BB%8F%E6%B5%8E%E5%BD%B1%E5%93%8D.html",
    "title": "密码学-发展史与当代经济影响",
    "content": "密码学不仅是保密术，更是现代经济的底层信任机器。从古典替换法到公钥革命，从TLS到区块链与零知识证明，密码学已成为互联网与数字经济的基础设施。本文按时间脉络梳理密码学主要里程碑，并分析其对金融、支付、数据市场与监管的深远影响。1. 古典密码学：对称“保密术”的时代  早期方法：凯撒移位、维吉尼亚表、一次性密码本（理论上不可破）。  工业化破解：二战期间的机械与电机加密（恩尼格玛、紫密），由统计分析与计算机器（图灵机）推动破解技术跃迁。2. 公钥密码学革命（1970s）  基本思想：将加密密钥与解密密钥分离，解决密钥分发难题。  代表算法：RSA（整数分解困难）、Diffie–Hellman（离散对数）、椭圆曲线 ECDSA/ECDH（以更短密钥提供相当安全性）。  重要配套：数字签名、消息认证码（MAC）、哈希函数（SHA 系列）、随机数生成器（CSPRNG）。3. 互联网与密码协议（1990s–）  TLS/SSL：为网页、支付与 API 提供端到端加密与身份认证；证书与 PKI 形成“信任锚”。  存储与传输：AES 成为对称加密事实标准，GCM/ChaCha20-Poly1..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/java/2017/05/21/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E4%BB%8ELock%E5%88%B0AQS.html",
    "title": "Java 并发编程：从 Lock 到 AQS",
    "content": "并发编程里，“锁”是跨线程协调和内存可见性的核心抽象。本文从 Java 对象头与锁位开始，系统梳理锁信息的存放位置、synchronized 与 Lock/AQS 的实现原理、CAS 的内存语义与常见陷阱，并从 x86/ARM 的汇编视角出发，解释 HotSpot 在不同平台上的底层逻辑。最后给出工程实践的选型建议与调优要点。1. Java 对象、对象头与锁位HotSpot 中对象的内存布局通常包含三段：  对象头（Header）：包含 Mark Word 和 Klass Pointer；数组对象还包含数组长度。  实例数据（Instance Data）：各字段的实际存储。  对齐填充（Padding）：保证对象按 8 字节对齐。1.1 Mark Word 与锁信息Mark Word 是一个会随对象状态复用的位段（32/64 位 JVM 分别是 32/64 位；在 64 位下如果启用指针压缩，Klass Pointer 为 32 位）：  无锁：存放对象哈希（identity hash code）、GC Age 等。  偏向锁：存放偏向线程 ID、Epoch、Age 等。  轻量..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/java/2017/04/09/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8ESPI%E6%9C%BA%E5%88%B6%E5%AE%9E%E8%B7%B5.html",
    "title": "Java 类加载器与 SPI 机制实践",
    "content": "本文系统梳理 Java 虚拟机的类加载流程、双亲委派模型与命名空间隔离，深入解析 SPI（Service Provider Interface）在容器与插件化架构中的使用要点与常见坑，并结合字节码增强与 Java Agent 的实践串联起类加载与运行期增强这一条主线，帮助你在工程中进行正确的架构取舍与问题诊断。0. 你为什么需要关心类加载与 SPI  定位复杂 ClassNotFoundException / NoSuchMethodError / LinkageError：多数与类加载边界和版本冲突相关。  搭建插件化平台与多租户隔离：自定义 ClassLoader 能在一进程内提供清晰的依赖边界与热插拔能力。  正确使用 SPI、JDBC、JNDI、日志门面：都依赖 ServiceLoader + 线程上下文类加载器（TCCL）。  运行期增强与诊断：AOP、性能探针、日志埋点、线上热修复都离不开字节码增强与 Java Agent。1. JVM 类加载全流程与命名空间JVM 将一个 .class 从“字节序列”变为可执行的类元数据，经历如下阶段：1) 加载（Loading） ..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/nginx/2017/02/13/Nginx-%E8%BF%9E%E6%8E%A5%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html",
    "title": "Nginx 连接复用与四层负载均衡",
    "content": "对比四层（stream）与七层（http）转发，从操作系统并发与 I/O 机制出发系统性说明：Nginx 的网络设计、连接复用原理与 Linux 内核调优，并附可执行配置与观测建议。1. 从操作系统角度看网络并发模型高并发网络服务的核心是“如何在有限 CPU/内存下同时处理大量连接”。关键是并发模型与 I/O 机制：  进程/线程模型：每连接一个进程/线程，易编程，但上下文切换与栈内存开销在 1k～10k 连接下迅速放大。  事件驱动模型（Reactor/Proactor）：少量线程管理海量非阻塞 fd，依赖内核事件通知。内核 I/O 通知机制：  select/poll：线性扫描，fd 数/开销受限，不适合高并发。  epoll（Linux）：O(1) 监听大量 fd，边缘/水平触发，EPOLLEXCLUSIVE 降低惊群。  kqueue（BSD/macOS）：高效通用事件队列。  IO_uring（Linux 新）：提交/完成队列，绕过部分系统调用开销；Nginx 主线仍以 epoll 为主。Reactor vs Proactor：Nginx 采用 Reactor（事件到来..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/php/2016/08/17/PHP-FPM-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%8C%87%E5%8D%97.html",
    "title": "PHP-FPM 性能调优指南",
    "content": "本文系统性梳理 PHP-FPM 在高并发与高性能场景下的完整优化路径：从 Linux 操作系统内核与网络栈、到 Nginx 与 PHP-FPM 的通讯方式与参数调优，再到 PHP 运行时与业务代码层面的最佳实践，并给出生产可落地的配置示例与故障排查清单。目标读者为正在建设或运营中大型 PHP Web 服务的工程师与架构师。读者收益  清晰的容量规划方法与关键监控口径（QPS、P95/P99、错误率、队列长度）；  一套可复用的 Linux 内核与网络栈调优清单；  PHP-FPM pm 模式与核心参数的取舍建议与安全边界；  OPcache/JIT、realpath cache、Composer 自动加载与 APCu 等在生产中的最佳实践；  业务代码性能“十项准则”与常见反模式清单；  标准化配置样例：sysctl、systemd、Nginx、FPM pool 与 OPcache。一、性能目标与测量口径在优化之前，先把“好”的定义固定下来。  指标分层：          应用端：QPS、TP95/TP99 响应时间、错误率、超时率；      资源端：CPU 使用率、上下文切..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/mysql/2016/04/12/MySQL-%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%83%AD%E7%82%B9%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8FID%E5%AE%9E%E8%B7%B5.html",
    "title": "MySQL 自增主键热点与分布式 ID 实践",
    "content": "在高并发写入场景下，InnoDB 的自增主键（AUTO_INCREMENT）会在聚簇索引上形成尾部写热点，导致插入抖动与间歇性锁等待。本文从 InnoDB 聚簇索引结构、插入缓冲、间隙锁协同等维度拆解热点成因，并给出分布式 ID 的落地实践与权衡。1. 聚簇索引与尾部写热点  InnoDB 的聚簇索引以主键排序存储，AUTO_INCREMENT 会将新记录追加到 B+Tree 右侧叶子。  高并发插入时，右侧叶子页存在锁竞争与页分裂放大，表现为插入 TPS 下降与 P95/P99 波动。CREATE TABLE orders (  id BIGINT PRIMARY KEY AUTO_INCREMENT,  user_id BIGINT NOT NULL,  amount DECIMAL(10,2) NOT NULL,  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,  KEY idx_user (user_id)) ENGINE=InnoDB;2. AUTO_INCREMENT 锁与并发  MySQL 5.7 之前，AUTO_IN..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/golang/2015/11/02/Go-goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86GMP.html",
    "title": "Go goroutine 调度器原理：GMP",
    "content": "这篇文章不只是“是什么”，而是从语言设计动机与系统实现细节出发，系统性拆解 Go 调度器的三元模型：G（goroutine）、M（OS thread）、P（processor）。围绕“为什么要引入 GMP”“GMP 解决了什么问题”“有哪些代价与权衡”“如何直观理解并用实验证明”，我们给出多维度、可操作的深度解读。一、动机：Go 想解决什么问题？如果回到 2007–2009 年 Go 诞生的背景，Google 内部已经在大规模分布式系统中挣扎：  需要写高并发服务，却要在复杂的回调、线程与锁之间艰难取舍；  线程创建与上下文切换成本高，每个线程动辄 MB 级别栈内存；  I/O 与 CPU 混合型负载让“要么阻塞、要么回调”的模型两头不讨好；  C/C++ 缺少一等公民的并发原语，异步代码可读性差而且脆弱。Go 的答案可以浓缩为三点：  基于 CSP 的并发观：以 goroutine 与 channel 为一等公民，用“看起来可阻塞”的直观代码描述并发；  用户态调度器：把大量 goroutine 以 M:N 方式复用到少量 OS 线程上，降低成本并提升可伸缩性；  面向工程实战..."
  },

  {
    "url": "/%E6%8A%80%E6%9C%AF/java/2015/09/08/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8F%AF%E8%A7%81%E6%80%A7%E5%AE%9E%E8%B7%B5.html",
    "title": "Java 内存模型与可见性实践",
    "content": "JMM（Java Memory Model）定义了线程间可见性、原子性与有序性。本文通过可复现案例解释 volatile、happens-before、指令重排与发布/逃逸，并给出 JIT 层面的观测方法。1. 可见性问题复现public class StopFlagDemo {  // 去掉 volatile 观察现象  static /*volatile*/ boolean stop = false;  public static void main(String[] args) throws Exception {    new Thread(() -&amp;gt; { while (!stop) { } }).start();    Thread.sleep(100);    stop = true;  }}无 volatile 时，JIT 可能将 stop 缓存至寄存器，循环无法观察到主线程写入。2. JIT 观测（hsdis/PrintAssembly）启动参数：-XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX..."
  }

]


