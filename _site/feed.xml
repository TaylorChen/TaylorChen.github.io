<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-08-02T14:53:02+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">TayloyChen Blog</title><subtitle>这里是 TayloyChen 的个人博客，与你一起发现更大的世界 | 要做一个有 ikigai 的程序员</subtitle><entry><title type="html">Ai辅助编程中的llm选择最佳实践</title><link href="http://localhost:4000/2025/05/04/AI%E8%BE%85%E5%8A%A9%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84LLM%E9%80%89%E6%8B%A9%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html" rel="alternate" type="text/html" title="Ai辅助编程中的llm选择最佳实践" /><published>2025-05-04T00:00:00+08:00</published><updated>2025-05-04T00:00:00+08:00</updated><id>http://localhost:4000/2025/05/04/AI%E8%BE%85%E5%8A%A9%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84LLM%E9%80%89%E6%8B%A9%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5</id><content type="html" xml:base="http://localhost:4000/2025/05/04/AI%E8%BE%85%E5%8A%A9%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84LLM%E9%80%89%E6%8B%A9%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html"><![CDATA[<h1 id="ai辅助编程中的llm选择最佳实践">AI 辅助编程中的 LLM 选择最佳实践</h1>

<p><strong>看开发阶段、试不同模型、管好成本，最终找到最适合自己的方案</strong></p>

<p>软件开发有不同阶段，每个阶段需要 AI 的不同能力。开发分成四个阶段，并给出如何选择模型的建议：</p>

<h2 id="1-设计与架构阶段">1. 设计与架构阶段</h2>

<ul>
  <li>
    <p>需求：这个阶段你需要一个能深度思考、有丰富知识的模型，帮助理解业务需求并设计架构。</p>
  </li>
  <li>
    <p>推荐模型：OpenAI o1、Gemini 2.5 Pro、DeepSeek R1</p>
  </li>
  <li>
    <p>为什么选这些：这些模型推理能力强，能帮你做出清晰的早期决策</p>
  </li>
  <li>
    <p>成本建议：这里值得用高级模型，因为好的架构能省下后期改动的麻烦</p>
  </li>
</ul>

<h2 id="2-开发阶段">2. 开发阶段</h2>

<ul>
  <li>
    <p>需求：写代码时，需要模型能理解代码模式、建议补全、解释实现</p>
  </li>
  <li>
    <p>推荐模型：Gemini 2.5 Pro、GPT-4o、Grok 3</p>
  </li>
  <li>
    <p>额外亮点：Claude 3.7 Sonnet 虽然基准测试分数不最高，但很多开发者喜欢，建议多试试</p>
  </li>
  <li>
    <p>成本建议：简单编码用中档模型就够，复杂任务再用高级模型</p>
  </li>
</ul>

<h2 id="3-测试阶段">3. 测试阶段</h2>

<ul>
  <li>
    <p>需求：写测试时，模型要能发现边缘情况、写出可靠的测试代码</p>
  </li>
  <li>
    <p>推荐模型：Claude 3.7、OpenAI o1、GPT-4o Mini</p>
  </li>
  <li>
    <p>成本建议：普通测试用中档模型，复杂或关键测试用高级模型</p>
  </li>
</ul>

<h2 id="4-部署与审查阶段">4. 部署与审查阶段</h2>

<ul>
  <li>
    <p>需求：审查大段代码时，模型要有大上下文窗口，能一次看懂整个代码库</p>
  </li>
  <li>
    <p>推荐模型：Gemini 2.5 Pro、GPT-4o Mini、GPT-4.1、OpenAI o1</p>
  </li>
  <li>
    <p>成本建议：高级模型能加快审查速度，节省时间，值得投资</p>
  </li>
</ul>

<p><strong>实用建议：如何选到适合的模型</strong></p>

<p>除了按阶段选模型，还有一些实用技巧：</p>

<ul>
  <li>
    <p>从小模型开始：先试试中档模型（如 Claude 3 Haiku 或 GPT-3.5），不够用再升级</p>
  </li>
  <li>
    <p>任务分模型：在 Cline 中，可以为不同任务设置不同模型。比如头脑风暴用高级模型，日常编码用中档，写文档用便宜的</p>
  </li>
  <li>
    <p>关注花销：用 Cline 的 token 计数器，看看哪些任务花钱多，优化模型选择</p>
  </li>
  <li>
    <p>别只看分数：基准测试（如 MMLU Pro、Big CodeBench）只是参考，实际用起来可能不一样</p>
  </li>
  <li>
    <p>多试试：在不重要的项目上实验不同模型，找到感觉</p>
  </li>
  <li>
    <p>Plan/Act 分开选：Cline 有个 Plan/Act 模式，规划可以用推理强的模型（如 Gemini 2.5 Pro），实现用快又便宜的（如 Gemini 2.5 Flash Preview）</p>
  </li>
</ul>

<p><img src="/images/2e9ea54a25bedd353d5e06c076d9c7e4.jpeg" alt="Image" /></p>]]></content><author><name></name></author><summary type="html"><![CDATA[AI 辅助编程中的 LLM 选择最佳实践]]></summary></entry><entry><title type="html">数学思维思维模式</title><link href="http://localhost:4000/2024/08/18/%E6%95%B0%E5%AD%A6%E6%80%9D%E7%BB%B4%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F.html" rel="alternate" type="text/html" title="数学思维思维模式" /><published>2024-08-18T00:00:00+08:00</published><updated>2024-08-18T00:00:00+08:00</updated><id>http://localhost:4000/2024/08/18/%E6%95%B0%E5%AD%A6%E6%80%9D%E7%BB%B4%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F</id><content type="html" xml:base="http://localhost:4000/2024/08/18/%E6%95%B0%E5%AD%A6%E6%80%9D%E7%BB%B4%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F.html"><![CDATA[<h1 id="日常思考问题的5种数学思维思维模式">日常思考问题的5种数学思维思维模式</h1>

<h2 id="1-从不确定性中找到确定性">1. 从不确定性中找到确定性</h2>
<p>第一种数学思维源于概率论，叫作“从不确定性中找到确定性”。</p>

<p>假如一件事情的成功概率是20%，是不是意味着我重复做这件事5次就一定能成功呢?很多人会这样想，但事实并不是这样。如果我们把95%的概率定义为成功，那么，这件20%成功概率的事，你需要重复做14次才能成功。换句话说，你只要把这件20%成功概率的事重复做14次，你就有95%的概率能做成。
计算过程如下，对公式头疼的朋友可以直接略过。做1次失败的概率为:1-20%=80%=0.8
重复做n次都失败的概率是:80%”=1-95%=5%=0.05(重复做n次至少有1次成功的概率是95%，就相当于重复做 n次、每一次都不成功的概率是5%)</p>
<blockquote>
  <p>n = log0.08^0.05≈13.42</p>
</blockquote>

<p>所以，重复做14次，你成功的概率能达到 95%。
如果你要达到99%的成功概率，那么你需要重复做21次。
虽然这个世界上没有100%的成功概率，但是只要重复做大概率成功的事情，你成功的概率就能够接近100%。这就是从不确定性中找到确定性，这是概率论交给我们最重要的思维</p>

<h2 id="2-用动态的眼光看问题">2. 用动态的眼光看问题</h2>
<p>第二种数学思维源于微积分，叫做“用动态的眼光看问题”。</p>

<p>宏观上，我们看到的是位移，但是从微观的角度来看，整个过程是从加速度开始的：加速度累积，变成速度；速度累积，变成位移。这就是积分。反过来说，物体之所以会有位移，是因为<strong>加速度</strong>经过了一段时间的累积。而物体之所以会有速度，是因为加速度经过了一段时间的累积。而物体之所以会有位移，是因为加速度经过一段时间的累积。位移相对于时间的一阶导数是速度，速度相对时间的一阶导数是位移，微观上其实是每一个瞬间速度的累积。而位移的倒数，就是从宏观回到微观，去观察它瞬间的速度。这就是微分。</p>

<p>那么微积分对于我们日常生活到底有什么作用呢？
理解微积分，你看问题的眼光就会从静态变为动态。</p>

<p>加速度累积，变成速度；速度累积，变成位移，其实人也一样。你今天晚上努力学习了，但是一晚上的努力并不会直接变成你的能力。你的努力得积累一段时间，才会变成你的能力。而你有了能力，并不会马上作出成绩。你的能力得积累到一段时间，才会变成你的成绩。而你有了一次成绩，并不会马上得到领导的赏识。你的成绩也得积累一段时间，才会使你得到领导的赏识。
从努力到能力、到成绩、到赏识，是有一个过程的，有一个积分的效应。
努力的时候，希望瞬间得到大家的认可，但是出了问题后却不去想几个月前的懈怠。这是很多人容易走进的思维误区。</p>

<p>从本质上讲，微积分的思维方式就是用动态的眼光看问题。一件事情的结果并不是瞬间产生的，而是长期以来的积累效应造成的。出了问题，不要只看当时那个瞬间，只有从宏观一直追述到微观，才能找到问题的根源。</p>

<h2 id="3-公里体系">3. 公里体系</h2>
<p>第三种数学思维源于几何学，叫做公里体系。如果说公里体系是一个大树，那么，公里体系就是大树的树根。在几何学中，一旦制定了不同的公里，就会得到完全不同的知识体系。这就是公里体系的思维。</p>

<p>这种思维在我们的生活中非常重要，比如，每家公司都有自己的愿景、使命、价值观，或者说公司基因、文化。因为愿景，使命，价值观不同，公司与公司之间的行为和决策差异就会很大。一家公司的愿景、使命、价值观，就相当于这家公司的公里。公里直接决定了这家公司的各种行为往那个方向发展。所有的规章制度，工作流程，决策行为，都是在愿景，使命，价值观这些公里上“生长”出来的定理，他们构成这家公司的公里体系。而这个体系一定是完全自洽的。不管公司以后如何发展，只要有公里存在，就会演绎一出一套能够解决问题的新法则（定理）。</p>

<p>公理没有对错，不需要被证明，公理是一种选择，是一种共识，是一种基准原则。</p>

<p>制定不同的公理，就会得到完全不同的公理体系，并因此得到完全不同的结果。</p>

<h2 id="4-数字的方向性">4. 数字的方向性</h2>
<p>第四种数学思维源于代数，叫作“数字的方向性”。</p>

<p>数这个东西，除了大小，还有一个非常重要的属性：方向。在数学上，我们把有方向的数字叫作向量。</p>

<p>数其实是有方向的，在日常的工作和生活中可以得以体现。在公司做事情，两个人都是很有能力，合作的时候，如果他们的能力都往一个方向使，形成合力，这是最好的结果。但如果他们的能力不往一个方向使，反而相互牵制，那可能还不如把这件事情交给其中一个人来做。</p>

<h2 id="5-全局最优和达成共赢">5. 全局最优和达成共赢</h2>
<p>第五种数学思维源于博弈论，叫作“全局最优和达成共赢”。我们每天大大小小的决策，每个决策的背后逻辑就是一场博弈。</p>

<p>下围棋就是典型的博弈场景。没走一步棋，我的所得就是你的所失，我的所失就是你的所得。这是博弈论中典型的零和博弈。在零和博弈中，你一定要保持清醒：你要的是全局最优解，而不是局部的最优解。</p>

<p>经营公司也一样，不要总是想着每件事情都必须一凡风顺，如果你想得到最好的结果，在一些关键步骤上就要做出妥协。</p>

<p>除了零和博弈之外，还有一种是非零和博弈，它讲究共赢，共赢的前提是建立信任，但是建立信任特别不容易。</p>

<p>孔子说“三十而立，四十而不惑，五十而知天命，六十而耳顺，七十而从心所欲不逾矩”。<strong>所谓“从心所欲不逾矩”，不是说你要通过约束自己来让自己做的事情不越出边界，而是当你拥有符合规律的思维方式时，你做的事情根本就不会越出边界。</strong></p>

<p><img src="/images/0519229cd9a2269e743231065f8d2254.jpg" alt="Image" /></p>]]></content><author><name></name></author><summary type="html"><![CDATA[日常思考问题的5种数学思维思维模式]]></summary></entry><entry><title type="html">二八法则的一些思考</title><link href="http://localhost:4000/2024/03/25/%E4%BA%8C%E5%85%AB%E6%B3%95%E5%88%99%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83.html" rel="alternate" type="text/html" title="二八法则的一些思考" /><published>2024-03-25T00:00:00+08:00</published><updated>2024-03-25T00:00:00+08:00</updated><id>http://localhost:4000/2024/03/25/%E4%BA%8C%E5%85%AB%E6%B3%95%E5%88%99%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83</id><content type="html" xml:base="http://localhost:4000/2024/03/25/%E4%BA%8C%E5%85%AB%E6%B3%95%E5%88%99%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83.html"><![CDATA[<p>关于二八法则的另外一种叫法是80/20法则，或者叫关键少数法则。在生活工作方各方面都有体现：</p>

<p>在经济学领域，全球最富有的20%的人口，控制着世界收入的82.7%。</p>

<p>在软件领域，可以应用于优化软件工作，通过修复报告最多的错误的前20%，给定系统中80%的相关错误将被消除。</p>

<p>在运动锻炼上，20%的练习和习惯影响着80%的结果，受训者不应该专注于多种训练。</p>

<p>将二八法则落实到行动上，简单整理了如下方法</p>

<p><strong>做有复利积累的事情</strong></p>

<p>复利特别在经济学领域比较常用，例如做量化一般也会评估复利的长期收益(常说的利滚利)。最常见的复利即资产，即可以自行为持有人带来收益的东西，资产本身是固化的劳动，而靠其赚到的钱又可以固化为资产，从而以指数增长的方式增殖。当然，任何可以积累的东西都是具有复利效应：知识是可以积累下来的，积累的知识帮助做出更高概率正确的决策，带来更大的视野，从而有需求及动力学习更多知识；个人IP影响力是可以积累的，更高的影响力带来更大的曝光，接触更多优秀的人，有更多合作机会，反过来又增强个人的影响力。</p>

<p><strong>极致聚焦，做减法</strong></p>

<p>现实中每个人的精力有限，不太可能可以做所有的事情，要通过分析和评估来确定哪些是产生最大价值的关键因素。旦识别出关键因素，就需要对它们进行优先排序。这意味着要将资源和精力集中在那些最能产生效益的领域。识别并剔除那些消耗时间、金钱和资源但收益甚微的活动。在决策过程中，尽量减少不必要的选项和复杂性。通过简化流程，可以提高效率并减少错误。有效地利用资源，提高效率和产出。</p>

<p><strong>战略优于战术</strong></p>

<p>程序员应该都有感受，写代码最重要的是前面的思考的环节，写只占据很少时间，若思考不清晰，后续会有无尽的debug负担；做产品也一样，我个人看来，商业模式&gt;流量策略&gt;具体开发，商业模式定义了是否解决的是痛点问题，该问题是否给用户带来价值从而用户有付费意愿，该问题定义清楚后，流量策略和具体开发则是水到渠成的事情，而渠道的重要性往往要高于具体开发。</p>

<p><strong>发挥自己的比较优势</strong></p>

<p>社会分工之所以存在，是因为每个人有其比较优势，各自做擅长的事情并合作，会提升整体效率。对个人来说，发挥自己的比较优势，只做那 20% 自己擅长的或有热情的事情（热情本身也会变为擅长），其他事情则是最大程度自动化或者外包出去。当前AI能力如此强大，各细分领域服务极度充沛，特定问题付费解决可节省大量人力，成本远低于自己浪费时间。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[关于二八法则的另外一种叫法是80/20法则，或者叫关键少数法则。在生活工作方各方面都有体现：]]></summary></entry><entry><title type="html">实用mac软件推荐列表</title><link href="http://localhost:4000/2023/12/19/%E5%AE%9E%E7%94%A8Mac%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E5%88%97%E8%A1%A8.html" rel="alternate" type="text/html" title="实用mac软件推荐列表" /><published>2023-12-19T00:00:00+08:00</published><updated>2023-12-19T00:00:00+08:00</updated><id>http://localhost:4000/2023/12/19/%E5%AE%9E%E7%94%A8Mac%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E5%88%97%E8%A1%A8</id><content type="html" xml:base="http://localhost:4000/2023/12/19/%E5%AE%9E%E7%94%A8Mac%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E5%88%97%E8%A1%A8.html"><![CDATA[<p><strong>Apps</strong></p>

<p><strong>日常使用</strong></p>

<p>ClashX Pro：科学上网</p>

<p>只有先科学上网，才能装后面的</p>

<p>Notion：笔记输入 + 博客输出的工具</p>

<p>Chrome：浏览器</p>

<p>Xnip：截图工具</p>

<p>1password 7：密码管理工具</p>

<p>其它的也用过，还是这个原生 App 比较流畅</p>

<p>CleanMyMac X：Mac优化清理工具</p>

<p>Warp WindTerm iTerm2：终端</p>

<p>Alfred：本地搜索、应用启动、剪贴板 📋</p>

<p><strong>效率神器</strong></p>

<p>Karabiner-Elements：键盘键位修改神器</p>

<p>一些配置 <a href="https://gist.github.com/ycjcl868/3933cb65acedb5d771855dee927781d8">karabiner.json</a> ，主要是改 HHKB 和 Apple Keyboard</p>

<p><a href="https://dida365.com/">滴答清单</a> ：任务和规划时间（GTD）的应用</p>

<p><a href="https://flomoapp.com/">flomo</a> ：快速记录一些想法</p>

<p><a href="https://github.com/ripperhe/Bob/releases">Bob 社区版</a> ：划词翻译和截图翻译工具</p>

<p>支持多个翻译聚合还挺方便的</p>

<p><a href="https://inputsource.pro/">Input Source Pro</a> ：不同应用、不同网站自动切换输入法</p>

<p><a href="https://y.qq.com/">QQ Music</a> ：网络音乐服务产品</p>

<p><a href="https://srf.baidu.com/input/mac.html">百度五笔输入法</a></p>

<p>试过 Mac 上各类的五笔输入，还是这个好用</p>

<p><a href="https://netnewswire.com/">NetNewsWire</a> ：开源、免费、全平台的 RSS 订阅、阅读</p>

<p>订阅 <a href="https://github.com/ycjcl868/feeds/blob/master/index.opml">index.opml</a></p>

<p><a href="https://www.macbartender.com/Bartender4/">Bartender 4</a> ：菜单栏应用图标管理工具</p>

<p>管理挺方便，就是 Mac 屏中间刘海那块没适配好</p>

<p>OpenInTerminal：从 Finder 一键打开 Terminal</p>

<p>之前的 Go2Shell 似乎不维护了，就用了这个</p>

<p><a href="https://iina.io/">IINA</a> ：媒体播放器</p>

<p><a href="https://getkap.co/">Kap</a> ：开源录屏工具</p>

<p>可转成 gif、mp4，支持插件</p>

<p>新 Mac 生成 gif 基本是秒级导出</p>

<p><a href="https://www.taskpaper.com/">TaskPaper</a> ：文本编辑器模式的任务管理工具（GTD）</p>

<p>经常用来管理工作上需要长期跟进的事，和滴答清单结合使用</p>

<p>Mindnode</p>

<p><a href="https://telegram.org/">Telegram</a> ：相对匿名安全的聊天软件</p>

<p><a href="https://cubox.pro/">Cubox</a> ：一站式信息收集、阅读、管理和回顾</p>

<p>碎片化阅读时代的文章、视频收集器</p>

<p><a href="https://kyome.io/runcat/index.html?lang=en">RunCat</a> ：在任务栏奔跑的猫</p>

<p>猫奔跑的速度会随着CPU使用率提升而越来越快（新 Mac 怎么开发都没看猫奔跑过）</p>

<p><a href="https://magnet.crowdcafe.com/">Magnet</a> ：窗口管理</p>

<p><a href="https://github.com/MonitorControl/MonitorControl">MonitorControl</a> ：显示器亮度调节</p>

<p><a href="https://apps.apple.com/jp/app/standup/id1439378680?l=en&amp;mt=12">StandUp</a> ：提醒站立</p>

<p><a href="https://medium.com/@mariociabarra/wifriedx-in-depth-look-at-yosemite-wifi-and-awdl-airdrop-41a93eb22e48">WiFriedX</a> ：关闭 AWDL/AirDrop，优化 M1 系列 Mac 的 Wifi 连接</p>

<p> </p>

<p><strong>开发使用</strong></p>

<p><a href="https://code.visualstudio.com/">VSCode</a> ：代码编辑器</p>

<p>通过自带的 <a href="https://code.visualstudio.com/docs/editor/settings-sync">Settings Sync</a> 功能一键同步</p>

<p><a href="https://github.com/git-up/GitUp">GitUp</a> ：Git GUI 软件</p>

<p>比 SourceTree 等软件要简洁，日常开发中基本没有做不了 GUI 操作</p>

<p><a href="https://www.sublimetext.com/">Sublime Text</a> ：文本编辑器</p>

<p>准确来讲，经常用这个编辑器快速做一些纪要</p>

<p>DataGrip：数据库开发工具</p>

<p>Goland：Gopher 开发工具</p>

<p>Dash：API 文档和代码片段管理</p>

<p>一直在用，找 API 文档和用法太方便了</p>

<p><a href="https://www.postman.com/">Postman</a> ：API 调试神器</p>

<p><a href="https://github.com/oldj/SwitchHosts">SwitchHosts</a> ：管理、切换多个hosts 方案的工具</p>

<p>QuickLook 预览插件</p>

<p><a href="http://www.sagtau.com/quicklookjson.html">quicklook-json</a></p>

<p><a href="https://github.com/toland/qlmarkdown">qlmarkdown</a></p>

<p><a href="https://github.com/Marginal/QLVideo">QLVideo</a></p>

<p> </p>

<p><strong>System Configuration</strong></p>

<p>触摸板三指拖拽</p>

<p>系统设置 → 辅助功能 → 指针控制 → 触控板选项 → 启用拖移（三指拖移）</p>

<p>退格键响应速度</p>

<p>系统设置 → 键盘，按键重复 调到最快、重复前延迟调最短</p>

<p><a href="https://gist.github.com/laispace/666dd7b27e9116faece6?permalink_comment_id=3686810#gistcomment-3686810">Github clone 加速</a></p>

<p>屏保 <a href="https://aerialscreensaver.github.io/">Aerial</a></p>

<p> </p>

<p><strong>Dev</strong></p>

<p>brew</p>

<p>on-my-zsh</p>

<p>fzf</p>

<p>autojump</p>

<p><a href="https://github.com/jesseduffield/lazygit">lazygit</a> ：命令行版 Git GUI</p>

<p><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a> ：快速搜索文件/目录中包含的字符串</p>

<p>bat</p>

<p><a href="https://cli.github.com/">gh</a></p>

<p><a href="https://github.com/profclems/glab">glab</a></p>

<p><a href="https://github.com/TheYkk/git-switcher">git-switcher</a></p>

<p>graphviz</p>

<p>Node.js 相关</p>

<p>fnm</p>

<p>node 16 似乎用不了 node-gyp-build</p>

<p>Python 相关</p>

<p>pyenv</p>

<p>Java 相关</p>

<p><a href="https://github.com/jenv/jenv">jenv</a></p>

<p>Go</p>

<p>modd</p>

<p>tree</p>

<p>字体安装</p>

<p>brew install –cask font-fira-code font-jetbrains-mono</p>

<p> </p>

<p><strong>Plugins</strong></p>

<p>Alfred workflows</p>

<p><a href="https://github.com/jopemachine/alfred-chromium-workflow/">alfred-chromium-workflow</a> ：浏览器历史记录搜索</p>

<p>找一些页面很方便</p>

<p><a href="https://github.com/wensonsmith/YoudaoTranslator">YoudaoTranslator</a> ：有道搜索</p>

<p>平时直接 yd 中英文单词/句子 很方便</p>

<p><a href="https://github.com/ycjcl868/alfred-npmjs">NpmSearch</a> ：npm 包搜索</p>

<p>npm 包名 搜索一些包版本，同时支持任意 registry 源</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Apps]]></summary></entry><entry><title type="html">技术成长不用等十年拆墙式进阶指南</title><link href="http://localhost:4000/2019/03/18/%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF%E4%B8%8D%E7%94%A8%E7%AD%89%E5%8D%81%E5%B9%B4%E6%8B%86%E5%A2%99%E5%BC%8F%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97.html" rel="alternate" type="text/html" title="技术成长不用等十年拆墙式进阶指南" /><published>2019-03-18T00:00:00+08:00</published><updated>2019-03-18T00:00:00+08:00</updated><id>http://localhost:4000/2019/03/18/%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF%E4%B8%8D%E7%94%A8%E7%AD%89%E5%8D%81%E5%B9%B4%E6%8B%86%E5%A2%99%E5%BC%8F%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97</id><content type="html" xml:base="http://localhost:4000/2019/03/18/%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF%E4%B8%8D%E7%94%A8%E7%AD%89%E5%8D%81%E5%B9%B4%E6%8B%86%E5%A2%99%E5%BC%8F%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97.html"><![CDATA[<h1 id="技术成长不用等十年拆墙式进阶指南">技术成长不用等十年：拆墙式进阶指南</h1>

<p>身边总有人问：“每天写 CRUD，能成大牛吗？”“下班累得只想躺，哪有时间学新技术？”“学了半年框架，感觉还是没进步……”</p>

<p>技术成长的焦虑，往往源于把 “成为大牛” 当成了遥不可及的山顶。但真实的成长，从来不是闷头爬坡，而是像拆墙 —— 拆掉挡在眼前的认知墙、行动墙、业务墙。每拆一块砖，视野就开阔一分，3 年能抵别人 5 年，这才是接地气的进阶逻辑。</p>

<h2 id="一先拆认知墙别被-一万小时-吓住">一、先拆认知墙：别被 “一万小时” 吓住</h2>

<p>《异类》的一万小时理论火了之后，太多人盯着 “10 年” 这个数字焦虑。但没人告诉你：这一万小时，藏在每天的碎片里，甚至能和加班 “搭伙过日子”。</p>

<h3 id="1-别算总帐算-零钱">1. 别算总帐，算 “零钱”</h3>

<p>刚工作时我也觉得 “每天 3 小时” 是天方夜谭 —— 早上挤地铁，晚上加完班快 10 点，哪来整块时间？后来发现，把 “3 小时” 拆成 “5 分钟 + 15 分钟 + 20 分钟” 的零钱，反而更容易坚持。以学习 Java 开发为例：</p>

<ul>
  <li>
    <p>上班前 5 分钟：打开收藏的 Java 集合框架源码片段，看 ArrayList 的 add 方法实现，了解它如何动态扩容数组，增加元素。比如看到 add 方法里，当数组容量不足时，会创建一个新的更大的数组，并将原数组元素复制过去。</p>
  </li>
  <li>
    <p>午休后 15 分钟：用公司测试环境跑一段昨天学的多线程代码示例。例如写一个简单的多线程任务，模拟多个线程同时访问共享资源，观察线程安全问题，再尝试用 synchronized 关键字去解决。</p>
  </li>
  <li>
    <p>睡前 20 分钟：在手机备忘录写 “今日踩坑笔记”。比如今天在写数据库查询语句时，因为没有给某个字段加索引，导致查询速度极慢，通过给该字段添加索引，查询时间从十几秒缩短到了几百毫秒。</p>
  </li>
</ul>

<p>这样一天下来，40 分钟不算多，但每周就是 280 分钟，一年积累 14560 分钟 —— 差不多 242 小时，足够啃完一本像《Effective Java》这样的源码书。</p>

<h3 id="2-警惕-伪努力-的自我感动">2. 警惕 “伪努力” 的自我感动</h3>

<p>有人囤了 50G 教程，却只看了前 3 集；有人 GitHub 星标了 200 个项目，从没克隆过一个。这种 “收藏即学会” 的假努力，比不学习更坑 —— 它会让你产生 “我在进步” 的错觉。</p>

<p><strong>真成长的两个标志</strong>：</p>

<ul>
  <li>
    <p>能说出 “上周学会的东西，这周用到了”。例如上周学习了 Redis 缓存技术，这周在项目中给频繁查询的热点数据加上了 Redis 缓存，大大提高了系统响应速度。原本查询数据库需要几百毫秒的接口，现在通过 Redis 缓存，响应时间缩短到了几十毫秒。</p>
  </li>
  <li>
    <p>能指出 “以前写的代码，现在看是错的”。比如发现半年前写的单例模式代码，在多线程环境下会出现创建多个实例的问题，现在明白要使用双重检查锁机制或者静态内部类的方式来确保单例的唯一性。</p>
  </li>
</ul>

<h2 id="二再拆行动墙把-大目标-砸成-手边事">二、再拆行动墙：把 “大目标” 砸成 “手边事”</h2>

<p>“今年要吃透 JVM”“年底前搞定分布式系统”—— 这种目标喊完就忘，因为太像 “要吃一头大象”。真正能落地的行动，是把大象切成 “今天能吃一口” 的小块。</p>

<h3 id="1-目标拆解的-三阶落地法">1. 目标拆解的 “三阶落地法”</h3>

<p>以 “3 个月学好 MySQL” 为例，别一上来就说 “要懂索引原理”，按 “用→优→理” 三阶拆：</p>

<ul>
  <li>
    <p><strong>第 1 个月（用）</strong>：每天花 10 分钟，给写的 SQL 加 explain 分析。比如在写一个查询用户信息的 SQL 语句时，使用 explain 关键字查看执行计划，发现因为使用了 “select *”，没有明确指定需要的字段，导致全表扫描，查询效率低下。通过优化 SQL，只查询必要字段，速度得到了提升。</p>
  </li>
  <li>
    <p><strong>第 2 个月（优）</strong>：每周挑一个慢查询，试着改写成 join。例如原本有三次单表查询，分别查询用户表、订单表、商品表，通过分析业务逻辑，将其改写成一次联表查询，减少了数据库查询次数，大大提高了查询效率。原本需要多次查询数据库并在应用层进行数据组装，现在通过一次联表查询就获取到了所需的关联数据。</p>
  </li>
  <li>
    <p><strong>第 3 个月（理）</strong>：每周末花 1 小时，对着《高性能 MySQL》看一个索引类型。比如学习聚簇索引和非聚簇索引的区别，了解到聚簇索引按照数据行的物理存储顺序构建，适合范围查询；非聚簇索引则与数据行的物理存储顺序无关，适合等值查询。并通过在测试数据库中创建不同类型的索引，进行查询测试，加深理解。</p>
  </li>
</ul>

<p>每个阶段都能立刻用在工作里，成就感会推着你走。</p>

<h3 id="2-加班党的-偷时间-技巧">2. 加班党的 “偷时间” 技巧</h3>

<p>上周和一个大厂朋友聊天，他说 “我加班多，但两年升了高级，靠的是加班时‘顺手学’”：</p>

<ul>
  <li>
    <p>改 bug 时多问一句：“这个报错的底层原因是什么？” 比如遇到 NullPointerException 空指针异常报错，在修复 bug 的同时，顺手查阅 JVM 的空指针检查机制。了解到 JVM 在执行字节码指令时，当访问一个空引用的对象实例的属性或方法时，就会抛出这个异常。通过深入理解，以后在编写代码时能更注重对象的判空处理，避免类似问题。</p>
  </li>
  <li>
    <p>部署代码时多做一步：“加个监控指标行不行？” 例如在给接口部署上线时，顺便添加一个响应时间监控指标。通过使用 Prometheus 这样的监控工具，配置好相应的指标采集规则，就可以实时观察接口的响应时间变化。这不仅能帮助及时发现系统性能问题，还让自己学会了 Prometheus 的基础用法。</p>
  </li>
  <li>
    <p>下班前花 5 分钟：“今天的代码里，哪个地方能再简化一行？” 比如把重复的判断逻辑抽成工具类，练习了设计模式。原本在多个地方都有判断用户是否登录的重复代码，通过创建一个 UserUtil 工具类，将判断逻辑封装在其中，其他地方只需调用该工具类的方法，代码变得更加简洁、易维护，同时也加深了对设计模式中封装思想的理解。</p>
  </li>
</ul>

<p>加班不是成长的敌人，关键是别当 “代码搬运工”。</p>

<h2 id="三最后拆业务墙crud-里藏着-进阶密码">三、最后拆业务墙：CRUD 里藏着 “进阶密码”</h2>

<p>“天天写业务，哪有技术含量？” 这是最大的误解。业务代码就像土壤，能不能长出技术的苗，看你会不会 “深挖三铲”。</p>

<h3 id="1-业务代码的三层深挖法">1. 业务代码的三层深挖法</h3>

<p>拿最普通的 “用户注册” 功能举例：</p>

<ul>
  <li>
    <p><strong>第一层（功能）</strong>：完成表单校验、入库（这是基础）。在实现用户注册功能时，首先要对用户输入的用户名、密码、手机号等信息进行表单校验，确保格式正确且符合业务规则。例如用户名不能包含特殊字符，密码长度要在一定范围内等。校验通过后，将用户信息插入数据库的用户表中。</p>
  </li>
  <li>
    <p><strong>第二层（优化）</strong>：加个手机号格式缓存（不用每次查数据库），加个异步发送短信（不阻塞注册流程）—— 这就用到了缓存和多线程。可以使用 Redis 缓存来存储已经校验过的手机号格式，当下次有新用户注册输入手机号时，先从 Redis 中查询该手机号格式是否已经校验过，若已校验则直接通过，无需再进行复杂的格式校验逻辑，减少数据库查询压力。同时，为了避免发送注册成功短信时阻塞用户注册流程，可以使用多线程技术，将发送短信的任务放到一个新的线程中执行。例如在 Java 中，可以使用线程池来管理这些发送短信的线程，提高系统并发处理能力。</p>
  </li>
  <li>
    <p><strong>第三层（原理）</strong>：想想 “为什么用 Redis 存验证码？”“线程池参数怎么设才不炸？”—— 逼着自己关联底层知识。思考为什么选择 Redis 存储验证码，是因为 Redis 具有高性能、支持分布式、数据结构丰富等特点，适合存储验证码这种时效性强的数据。对于线程池参数设置，要考虑任务类型、并发量等因素。比如如果是 CPU 密集型任务，线程池大小不宜设置过大，防止过多线程竞争 CPU 资源；如果是 I/O 密集型任务，可以适当增大线程池大小，充分利用 CPU 空闲时间处理其他任务。通过这样深入思考，能将业务实现与底层技术原理紧密联系起来，提升技术深度。</p>
  </li>
</ul>

<p>我见过有人把注册功能写成 “分布式锁防重复提交”“消息队列削峰” 的案例，业务没变，但技术深度完全不同。</p>

<h3 id="2-用-业务问题-当钥匙">2. 用 “业务问题” 当钥匙</h3>

<p>别总等着 “学完再用”，要学会 “用了再学”。比如：</p>

<ul>
  <li>
    <p>发现 “订单查询慢”，就去学索引优化。在实际业务中，如果订单数据量较大，订单查询速度慢，通过分析发现是因为查询语句没有合理利用索引。这时就可以学习索引优化知识，比如为经常用于查询条件的字段创建合适的索引，选择合适的索引类型（如 B - Tree 索引、哈希索引等）。通过实际业务问题驱动学习，能更快掌握索引优化技巧，并应用到项目中，显著提升订单查询速度。</p>
  </li>
  <li>
    <p>遇到 “并发下单超卖”，就去学分布式锁。当电商系统中出现高并发下单时，可能会出现商品超卖问题。为了解决这个问题，需要学习分布式锁知识。可以了解基于 Redis、Zookeeper 等实现分布式锁的原理和方式。例如使用 Redis 的 SETNX 命令（SET if Not eXists）来实现简单的分布式锁，通过设置锁的过期时间来避免死锁。在实际项目中应用分布式锁，解决并发下单超卖问题，同时也加深了对分布式系统一致性问题的理解。</p>
  </li>
  <li>
    <p>老板说 “系统总崩”，就去学监控和高可用。如果系统经常崩溃，影响业务正常运行，此时就需要学习系统监控和高可用技术。可以使用如 Grafana + Prometheus 组合进行系统监控，实时监测系统的 CPU 使用率、内存使用率、磁盘 I/O、网络流量等指标，及时发现系统性能瓶颈。对于高可用架构，可以学习如何使用负载均衡、集群部署等技术，将系统部署到多个服务器上，当一台服务器出现故障时，其他服务器能继续提供服务，保证系统的高可用性。通过解决业务中的这些痛点问题，推动自己不断学习新的技术知识。</p>
  </li>
</ul>

<p>业务中的痛点，恰恰是最好的学习路标。去年有个同事，因为负责的后台总卡顿，硬着头皮学了 JVM 调优，现在成了团队里的 “性能优化专家”。</p>

<h2 id="四拆墙工具包3-个随时能用的小技巧">四、拆墙工具包：3 个随时能用的小技巧</h2>

<h3 id="1-5-分钟碎片法">1. 5 分钟碎片法</h3>

<ul>
  <li>
    <p>蹲坑时：刷一篇 “10 行代码讲透 ArrayList 扩容”。在手机上阅读相关技术文章，了解 ArrayList 在添加元素时，如果当前容量不足，是如何通过创建新数组、复制元素等步骤实现扩容的，加深对集合框架底层原理的理解。</p>
  </li>
  <li>
    <p>等电梯时：在脑子里过一遍 “今天改的那个 bug，根本原因是什么？”。回顾今天修复的某个代码错误，思考是因为逻辑判断失误、语法错误，还是对某个 API 的使用不当导致的，强化对问题的分析和解决能力。</p>
  </li>
  <li>
    <p>外卖到了还没开吃：打开 IDE，跑一遍昨天记的代码片段。比如昨天学习了一段关于文件读写的代码，利用这几分钟时间在 IDE 中运行一下，确保自己真正掌握了这段代码的功能和使用方法，同时也能加深记忆。</p>
  </li>
</ul>

<p>碎片时间不用学新知识，能复盘、能巩固就够了。</p>

<h3 id="2-进步可视化">2. 进步可视化</h3>

<p>找个笔记本，每天写三行：</p>

<ul>
  <li>
    <p>今天解决了什么问题？（哪怕是 “搞定了一个乱码 bug”）。例如今天在处理用户上传文件时，文件内容出现乱码，通过排查发现是文件编码格式与系统默认编码格式不一致，通过修改编码设置解决了这个问题。</p>
  </li>
  <li>
    <p>用到了什么知识点？（比如 “知道了 UTF - 8 和 GBK 的区别”）。在解决乱码问题过程中，了解到 UTF - 8 是一种变长编码，支持全球几乎所有字符集，而 GBK 是针对简体中文的编码，二者在编码范围、存储方式上有所不同。</p>
  </li>
  <li>
    <p>明天想搞懂什么？（比如 “为什么 Postman 发请求会跨域”）。由于在测试接口时发现使用 Postman 发送请求出现跨域问题，明天计划深入学习跨域产生的原因（浏览器的同源策略限制）以及解决方案（如使用 CORS、JSONP 等）。</p>
  </li>
</ul>

<p>三个月后翻一翻，会发现自己不知不觉懂了这么多。</p>

<h3 id="3-业务代码的-找茬游戏">3. 业务代码的 “找茬游戏”</h3>

<p>每次写完代码，问自己三个问题：</p>

<ul>
  <li>
    <p>这行代码，换个写法能更快吗？（比如用 for 循环代替 Stream，在数据量大时更快）。在处理一个对集合进行遍历操作的需求时，对比使用传统 for 循环和 Java 8 的 Stream API 的性能。通过测试发现，当集合数据量较大时，for 循环的执行效率更高，因为 Stream API 在内部会进行一些封装和函数式编程操作，有一定的性能开销。</p>
  </li>
  <li>
    <p>这段逻辑，加个日志能方便排错吗？（比如给支付流程加 “订单状态变更” 日志）。在实现支付功能时，为了便于后续排查问题，在订单状态发生变更的关键节点添加日志记录，如记录订单从 “待支付” 变为 “支付中”“支付成功”“支付失败” 等状态的时间、操作人等信息，方便在出现问题时快速定位和分析。</p>
  </li>
  <li>
    <p>这个功能，未来可能会怎么变？（比如用户量涨 10 倍，数据库要不要分表）。考虑到业务的发展，如果未来用户量大幅增长，现有的数据库表结构可能无法满足性能需求。提前思考是否需要进行数据库分表操作，以及分表的策略（如按时间分表、按用户 ID 取模分表等），培养对系统扩展性的思考能力。</p>
  </li>
</ul>

<p>找茬多了，慢慢就有了 “架构思维”。</p>

<h2 id="结语成长是-今天比昨天多懂一点">结语：成长是 “今天比昨天多懂一点”</h2>

<p>没人能一口吃成胖子，技术成长也不用等十年。你不用每天学 3 小时，每天 20 分钟够了；你不用立刻搞定分布式，先把手里的 SQL 写明白；你不用羡慕别人懂源码，先搞懂自己项目里的框架怎么配置。</p>

<p>就像拆墙，今天拆一块砖，明天拆一片瓦，突然有一天抬头，会发现自己已经站在以前仰望的高度。</p>

<p>现在打开你的 IDE，从改好眼前的第一行代码开始吧。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[技术成长不用等十年：拆墙式进阶指南]]></summary></entry></feed>